
#+TITLE: Sophie's Emacs Configuration
#+AUTHOR: Sophie Bosio
#+PROPERTY: header-args :tangle yes
#+STARTUP: overview

[[./images/config-screenshot.png]]

* About

This is my attempt at keeping my Emacs configuration organised and readable.

I write all my
initialisation code in this document as code blocks and then use
=org-babel-tangle= to extract those code blocks into a separate file. That new,
generated file becomes my =init.el=. This way, I can document my code and explain
my choices to my future self - and to anyone else who might be interested in looking at it.

If you're interested in this, it's called a "literate configuration" and there
are lots of great blog posts out there with inspiration and tips!

I've lifted a lot of code from [[https://github.com/rougier][Nicolas Rougier]] (especially his Org setup) and [[https://github.com/larstvei/][Lars Tveito]] and [[https://github.com/larstvei/dot-emacs/blob/master/init.org][his Emacs configuration]].

I'm at the very beginning of learning Emacs, so if you have any suggestions or improvements, I would be very happy to hear about them!


* Setup

** =init.el= Code

As mentioned, I use =org-babel-tangle= and this document, written in Org mode.

The code below extracts the elisp configuration code and creates/overwrites the
=~/.emacs.d/init.el= configuration file when the =.org=-file is saved.
Therefore, changes are only done in the =.org=-file, where writing longer
comments about how things work and why things are added is easier, and then the resulting =init.el=-file remains clean and without excessive comments.

This is what the =init.el= file should look like, prompting it to tangle the =init.org= file and replace itself with that code.

#+BEGIN_SRC emacs-lisp :tangle no
;; We need org in order to make use of the tangling functionality
(require 'org)
;; Open the org-mode configuration
(find-file (concat user-emacs-directory "init.org"))
;; Tangle the file
(org-babel-tangle)
;; Load the tangled file
(load-file (concat user-emacs-directory "init.el"))
;; Byte-compile it
(byte-compile-file (concat user-emacs-directory "init.el"))
#+END_SRC

** Git Tracking & Practicalities

Now we also don't need to track the generated =init.el= file on Git, since it is directly derived from =init.org=.

This code makes Git ignore changes to =init.el=:

#+BEGIN_SRC sh :tangle no
git update-index --assume-unchanged init.el
#+END_SRC

If you do want to start tracking the file again, you can use:

#+BEGIN_SRC sh :tangle no
git update-index --no-assume-unchanged init.el
#+END_SRC

** Lexical Scoping

First, I want lexical scoping for the =init=-file, so I will add that to the top of the file.

#+BEGIN_SRC emacs-lisp
;;; -*- lexical-binding: t -*-
#+END_SRC

** Tangling

Now to tangling! The rest of the text and code in this section is lifted directly from Lars' configuration.

The =init.el= should (after the first run) mirror the source blocks in the =init.org=. We can use =C-c C-v t= to run =org-babel-tangle=, which extracts the code blocks from the current file into a source-specific file (in this case a =.el=-file).

To avoid doing this each time a change is made we can add a function to the =after-save-hook= ensuring to always tangle and byte-compile =.org=-document after changes.

#+BEGIN_SRC emacs-lisp
   (defun tangle-init ()
     "If the current buffer is init.org the code-blocks are
   tangled, and the tangled file is compiled."
     (when (equal (buffer-file-name)
                  (expand-file-name (concat user-emacs-directory "init.org")))
       ;; Avoid running hooks when tangling.
       (let ((prog-mode-hook nil))
         (org-babel-tangle)
         (byte-compile-file (concat user-emacs-directory "init.el")))))

   (add-hook 'after-save-hook 'tangle-init)
   #+END_SRC

** Start-Up

I want to make some tweaks to improve startup performance. First, a common tweak is to disable the garbage collector during initialisation, and then resetting it afterwards.

#+BEGIN_SRC emacs-lisp
(setq gc-cons-threshold (* 50 1000 1000))

;; Set and reset threshold
(let ((old-gc-treshold gc-cons-threshold))
  (setq gc-cons-threshold most-positive-fixnum)
  (add-hook 'after-init-hook
            (lambda () (setq gc-cons-threshold old-gc-treshold))))
#+END_SRC

Set Emacs user directory explicitly:

#+BEGIN_SRC emacs-lisp
(setq user-emacs-directory "~/.emacs.d/")
(setq default-directory "~/")
#+END_SRC

Set UFT-8 as preferred coding system.

#+BEGIN_SRC emacs-lisp
(set-language-environment "UTF-8")
#+END_SRC

** Packages

To manage downloaded packages, Emacs comes with =package.el= installed. In
addition, I want to use =use-package= and the conveniently compatible =quelpa=, so let's make sure we have those loaded.

#+begin_src emacs-lisp
(require 'package)
(require 'use-package)
(setq use-package-always-ensure t)
#+end_src

Next, I'll set up my package sources. These are very common and well-maintained mirrors.

#+BEGIN_SRC emacs-lisp
(setq package-archives
      '(("GNU ELPA"     . "https://elpa.gnu.org/packages/")
        ("MELPA"        . "https://melpa.org/packages/")
        ("ORG"          . "https://orgmode.org/elpa/")
        ("MELPA Stable" . "https://stable.melpa.org/packages/")
        ("nongnu"       . "https://elpa.nongnu.org/nongnu/"))
      package-archive-priorities
      '(("GNU ELPA"     . 20)
        ("MELPA"        . 15)
        ("ORG"          . 10)
        ("MELPA Stable" . 5)
        ("nongnu"       . 0)))

(package-initialize)
#+END_SRC

I have a folder with extensions that have been downloaded manually. I'll add these to the =load-path= so Emacs knows where to look for them. My folder is called "local-extensions".

#+BEGIN_SRC emacs-lisp
(defvar local-extensions "~/.emacs.d/local-extensions/")
(add-to-list 'load-path  local-extensions)
(let ((default-directory local-extensions))
  (normal-top-level-add-subdirs-to-load-path))
#+END_SRC

And load custom settings from =custom.el= if it exists.

#+BEGIN_SRC emacs-lisp
(setq custom-file (concat user-emacs-directory "custom.el"))
(when (file-exists-p custom-file)
  (load custom-file))
#+END_SRC



* Interaction, Look & Feel

** Custom Keybindings

I keep a custom keybinding map that I add to per package, and then activate at
the end of the configuration. This keeps my custom bindings from being
overwritten by extensions' own bindings.

The first step is to create the custom keybinding map. We'll activate it in the
very last section, "Custom Keybindings".

#+begin_src emacs-lisp
(defvar custom-bindings-map (make-keymap)
  "A keymap for custom keybindings.")
#+end_src

** Sane Defaults

I have some defaults that I like to have in my config. Please note that this is
behaviour that /I/ consider sane, and want in my configuration. You should
definitely modify these to your tastes!

I want to reduce the number of UI elements that I don't use, so I'll remove those and inhibit some default behaviours. I'll also make the scrolling a little smoother.

#+BEGIN_SRC emacs-lisp
(setq inhibit-startup-message      t         ;; No startup message
      initial-scratch-message      nil       ;; Empty scratch buffer
      ring-bell-function          'ignore    ;; No bell
      display-time-default-load-average nil  ;; Don't show me load time
      default-directory            "~/"      ;; Set default directory
      scroll-margin                0         ;; Space between top/bottom
      use-dialog-box               nil       ;; Disable dialog
      auto-revert-interval         1         ;; Refresh buffers fast
      echo-keystrokes              0.1       ;; Show keystrokes fast
      frame-inhibit-implied-resize 1         ;; Don't resize frame implicitly
      sentence-end-double-space    nil       ;; No double spaces
      recentf-max-saved-items 1000           ;; Show more recent files
      save-interprogram-paste-before-kill t  ;; Save copies between programs
)

(set-fringe-mode 10)  ;; Fringe of 10
#+END_SRC

There are some default modes I want to disable to clean up the UI further.

#+BEGIN_SRC emacs-lisp
(dolist (mode
    '(tool-bar-mode        ;; Remove toolbar
      scroll-bar-mode      ;; Remove scollbars
      menu-bar-mode        ;; Remove menu bar
      blink-cursor-mode))  ;; Solid cursor, not blinking
    (funcall mode 0))
#+END_SRc

Some variables are buffer-local, so to change them globally, we need to use =setq-default= instead of the normal =setq=.

#+BEGIN_SRC emacs-lisp
(setq-default tab-width 4                       ;; Smaller tabs
              fill-column 80                    ;; Maximum line width
              split-width-threshold 160         ;; Split vertically by default
              split-height-threshold nil        ;; Split vertically by default
              frame-resize-pixelwise t          ;; Fine-grained frame resize
              auto-fill-function 'do-auto-fill  ;; Auto-fill-mode everywhere
)
#+END_SRC

I don't want to type out 'yes' or 'no' every time Emacs asks me something, so I'll set these to 'y' and 'n'.

#+BEGIN_SRC emacs-lisp
;; (fset 'yes-or-no-p 'y-or-n-p)
(setq use-short-answers t)
#+END_SRC

To avoid clutter, let's put all the auto-saved files into one and the same directory.

#+BEGIN_SRC emacs-lisp
(defvar emacs-autosave-directory
  (concat user-emacs-directory "autosaves/")
  "This variable dictates where to put auto saves. It is set to a
  directory called autosaves located wherever your .emacs.d/ is
  located.")

;; Sets all files to be backed up and auto saved in a single directory.
(setq backup-directory-alist
      `((".*" . ,emacs-autosave-directory))
      auto-save-file-name-transforms
      `((".*" ,emacs-autosave-directory t)))
#+END_SRC

I want to use the [[https://github.com/editorconfig/editorconfig-emacs][EditorConfig]] plugin, which helps maintain consistent coding
styles across editors when collaborating.

#+begin_src emacs-lisp
(use-package editorconfig
  :ensure t
  :config
  (editorconfig-mode 1))
#+end_src

And finally, I want scrolling to be a *lot* slower than it is by default.

#+BEGIN_SRC emacs-lisp
;; Smoother scrolling
(setq mouse-wheel-scroll-amount '(1 ((shift) . 1))) ;; one line at a time
(setq mouse-wheel-progressive-speed            nil) ;; don't accelerate scrolling
(setq mouse-wheel-follow-mouse                  't) ;; scroll window under mouse
(setq scroll-step                                1) ;; keyboard scroll one line at a time
(setq use-dialog-box                           nil) ;; Disable dialog
#+END_SRC

** Personal Defaults

Some of these, I can't argue are "sane" in general - but they're what I want.

*** Appearance

I prefer a bar cursor over a block cursor.

#+begin_src emacs-lisp
(setq-default cursor-type 'bar)
#+end_src

I want a small border around the whole frame, because I think it looks nicer. I
also want to set the fringe width.

#+BEGIN_SRC emacs-lisp
(add-to-list 'default-frame-alist '(internal-border-width . 22))
(set-fringe-mode 10)            ;; Set fringe width to 10
#+END_SRC

And when I open Emacs, I want it to open maximised and fullscreen by default.

#+BEGIN_SRC emacs-lisp
(set-frame-parameter (selected-frame) 'fullscreen 'maximized)
(add-to-list 'default-frame-alist     '(fullscreen . maximized))
;; (add-hook 'window-setup-hook          'toggle-frame-fullscreen t)  ;; F11
#+END_SRC

When coding, I want my delimiters (parentheses, brackets, etc.) to be colourised
in pairs. [[https://github.com/Fanael/rainbow-delimiters/tree/7919681b0d883502155d5b26e791fec15da6aeca][rainbow-delimiters]] does exactly that.

#+begin_src emacs-lisp
(use-package rainbow-delimiters
  :ensure t)

(add-hook 'prog-mode-hook #'rainbow-delimiters-mode)
#+end_src

*** Built-In Minor Modes

Minor modes I want to activate.

#+BEGIN_SRC emacs-lisp
(dolist (mode
    '(column-number-mode        ;; Show current column number in mode line
      delete-selection-mode     ;; Replace selected text when yanking
      dirtrack-mode             ;; Directory tracking in shell
      global-so-long-mode       ;; Mitigate performance for long lines
      global-visual-line-mode   ;; Break lines instead of truncating them
      global-auto-revert-mode   ;; Revert buffers automatically when they change
      recentf-mode              ;; Remember recently opened files
      savehist-mode             ;; Remember minibuffer prompt history
      save-place-mode           ;; Remember last cursor location in file
      show-paren-mode))         ;; Highlight matching parentheses
    (funcall mode 1))

(setq history-length 25)        ;; Only save the last 25 minibuffer prompts
(setq global-auto-revert-non-file-buffers t) ;; Revert Dired and other buffers
#+END_SRC
And I do want line numbers, but only in programming modes.

#+BEGIN_SRC emacs-lisp
(add-hook 'prog-mode-hook 'display-line-numbers-mode) ;; Only line numbers when coding
#+END_SRC

*** Custom Shortcuts

I have some commands I use a lot, and I'm not super great at lifting my pinky
for commands on the form =C-x y=, so I'll define some shortcuts to use instead.

Switch to the other window  =C-x o= \to  =M-o=.

#+begin_src emacs-lisp
(define-key custom-bindings-map (kbd "M-o") 'other-window)
#+end_src

*** Auto-Saving

I prefer having my files save automatically. Any changes I don't want, I just
don't commit to git. I use =auto-save-buffers-enhanced= to automatically save all
buffers, not just the ones I have open.

But since saving this file - the =init.org=-file - triggers recompilation of
=init.el=, it's really annoying if this file is autosaved when I write to it.
Therefore, I'll disable automatic saving for this file in particular.

#+BEGIN_SRC emacs-lisp
(use-package auto-save-buffers-enhanced
  :config
  (auto-save-buffers-enhanced t)
  (setq auto-save-buffers-enhanced-exclude-regexps '("init.org")))
#+END_SRC

*** Tabs vs. Indentation

One of the things that drove me the most insane when I first downloaded Emacs,
was the way it deals with indentation.

I want to use spaces instead of tabs. But if I'm working on a project that does
use tabs, I don't want to mess with other people's code, so I've used this
[[https://www.emacswiki.org/emacs/NoTabs][snippet]] from the Emacs Wiki to infer indentation style.

#+begin_src emacs-lisp
(defun infer-indentation-style ()
  ;; if our source file uses tabs, we use tabs, if spaces spaces, and if
  ;; neither, we use the current indent-tabs-mode
  (let ((space-count (how-many "^  " (point-min) (point-max)))
        (tab-count (how-many "^\t" (point-min) (point-max))))
    (if (> space-count tab-count) (setq indent-tabs-mode nil))
    (if (> tab-count space-count) (setq indent-tabs-mode t))))

(setq indent-tabs-mode nil)
(infer-indentation-style)
#+end_src

I want to disable electric indent mode when switching to a new major mode.

#+begin_src emacs-lisp
(add-hook 'after-change-major-mode-hook (lambda() (electric-indent-mode -1)))
#+end_src

Make backspace remove the whole tab instead of just deleting one space.

#+begin_src emacs-lisp
(setq backward-delete-char-untabify-method 'hungry)
#+end_src

Old configuration from a blog post. Note that I'm no longer using this:

#+BEGIN_SRC emacs-lisp :tangle no
;; Create a variable for our preferred tab width
(setq custom-tab-width 2)

;; Two callable functions for enabling/disabling tabs in Emacs
(defun disable-tabs () (setq indent-tabs-mode nil))
(defun enable-tabs  ()
  (local-set-key (kbd "TAB") 'tab-to-tab-stop)
  (setq indent-tabs-mode t)
  (setq tab-width custom-tab-width))

;; Hooks to Enable Tabs
(add-hook 'prog-mode-hook 'enable-tabs)
;; Hooks to Disable Tabs
(add-hook 'lisp-mode-hook 'disable-tabs)
(add-hook 'emacs-lisp-mode-hook 'disable-tabs)

;; Language-Specific Tweaks
(setq-default python-indent-offset custom-tab-width) ;; Python
(setq-default js-indent-level custom-tab-width)      ;; Javascript

;; Making electric-indent behave sanely
;; (setq-default electric-indent-inhibit t)

;; Inhibit electric indent mode when changing to new major mode
(add-hook 'after-change-major-mode-hook (lambda() (electric-indent-mode -1)))

;; Make the backspace properly erase the tab instead of
;; removing 1 space at a time.
(setq backward-delete-char-untabify-method 'hungry)

;;Visualize tabs as a pipe character - "|"
;; This will also show trailing characters as they are useful to spot.
(setq whitespace-style '(face tabs tab-mark trailing))
(custom-set-faces
 '(whitespace-tab ((t (:foreground "#636363")))))
(setq whitespace-display-mappings
  '((tab-mark 9 [124 9] [92 9]))) ; 124 is the ascii ID for '\|'
(global-whitespace-mode) ; Enable whitespace mode everywhere
#+END_SRC

*** Killing vs. Deleting

Another thing that bothered me, was how the =backward-kill-word= command
(C-delete/backspace) would delete not only trailing backspaces, but everything
behind it until it had deleted a word. Additionally, this was automatically
added to the kill ring. With this the help of some regexps, it behaves more like normal Ctrl-Backspace.

#+BEGIN_SRC emacs-lisp
;; Delete a word, a character, or whitespace
(defun custom/backward-delete ()
  (interactive)
  (cond
   ;; If you see a word, delete all of it
   ((looking-back (rx (char word)) 1)
    (custom/delete-dont-kill 1))
   ;; If you see a single whitespace and a word, delete both together
   ((looking-back (rx (seq (char word) (= 1 blank))) 1)
	(custom/delete-dont-kill 1))
   ;; If you see several whitespaces, delete them until the next word
   ((looking-back (rx (char blank)) 1)
    (delete-horizontal-space t))
   ;; If you see a single non-word character, delete that
   (t
    (backward-delete-char 1))))

;; Delete a word without adding it to the kill ring
(defun custom/delete-dont-kill (arg)
  "Delete characters backward until encountering the beginning of a word.
   With argument ARG, do this that many times.
   Don't kill, just delete."
  (interactive "p")
  (delete-region (point) (progn (backward-word arg) (point))))
#+END_SRC

Speaking of killing text, it's nice to be able to browse the kill ring.

#+begin_src emacs-lisp
(use-package browse-kill-ring
  :ensure t)
#+end_src

*** Killing Buffers

Sometimes, I'm putting some work away and I don't want those files to show up in
the buffer list. Killing a buffer with =C-x k= or marking several buffers in the
buffer list to kill them is fine, but can be a bit cumbersome.

I found this function in a [[https://superuser.com/questions/895920/how-can-i-close-all-buffers-in-emacs][Stack Exchange answer]]. It allows me to close the
current buffer easily by pressing =C-k=. If I prefix it, by writing =C-u C-k=, then
all "interesting" buffers are killed, leaving internal Emacs buffers intact.
This cleans up all the buffers I've opened or used myself.

#+begin_src emacs-lisp
(defun custom-kill-buffer-fn (&optional arg)
"When called with a prefix argument -- i.e., C-u -- kill all interesting
buffers -- i.e., all buffers without a leading space in the buffer-name.
When called without a prefix argument, kill just the current buffer
-- i.e., interesting or uninteresting."
(interactive "P")
  (cond
    ((and (consp arg) (equal arg '(4)))
      (mapc
        (lambda (x)
          (let ((name (buffer-name x)))
            (unless (eq ?\s (aref name 0))
              (kill-buffer x))))
        (buffer-list)))
    (t
      (kill-buffer (current-buffer)))))

(define-key custom-bindings-map (kbd "C-k") 'custom-kill-buffer-fn)
#+end_src

*** Language-Specific Commenting

I use =C-'= to comment/uncomment lines with [[https://github.com/redguardtoo/evil-nerd-commenter][Evil Nerd Commenter]]. It automatically
detects most programming languages and applies appropriate comment style.

#+begin_src emacs-lisp
(use-package evil-nerd-commenter
  :ensure t
  :bind (:map custom-bindings-map ("C-'" . evilnc-comment-or-uncomment-lines)))
#+end_src

*** Utilities

And finally, I want to use =ripgrep= as =grep=.

#+BEGIN_SRC emacs-lisp
(setq grep-command "rg -nS --no-heading "
      grep-use-null-device nil)
#+END_SRC

** Fonts

For the fixed-pitch font, I'm using a ligaturised version of Roboto Mono. It's a result of the
=a-better-ligaturizer= project and the ligaturised font can be found in the
[[https://github.com/lemeb/a-better-ligaturizer][repo]].

Please note that Org-specific faces are set in the "Org, Roam, & Obsidian" section.

#+begin_src emacs-lisp
(when (member "Roboto Mono" (font-family-list))
  (set-face-attribute 'default nil :font "Roboto Mono" :height 108)
  (set-face-attribute 'fixed-pitch nil :family "Roboto Mono"))

(when (member "Source Sans Pro" (font-family-list))
  (set-face-attribute 'variable-pitch nil :family "Source Sans Pro" :height 1.18))
#+end_src

=prettify-symbols-mode= displays greek letters nicely.

#+BEGIN_SRC emacs-lisp
(setq-default prettify-symbols-alist '(("lambda" . ?λ)
                                       ("delta"  . ?Δ)
                                       ("gamma"  . ?Γ)
                                       ("phi"    . ?φ)
                                       ("psi"    . ?ψ)))
#+END_SRC

The package =ligature.el= provides support for displaying the ligatures of
fonts that already have ligatures. Mine does, and seems to work just fine out
of the box with the ligatures defined on the package's page,

#+begin_src emacs-lisp
(require 'ligature)

(defvar ligature-def '("|||>" "<|||" "<==>" "<!--" "####" "~~>" "***" "||=" "||>"
                       ":::" "::=" "=:=" "===" "==>" "=!=" "=>>" "=<<" "=/=" "!=="
                       "!!." ">=>" ">>=" ">>>" ">>-" ">->" "->>" "-->" "---" "-<<"
                       "<~~" "<~>" "<*>" "<||" "<|>" "<$>" "<==" "<=>" "<=<" "<->"
                       "<--" "<-<" "<<=" "<<-" "<<<" "<+>" "</>" "###" "#_(" "..<"
                       "..." "+++" "/==" "///" "_|_" "www" "&&" "^=" "~~" "~@" "~="
                       "~>" "~-" "**" "*>" "*/" "||" "|}" "|]" "|=" "|>" "|-" "{|"
                       "[|" "]#" "::" ":=" ":>" ":<" "$>" "==" "=>" "!=" "!!" ">:"
                       ">=" ">>" ">-" "-~" "-|" "->" "--" "-<" "<~" "<*" "<|" "<:"
                       "<$" "<=" "<>" "<-" "<<" "<+" "</" "#{" "#[" "#:" "#=" "#!"
                       "##" "#(" "#?" "#_" "%%" ".=" ".-" ".." ".?" "+>" "++" "?:"
                       "?=" "?." "??" ";;" "/*" "/=" "/>" "//" "__" "~~" "(*" "*)"
                       "\\\\" "://"))

(ligature-set-ligatures 'prog-mode ligature-def)
(global-ligature-mode t)
#+end_src

I also want to be able to display emojis with the Apple emoji font. I usually
don't use it, though, so I won't activate the global mode.

#+BEGIN_SRC emacs-lisp
(use-package emojify
  :config
  (when (member "Apple Color Emoji" (font-family-list))
    (set-fontset-font
      t 'symbol (font-spec :family "Apple Color Emoji") nil 'prepend)))
#+END_SRC

** Themes

I really like the doom-themes, so I'll get those. My favourite for everyday use is the =doom-nord= theme.

#+BEGIN_SRC emacs-lisp
(use-package doom-themes
  :ensure t
  :config
  (setq doom-themes-enable-bold t    ; if nil, bold is universally disabled
        doom-themes-enable-italic t) ; if nil, italics is universally disabled
  (load-theme 'doom-nord t))
#+END_SRC

This theme cycling function is borrowed from Lars' [[https://github.com/larstvei/dot-emacs#theme][configuration]]. I'll bind
this function to =C-c C-t= in the "Keybindings" section.

#+begin_src emacs-lisp
(defvar favourite-themes '(doom-nord doom-nord-light doom-flatwhite))

(defun cycle-themes ()
  "Returns a function that lets you cycle your themes."
  (let ((themes favourite-themes))
    (lambda ()
      (interactive)
      ;; Rotates the thme cycle and changes the current theme.
      (let ((rotated (nconc (cdr themes) (list (car themes)))))
        (load-theme (car (setq themes rotated)) t))
      (message (concat "Switched to " (symbol-name (car themes)))))))
#+end_src

When changing themes interactively, as with =M-x load-theme=, the current custom
theme is not disabled, causing weird issues such as lingering borders. I'll advice =load-theme= to always
disable the currently enabled themes when switching.

#+begin_src emacs-lisp
(defadvice load-theme
    (before disable-before-load (theme &optional no-confirm no-enable) activate)
  (mapc 'disable-theme custom-enabled-themes))
#+end_src

** Mode Line

I really like Nicolas Rougier's [[https://github.com/rougier/nano-modeline][Nano Modeline]]. It's minimal, pretty, and has
some neat built-in features, like the option to put the modeline in the header
bar instead of at the bottom of the screen.

For some reason, the newest versions, after Version 1.0, don't work for me.
Therefore I have kept an old copy.

#+begin_src emacs-lisp
(require 'nano-modeline-old)
(nano-modeline-mode 1)
(setq nano-modeline-space-top      +0.60    ;; Space above the text
      nano-modeline-space-bottom   -0.60    ;; Space below the text
      nano-modeline-prefix         'status  ;; I want icons, not RW/RO signifiers
      nano-modeline-prefix-padding t)       ;; Padding between prefix and text
#+end_src

** Terminal Emulator

I like [[https://github.com/akermu/emacs-libvterm][vterm]] and usually just use that. I don't want it to double check with me
before killing an instance of the terminal, so I'll set it to just kill it.
I also really Lars' [[https://github.com/larstvei/dot-emacs#vterm][vterm functions]], so I'll use those as well. One is for
toggling the =vterm= buffer with the other open buffer, and another binds a
separate =vterm= instance to each =M-n= keystroke.

Lastly, deleting whole words doesn't work well in vterm by
default, so if anyone has a good tip for how to overwrite my custom bindings map
in just vterm, please do let me know :~)

#+begin_src emacs-lisp
(use-package vterm
  :defer  t

  :preface
  (let ((last-vterm ""))
    (defun toggle-vterm ()
      (interactive)
      (cond ((string-match-p "^\\vterm<[1-9][0-9]*>$" (buffer-name))
             (goto-non-vterm-buffer))
            ((get-buffer last-vterm) (switch-to-buffer last-vterm))
            (t (vterm (setq last-vterm "vterm<1>")))))

    (defun goto-non-vterm-buffer ()
      (let* ((r "^\\vterm<[1-9][0-9]*>$")
             (vterm-buffer-p (lambda (b) (string-match-p r (buffer-name b))))
             (non-vterms (cl-remove-if vterm-buffer-p (buffer-list))))
        (when non-vterms
          (switch-to-buffer (car non-vterms)))))

	(defun switch-vterm (n)
      (let ((buffer-name (format "vterm<%d>" n)))
        (setq last-vterm buffer-name)
        (cond ((get-buffer buffer-name)
               (switch-to-buffer buffer-name))
              (t (vterm buffer-name)
                 (rename-buffer buffer-name))))))

  :bind (:map custom-bindings-map
              ("C-z" . toggle-vterm)
              ("M-1" . (lambda () (interactive) (switch-vterm 1)))
              ("M-2" . (lambda () (interactive) (switch-vterm 2)))
              ("M-3" . (lambda () (interactive) (switch-vterm 3)))
              ("M-4" . (lambda () (interactive) (switch-vterm 4)))
              ("M-5" . (lambda () (interactive) (switch-vterm 5)))
              ("M-6" . (lambda () (interactive) (switch-vterm 6)))
              ("M-7" . (lambda () (interactive) (switch-vterm 7)))
              ("M-8" . (lambda () (interactive) (switch-vterm 8)))
              ("M-9" . (lambda () (interactive) (switch-vterm 9))))
        (:map vterm-mode-map
			  ("C-<backspace>" . (lambda () (interactive) (vterm-send-key (kbd "C-w")))))

  :config
  ;; Don't query about killing vterm buffers, just kill it
  (defadvice vterm (after kill-with-no-query nil activate)
    (set-process-query-on-exit-flag (get-buffer-process ad-return-value) nil)))
#+end_src

** Dashboard

It's perfectly fine to just land in the scratch buffer. I think it's practical
and aesthetically unproblematic. But I don't really use the scratch buffer that
much on startup - usually I just =C-x b= my way to where I need to go.

The =dashboard= extension gives you a welcoming and pretty landing buffer. I
point it to my own image, but the ='logo= banner is also really nice.

#+BEGIN_SRC emacs-lisp
(use-package dashboard
  :config
  (setq dashboard-display-icons-p     t) ;; display icons on both GUI and terminal
  (setq dashboard-icon-type 'nerd-icons) ;; use `nerd-icons' package
  (dashboard-setup-startup-hook)
  (setq dashboard-startup-banner         "~/Documents/dotfiles/images/emacs.png"
		dashboard-image-banner-max-width 150
		dashboard-banner-logo-title      "ELISP YOUR WAY TO HEAV3N"
		dashboard-center-content         t
		dashboard-set-footer             nil
		dashboard-page-separator         "\n\n\n"
		dashboard-items '((projects     . 5)
                          (recents      . 5)
                          (agenda       . 5))))
#+END_SRC

** Olivetti

=Olivetti= is a minor mode for centering text. For convenience, I'll bind it to =C-c C-o= to activate/deactivate it on the fly.

With the the font and font size I use, setting the =fill-column= variable to 4, means I can display /exactly/ 80 mono characters before the line is folded.

#+BEGIN_SRC emacs-lisp
(use-package olivetti
  :defer t
  :bind (:map custom-bindings-map ("C-c o" . olivetti-mode))
  :config
  (setq-default olivetti-body-width (+ fill-column 4)))
#+END_SRC

** Completion

For completions, I use [[https://github.com/minad/vertico][Vertico]] and a suite of other extensions that play well together:

- [[https://github.com/tumashu/vertico-posframe][vertico-posframe]]
- [[https://github.com/minad/consult][Consult]]
- [[https://github.com/minad/marginalia][Marginalia]]
- [[https://github.com/minad/corfu][corfu]]
- [[https://code.bsdgeek.org/adam/corfu-candidate-overlay][corfu-candidate-overlay]]
- [[https://github.com/minad/cape][cape]]
- [[https://github.com/oantolin/orderless][Orderless]]

Let's start by configuring =Vertico=.

#+begin_src emacs-lisp
(use-package vertico
  :config
  (vertico-mode 1)
  (setq vertico-count 25                       ; Show more candidates
		read-extended-command-predicate 'command-completion-default-include-p
		read-file-name-completion-ignore-case t  ; Ignore case of file names
		read-buffer-completion-ignore-case t     ; Ignore case in buffer completion
		completion-ignore-case t                 ; Ignore case in completion
))
#+end_src

Next, I want =Vertico= to appear in a small child frame, instead of as a
traditional minibuffer.

#+begin_src emacs-lisp
(use-package vertico-posframe
  :config
  (vertico-posframe-mode 1)
  (setq vertico-posframe-width 100
        vertico-posframe-height vertico-count))

#+end_src

Consult provides a /ton/ of search, navigation, and completion functionality. I
would definitely recommend looking at the documentation to learn more about all
that it can do.

#+begin_src emacs-lisp
(use-package consult
  :bind (:map custom-bindings-map
              ("C-x b"   . consult-buffer)
			  ("C-s"     . consult-line)
              ("M-s"     . consult-ripgrep)
			  ("C-c C-g" . consult-goto-line)))
#+end_src

=Marginalia= gives me annotations in the minibuffer.

#+begin_src emacs-lisp
(use-package marginalia
  :init 
  (marginalia-mode 1))
#+end_src

=corfu= gives me text completion at point.

#+begin_src emacs-lisp
(use-package corfu
  :custom
  (corfu-cycle t)                ;; Enable cycling for `corfu-next/previous'
  ;; (corfu-auto t)                 ;; Enable auto completion
  (corfu-auto-delay 0)           ;; No delay
  (corfu-auto-prefix 2)          ;; Start when this many characters have been typed
  (corfu-popupinfo-delay 0.5)    ;; Short delay
  ;; (corfu-separator ?\s)          ;; Orderless field separator
  ;; (corfu-quit-at-boundary nil)   ;; Never quit at completion boundary
  ;; (corfu-quit-no-match nil)      ;; Never quit, even if there is no match
  ;; (corfu-preview-current nil)    ;; Disable current candidate preview
  (corfu-preselect 'prompt)      ;; Preselect the prompt
  ;; (corfu-on-exact-match nil)     ;; Configure handling of exact matche

  :init
  (global-corfu-mode))

(use-package emacs
  :init
  ;; TAB cycle if there are only few candidates
  (setq completion-cycle-threshold 3)

  ;; Hide commands in M-x which do not apply to the current mode.
  ;; Corfu commands are hidden, since they are not supposed to be used via M-x.
  (setq read-extended-command-predicate
        #'command-completion-default-include-p)

  ;; Enable indentation+completion using the TAB key.
  ;; `completion-at-point' is often bound to M-TAB.
  (setq tab-always-indent 'complete))
#+end_src

=corfu-candidate-overlay= changes out the usual list of completion candidates to a
single overlaid suggestion. I don't usually
need to select between several candidates, so normally I don't really want a
whole list.

If there's only one candidate, I can
select and complete that word with TAB. If there are several candidates,
pressing TAB gives me the normal dropdown list.

I prefer this aesthetically, since it keeps the list out of the way for as long
as possible, but it's still available.

#+begin_src emacs-lisp :tangle no
(use-package corfu-candidate-overlay
  :after corfu
  :bind (:map corfu-map ("<tab>" . 'completion-at-point))
  :config
  (corfu-candidate-overlay-mode 1))
#+end_src

=corfu= also uses some of [[https://github.com/minad/cape][cape]]'s functionalities, so let's add that, too.

#+begin_src emacs-lisp
(use-package cape
  ;; Bind dedicated completion commands
  ;; Alternative prefix keys: C-c p, M-p, M-+, ...
  :bind (("C-c p p" . completion-at-point) ;; capf
         ("C-c p t" . complete-tag)        ;; etags
         ("C-c p d" . cape-dabbrev)        ;; or dabbrev-completion
         ("C-c p h" . cape-history)
         ("C-c p f" . cape-file)
         ("C-c p k" . cape-keyword)
         ("C-c p s" . cape-symbol)
         ("C-c p a" . cape-abbrev)
         ("C-c p l" . cape-line)
         ("C-c p w" . cape-dict)
         ("C-c p \\" . cape-tex)
         ("C-c p _" . cape-tex)
         ("C-c p ^" . cape-tex)
         ("C-c p &" . cape-sgml)
         ("C-c p r" . cape-rfc1345))
  :init
  ;; Add `completion-at-point-functions', used by `completion-at-point'.
  ;; NOTE: The order matters!
  (add-to-list 'completion-at-point-functions #'cape-dabbrev)
  (add-to-list 'completion-at-point-functions #'cape-file)
  (add-to-list 'completion-at-point-functions #'cape-elisp-block)
  (add-to-list 'completion-at-point-functions #'cape-history)
  (add-to-list 'completion-at-point-functions #'cape-keyword)
  (add-to-list 'completion-at-point-functions #'cape-tex)
  ;;(add-to-list 'completion-at-point-functions #'cape-sgml)
  ;;(add-to-list 'completion-at-point-functions #'cape-rfc1345)
  ;;(add-to-list 'completion-at-point-functions #'cape-abbrev)
  (add-to-list 'completion-at-point-functions #'cape-dict)
  ;;(add-to-list 'completion-at-point-functions #'cape-symbol)
  ;;(add-to-list 'completion-at-point-functions #'cape-line)
)
#+end_src

And [[https://github.com/oantolin/orderless][Orderless]] is a package for a completion /style/, that matches multiple
regexes, in any order. Let's use it together with Corfu.

#+begin_src emacs-lisp
(use-package orderless
  :ensure t
  :config
  (setq completion-styles '(orderless basic partial-completion)
        completion-category-overrides '((file (styles basic partial-completion)))
        orderless-component-separator "[ |]"))
#+end_src

** Snippets

[[https://github.com/joaotavora/yasnippet][YASnippet]] is a template system for Emacs that allows you to predefine snippets
you use often and insert them easily. I want snippets for basic Org-files,
Roam-notes, and other sequences often used.

#+begin_src emacs-lisp
(use-package yasnippet
  :diminish yas-minor-mode
  :defer 5
  :config
  (setq yas-snippet-dirs '("~/.emacs.d/snippets/"))
  (yas-global-mode 1)) ;; or M-x yas-reload-all if you've started YASnippet already.

;; Silences the warning when running a snippet with backticks (runs a command in the snippet)
(require 'warnings)
(add-to-list 'warning-suppress-types '(yasnippet backquote-change)) 
#+end_src

** Helpful & Which Key

Helpful is an improvement on Emacs' built-in *help* buffer. It's more user-friendly and easier to read.

#+BEGIN_SRC emacs-lisp
(use-package helpful
  :bind (:map custom-bindings-map
			  ("C-h f" . #'helpful-callable)
			  ("C-h v" . #'helpful-variable)
			  ("C-h k" . #'helpful-key)
			  ("C-h x" . #'helpful-command)
			  ("C-h d" . #'helpful-at-point)
			  ("C-h F" . #'helpful-function)))
#+END_SRC

[[https://github.com/justbur/emacs-which-key][which-key]] shows you available keybindings in the minibuffer. When you've started
to enter a command, it will show you where you can go from there.

#+begin_src emacs-lisp
(use-package which-key
  :config
  (which-key-mode))
#+end_src

** Flyspell

[[https://www.emacswiki.org/emacs/FlySpell][Flyspell]] enables on-the-fly spell checking and highlights misspelled words in
the way that you'd expect.

I've borrowed [[https://github.com/larstvei/dot-emacs#flyspell][Lars' function]] for cycling through languages from his config. The
below code ensures changing spelling language in one buffer does not affect the
spelling languages of other buffers. I mostly write in British English, but
adapt to American English when collaborating, so I'll add both.

#+begin_src emacs-lisp
(defun cycle-languages ()
  "Changes the ispell dictionary to the first element in
ISPELL-LANGUAGES, and returns an interactive function that cycles
the languages in ISPELL-LANGUAGES when invoked."
  (let ((ispell-languages (list "british" "norsk" "american" "italiano" "francais")))
    (lambda ()
      (interactive)
      ;; Rotates the languages cycle and changes the ispell dictionary.
      (let ((rotated (nconc (cdr ispell-languages) (list (car ispell-languages)))))
        (ispell-change-dictionary (car (setq ispell-languages rotated)))))))
#+end_src

I'll enable =flyspell-mode= for all text modes and use =flyspell-prog-mode= for
spell checking comments and strings in all programming modes. =C-c l= is bound to
a function returned from =cycle-languages=, giving a language switcher for every
buffer where flyspell is enabled.

#+begin_src emacs-lisp
(use-package flyspell
  :defer t
  :if (executable-find "aspell")
  :hook ((text-mode . flyspell-mode)
         (prog-mode . flyspell-prog-mode)
         (flyspell-mode . (lambda ()
                            (local-set-key
                             (kbd "C-c l")
                             (cycle-languages)))))
  :config
  (ispell-change-dictionary "british" t))
#+end_src

** Magit

Magit is a Git client specifically for Emacs, and it's super powerful.

Let's first make sure we're highlighting uncommitted changes.

#+begin_src emacs-lisp
(use-package diff-hl
  :config
  (global-diff-hl-mode))
#+end_src

Then configure Magit.

#+begin_src emacs-lisp
(use-package magit
  :bind (:map custom-bindings-map ("C-c m" . magit-status))
  :config
  (add-hook 'magit-pre-refresh-hook 'diff-hl-magit-pre-refresh)
  (add-hook 'magit-post-refresh-hook 'diff-hl-magit-post-refresh))
#+end_src

** Projectile
 
[[https://projectile.mx/][Projectile]] provides a convenient project interaction interface. I keep most of
my projects in a specific folder, so I'll set Projectile to check that path specifically.

#+begin_src emacs-lisp
(use-package projectile
  :bind (:map custom-bindings-map ("C-c p" . projectile-command-map))
  :config
  (setq projectile-project-search-path '("~/Dropbox/projects/")))
#+end_src

** PDF Tools

This displays PDFs in a much more beautiful way.

However, it takes a long time to load, so we'll wait to load it until we try to open a PDF. Then it'll take a long time to open the first PDF, but all the others will load quickly, and we don't need to spend any extra start-up time when we don't need to open any PDFs.

#+begin_src emacs-lisp
(use-package pdf-tools
  :defer t
  :mode "\\.pdf\\'"
  :bind (:map pdf-view-mode-map
              ("c" . (lambda ()
                       (interactive)
                       (if header-line-format
                           (setq header-line-format nil)
                         (nano-modeline-pdf-mode))))
              ("j" . pdf-view-next-line-or-next-page)
              ("k" . pdf-view-previous-line-or-previous-page))
  :init (pdf-loader-install)
  :config (add-to-list 'revert-without-query ".pdf"))
#+end_src

** LaTeX

I use AUCTeX to work with LaTeX files from within Emacs and it's a massive help.
It has a lot of different features, and I'd recommend checking out the
documentation to see all the stuff you can do with it.

#+begin_src emacs-lisp
(use-package auctex
  :hook
  (LaTeX-mode . turn-on-prettify-symbols-mode)
  (LaTeX-mode . turn-on-flyspell))
#+end_src

** ChatGPT Shell

[[https://github.com/xenodium/chatgpt-shell][chatgpt-shell]] allows you to query ChatGPT from OpenAI directly inside Emacs. It
also integrates with DALL-E and Org Babel.

#+begin_src emacs-lisp
(use-package chatgpt-shell
  :ensure t
  :custom
  ((chatgpt-shell-openai-key
    (lambda ()
      (auth-source-pass-get 'secret "openai-key")))))
#+end_src

For this, we need an OpenAI Key. I've stored mine in =~/.authinfo=.

#+begin_src emacs-lisp
;; The file ~/.authinfo has this line:
;; machine api.openai.com password OPENAI_KEY
(setq chatgpt-shell-openai-key
      (auth-source-pick-first-password :host "api.openai.com"))
#+end_src


* Org, Roam, & Obsidian

** Org

[[https://orgmode.org/][Org Mode]] is a smart text system that is used for organising notes, literate programming, time management, and a wide variety of other use cases. I've been interested in switching from my previous note-taking app, Obsidian, to using Org and Roam (described in the next section).

*Note* that I've set keybindings for Org and Roam in the "Keybindings" section.

Let's first make sure we're using Org.

#+BEGIN_SRC emacs-lisp
(use-package org)
#+END_SRC

*** Prettifying

We'll declutter by hiding leading starts in headings and emphasis markers (e.g.,
the slashes in  =/.../= ). We'll also use [[https://orgmode.org/manual/Special-Symbols.html]["pretty entities"]], which allow us to
insert special characters LaTeX-style by using a leading backslash (e.g., =\alpha= to
write the greek letter alpha) and display ellipses in a condensed way.

#+begin_src emacs-lisp
(setq org-adapt-indentation t
      org-hide-leading-stars t
      org-hide-emphasis-markers t
      org-pretty-entities t
	  org-ellipsis "  ·")
#+end_src

For source code blocks specifically, I want Org to display the contents using
the major mode of the relevant language. I also want TAB to behave inside the
source code block like it normally would when writing code in that language.

#+begin_src emacs-lisp
(setq org-src-fontify-natively t
	  org-src-tab-acts-natively t
      org-edit-src-content-indentation 0)
#+end_src

Log when TODOs are marked as done.

#+begin_src emacs-lisp
(setq org-log-done t)
#+end_src

Next, I always want to center the text and enable linebreaks in Org. I've added
a hook to activate =olivetti-mode= and =visual-fill-mode=
is always on.

#+begin_src emacs-lisp
(add-hook 'org-mode-hook 'olivetti-mode)
#+end_src

 =org-modern= styles and prettifies a lot of Org elements, such as
headings, lists, tables, and source code blocks. My setup is a simplified
version of the usage example in the [[https://github.com/minad/org-modern][GitHub repo]].

#+begin_src emacs-lisp
(use-package org-modern
  :config
  (setq
   org-auto-align-tags t
   org-tags-column 0
   org-fold-catch-invisible-edits 'show-and-error
   org-special-ctrl-a/e t
   org-insert-heading-respect-content t

   ;; Don't style the following
   org-modern-tag nil
   org-modern-priority nil
   org-modern-todo nil
   org-modern-table nil

   ;; Agenda styling
   org-agenda-tags-column 0
   org-agenda-block-separator ?─
   org-agenda-time-grid
   '((daily today require-timed)
	 (800 1000 1200 1400 1600 1800 2000)
	 " ┄┄┄┄┄ " "┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄")
   org-agenda-current-time-string
   "⭠ now ─────────────────────────────────────────────────")

  (global-org-modern-mode))
#+end_src

=org-superstar= is similar to =org-modern= but has some other options for styling.

#+begin_src emacs-lisp
(use-package org-superstar
  :config
  (setq org-superstar-leading-bullet " ")
  (setq org-superstar-special-todo-items t) ;; Makes TODO header bullets into boxes
  (setq org-superstar-todo-bullet-alist '(("TODO" . 9744)
                                          ("INPROG-TODO" . 9744)
                                          ("WORK" . 9744)
                                          ("STUDY" . 9744)
                                          ("SOMEDAY" . 9744)
                                          ("READ" . 9744)
                                          ("PROJ" . 9744)
                                          ("CONTACT" . 9744)
                                          ("DONE" . 9745)))
  ;; :hook (org-mode . org-superstar-mode)
  )
#+end_src

Increase the size of LaTeX previews in Org.

#+begin_src emacs-lisp
(plist-put org-format-latex-options :scale 2)
#+end_src

*** Org Text Faces

Make sure =variable-pitch-mode= is always active in Org buffers.

#+begin_src emacs-lisp
(add-hook 'org-mode-hook 'variable-pitch-mode)
#+end_src

Set the sizes and fonts for the various headings.

#+begin_src emacs-lisp
;; Resize Org headings
(dolist (face '((org-level-1 . 1.35)
                (org-level-2 . 1.3)
                (org-level-3 . 1.2)
                (org-level-4 . 1.1)
                (org-level-5 . 1.1)
                (org-level-6 . 1.1)
                (org-level-7 . 1.1)
                (org-level-8 . 1.1)))
  (set-face-attribute (car face) nil :font "Source Sans Pro" :weight 'bold :height (cdr face)))

;; Make the document title a bit bigger
(set-face-attribute 'org-document-title nil :font "Source Sans Pro" :weight
'bold :height 1.8)
#+END_src

Ensure some parts of the Org-document still uses =fixed-pitch= even when
=variable-pitch-mode= is on.

#+begin_src emacs-lisp
(require 'org-indent)
(set-face-attribute 'org-indent nil :inherit '(org-hide fixed-pitch))

;; Ensure that anything that should be fixed-pitch in Org files appears that way
(set-face-attribute 'org-block nil            :foreground nil :inherit
'fixed-pitch :height 0.85)
(set-face-attribute 'org-code nil             :inherit '(shadow fixed-pitch) :height 0.85)
(set-face-attribute 'org-indent nil           :inherit '(org-hide fixed-pitch) :height 0.85)
(set-face-attribute 'org-verbatim nil         :inherit '(shadow fixed-pitch) :height 0.85)
(set-face-attribute 'org-special-keyword nil  :inherit '(font-lock-comment-face
fixed-pitch))
(set-face-attribute 'org-meta-line nil        :inherit '(font-lock-comment-face fixed-pitch))
(set-face-attribute 'org-checkbox nil         :inherit 'fixed-pitch)
#+end_src

*** Time & Task Tracking

Let's first increase the number of possible priorities for Org tasks. I'll set
mine to =E= so that we have =A= through =E=, in total five levels.

#+begin_src emacs-lisp
(setq org-lowest-priority ?F)  ;; Gives us priorities A through F
(setq org-default-priority ?E) ;; If an item has no priority, it is considered [#E].

(setq org-priority-faces
      '((65 . "")
        (66 . "Gold1")
        (67 . "Goldenrod2")
        (68 . "PaleTurquoise3")
        (69 . "DarkSlateGray4")
        (70 . "PaleTurquoise4")))
#+end_src

Then I'll expand the list of default task states.

#+begin_src emacs-lisp
(setq org-todo-keywords
      '((sequence
		 "TODO" "PROJECT" "READ" "WAITING"        ; Needs further action
		 "|"
		 "DONE" "CANCELLED" "POSTPONED" "IDEA"))) ; Needs no action currently
#+end_src

And change their appearance slightly, to help differentiate between them. I'll
pick the colours straight from the official [[https://www.nordtheme.com/docs/colors-and-palettes][Nord theme pallette]].

#+begin_src emacs-lisp
(setq org-todo-keyword-faces
      '(("TODO"      :inherit (org-todo region) :foreground "#A3BE8C" :weight bold)
		("PROJECT"   :inherit (org-todo region) :foreground "#88C0D0" :weight bold)
        ("READ"      :inherit (org-todo region) :foreground "#8FBCBB" :weight bold)
		("WAITING"   :inherit (org-todo region) :foreground "#81A1C1" :weight bold)
		("DONE"      :inherit (org-todo region) :foreground "#4C566A" :weight bold)
		("CANCELLED" :inherit (org-todo region) :foreground "#BF616A" :weight bold)
		("POSTPONED" :inherit (org-todo region) :foreground "#D08770" :weight bold)
		("IDEA"      :inherit (org-todo region) :foreground "#EBCB8B" :weight bold)))
#+end_src

For whatever reason, I've had an issue with clocking in, where the default
keybinding used =TAB= instead of =C-i= to clock in, so I'll set that manually.

#+begin_src emacs-lisp
(define-key org-mode-map (kbd "C-c C-x C-i") 'org-clock-in)
#+end_src

I'm trying out the Get Things Done method by David Allen, using Nicolas Rougier's [[https://github.com/rougier/emacs-gtd][GTD configuration]] and Nicolas Petton's
[[https://emacs.cafe/emacs/orgmode/gtd/2017/06/30/orgmode-gtd.html][blog post]] on the subject.

The first step is to set the relevant directories.

#+BEGIN_SRC emacs-lisp
(setq org-directory "~/Dropbox/org/")
(setq org-agenda-files (list "inbox.org" "projects.org"))
#+END_SRC

Then to set up the relevant capture templates, with accompanying keybindings.

#+BEGIN_SRC emacs-lisp
(setq org-capture-templates
       `(("i" "Inbox" entry  (file "inbox.org")
        ,(concat "* TODO %?\n"
                 "/Entered on/ %U"))))
(defun org-capture-inbox ()
     (interactive)
     (call-interactively 'org-store-link)
     (org-capture nil "i"))
#+END_SRC

And then I have some keybindings for these functions.

For basic agenda and TODO-related keybindings, I'll use =C-c= followed by a
single, lower-case letter.

#+BEGIN_SRC emacs-lisp
(define-key custom-bindings-map (kbd "C-c l") 'org-store-link)
(define-key custom-bindings-map (kbd "C-c a") 'org-agenda)
(define-key custom-bindings-map (kbd "C-c c") 'org-capture)
(define-key custom-bindings-map (kbd "C-c t") 'org-todo)
#+END_SRC

I have some custom =.org=-files that I use to organise different parts of my
life (see "Org & Roam" section). I'll add keybindings to capture different
types of notes, each corresponding to a an =.org=-file type.

#+BEGIN_SRC emacs-lisp
(define-key custom-bindings-map (kbd "C-c i") 'org-capture-inbox)
#+END_SRC

*** Hugo

[[https://gohugo.io/][Hugo]] is a static site generator. By default, it uses a Markdown flavour called
Blackfriday. The package [[https://github.com/kaushalmodi/ox-hugo/][ox-hugo]] can export Org files to this format, and
also generate appropriate front-matter. I use it to write my blog in Org and
easily put it online.

#+BEGIN_SRC emacs-lisp
(use-package ox-hugo
  :after ox)
#+END_SRC

I've had a great time blogging with =ox-hugo=, but it's a little bothersome to
have to rewrite the front-matter required in the blog post for it to export
property every time, so below is a little snippet lifted from [[https://ox-hugo.scripter.co/doc/org-capture-setup/][ox-hugo's blog]].

The file =all-posts,org= needs to be present in 'org-directory' and the file's
heading must be "Blog Posts". It can even be a symlink pointing to the actual location of all-posts.org! If you've named yours differently, change these values.

#+begin_src emacs-lisp
(with-eval-after-load 'org-capture
  (defun org-hugo-new-subtree-post-capture-template ()
    "Returns `org-capture' template string for new Hugo post.
See `org-capture-templates' for more information."
    (let* ((title (read-from-minibuffer "Post Title: "))
           (fname (org-hugo-slug title)))
      (mapconcat #'identity
                 `(
                   ,(concat "* TODO " title)
                   ":PROPERTIES:"
                   ,(concat ":EXPORT_FILE_NAME: " fname)
                   ":END:"
                   "%?\n")          ;Place the cursor here finally
                 "\n")))

  (add-to-list 'org-capture-templates
               '("h"                ;`org-capture' binding + h
                 "Hugo post"
                 entry
                 (file+olp "all-posts.org" "Blog Posts")
                 (function org-hugo-new-subtree-post-capture-template))))
#+end_src

*** RevealJS

[[https://github.com/yjwen/org-reveal][org-reveal]] is exports your Org documents to [[https://revealjs.com/][RevealJS]] presentations. For nice
syntax highlighting, let's also add =htmlize.el=.

#+begin_src emacs-lisp
(use-package ox-reveal
  :config
  (setq org-reveal-root "file:///home/sophie/reveal.js"))
(use-package htmlize)
#+end_src

#+RESULTS:

In the properties of each Org presentation document, you can set the
=REVEAL-ROOT= either to the CDN distribution of reveal.js or to your download
location.

CDN: =#+REVEAL_ROOT: https://cdn.jsdelivr.net/npm/reveal.js=
Local copy: =#+REVEAL_ROOT: file:///d:/reveal.js=

** Babel

For working with code blocks in Org mode, I want to make sure code blocks are
not evaluated by default on export. I also want to add some languages.

#+begin_src emacs-lisp
(use-package ob
  :ensure nil
  :after org
  :config
  (setq org-export-use-babel nil
        org-confirm-babel-evaluate nil)
  (org-babel-do-load-languages
   'org-babel-load-languages
   '((emacs-lisp . t)
     (python     . t)
     (haskell    . t))))
#+end_src

For Python, use whatever interpreter is set by =python-shell-interpreter=.

#+begin_src emacs-lisp
(use-package ob-python
  :ensure nil
  :after (ob python)
  :config
  (setq org-babel-python-command python-shell-interpreter))
#+end_src

** Roam

[[https://roamresearch.com/][Roam]] is a smart note-taking system in the style of a personal knowledge
management system. [[https://www.orgroam.com/][org-roam]] is a port of this system that uses all plain-text Org-files.

I'm planning to transition some/all of my notetaking from Obsidian (see below)
to Roam, but have not done so yet. Details are described in the "Obsidian"
section.

For now, I have set up a Roam directory and added a simple configuration for
navigating Roam nodes.

#+begin_src emacs-lisp
(use-package org-roam
  :init
  (setq org-roam-v2-ack t)
  :custom
  (org-roam-directory "~/Dropbox/org/roam")
  (org-roam-completion-everywhere t)
  :bind (:map org-mode-map
		 ("C-c n l" . org-roam-buffer-toggle)
         ("C-c n f" . org-roam-node-find)
         ("C-c n i" . org-roam-node-insert))
  :config
  (org-roam-db-autosync-enable))
#+end_src

** Obsidian

[[https://obsidian.md/][Obsidian]] is a smart note-taking app with similar capabilities to those of Org
Roam. I've used Obsidian for a long time, but increasingly want to do my work
in Emacs. So why not just use Roam? Well, Obsidian has a lot of very nice
graphical features and a large, helpful community dedicated to personal
knowledge management. Therefore, I still prefer it over Roam, but I would like
to be able to access and edit my Obsidian notes via Emacs. Enter the
=obsidian.el= package.

#+begin_src emacs-lisp
(use-package obsidian
  :config
  (obsidian-specify-path "~/Dropbox/obsidian-personal")
  ;; If you want a different directory of `obsidian-capture':
  (setq obsidian-inbox-directory "Inbox")

  (add-hook
   'obsidian-mode-hook
   (lambda ()
	 ;; Replace standard command with Obsidian.el's in obsidian vault:
	 (local-set-key (kbd "C-c C-o") 'obsidian-follow-link-at-point)


	 ;; Use either `obsidian-insert-wikilink' or `obsidian-insert-link':
	 (local-set-key (kbd "C-c C-l") 'obsidian-insert-wikilink)

	 ;; Following backlinks
	 (local-set-key (kbd "C-c C-b") 'obsidian-backlink-jump)
	 
	 ;; Jump to another Obsidian note
	 (local-set-key (kbd "C-c C-j") 'obsidian-jump)

	 ;; Capture Obsidian note
	 (local-set-key (kbd "C-c C-a") 'obsidian-capture)
	 ))
  (global-obsidian-mode t))
#+end_src


* Email

** =mu4e=

=mu4e= (=mu= for Emacs) is the 

** =org-msg=

=org-msg= lets you compose your emails in Org mode, which is  more ergonomic
than plain text and the resulting HTML is much more beautiful.

#+begin_src emacs-lisp
(use-package org-msg
  :after (org mu4e)
  :config
  (add-to-list 'mu4e-compose-pre-hook 'org-msg-mode)
  (setq org-msg-enforce-css (concat user-emacs-directory "email-style.css")
        org-msg-options "html-postamble:nil toc:nil num:nil author:nil email:nil"
        org-msg-default-alternatives '((new           . (text html))
                                       (reply-to-html . (text html))
                                       (reply-to-text . (text)))
        org-msg-signature "

#+begin_signature
#+begin_export html

Best regards,
Sophie Bosio
#+end_export
#+end_signature\n"))
#+end_src


* Programming

** Eglot

[[https://github.com/joaotavora/eglot][Eglot]] (Emacs polyGLOT) is an LSP server client for Emacs that comes
pre-installed from Emacs 29. If using a previous version, you can of course also install
it manually!

#+begin_src emacs-lisp
(use-package eglot
  :defer t
  :hook
  (eglot-managed-mode . (lambda () (eglot-inlay-hints-mode -1)))
  (python-mode . eglot-ensure)
)
#+end_src

** Haskell

For Haskell, I think the regular =haskell-mode= is nice. I'll add Haskell
Interactive Mode, which you can read more about [[https://wiki.haskell.org/Emacs/Inferior_Haskell_processes][here]], as well as =haskell-doc-mode=
which uses eldoc consistently throughout.

I also want to use the tool [[https://github.com/ndmitchell/hoogle][Hoogle]] from directly within Emacs to quickly
look up functions and packages. I've set it up according to the GitHub docs, so
that =C-c h= opens a prompt and querying the database opens a help buffer inside
Emacs with the results.

#+BEGIN_SRC emacs-lisp
(use-package haskell-mode
  :defer t
  :hook ((haskell-mode . interactive-haskell-mode)
         (haskell-mode . haskell-doc-mode))
  :config
  (define-key haskell-mode-map "\C-ch" 'haskell-hoogle)
  (setq haskell-hoogle-command "hoogle"))
#+END_SRC

** OCaml

OCaml requires some setup for =ocp-indent=,

#+begin_src emacs-lisp
(use-package ocp-indent)
#+end_src

and for =merlin=.
 
#+begin_src emacs-lisp
(let ((opam-share (ignore-errors (car (process-lines "opam" "var" "share")))))
      (when (and opam-share (file-directory-p opam-share))
       ;; Register Merlin
       (add-to-list 'load-path (expand-file-name "emacs/site-lisp" opam-share))
       (autoload 'merlin-mode "merlin" nil t nil)
       ;; Automatically start it in OCaml buffers
       (add-hook 'tuareg-mode-hook 'merlin-mode t)
       (add-hook 'caml-mode-hook 'merlin-mode t)
       ;; Use opam switch to lookup ocamlmerlin binary
       (setq merlin-command 'opam)))
#+end_src

Then I want integration with Dune, Merlin, and utop for the full IDE-experience.

#+begin_src emacs-lisp
;; Major mode for OCaml programming
(use-package tuareg
  :mode (("\\.ocamlinit\\'" . tuareg-mode)))

;; Major mode for editing Dune project files
(use-package dune
  :ensure t)

;; Merlin provides advanced IDE features
(use-package merlin
  :config
  (add-hook 'tuareg-mode-hook #'merlin-mode)
  (add-hook 'merlin-mode-hook #'company-mode)
  ;; we're using flycheck instead
  (setq merlin-error-after-save nil))

(use-package merlin-eldoc
  :hook ((tuareg-mode) . merlin-eldoc-setup))

;; utop REPL configuration
(use-package utop
  :config
  (add-hook 'tuareg-mode-hook #'utop-minor-mode))
#+end_src

** Python

Let's first set the language interpreter.

#+begin_src emacs-lisp
(use-package python
  :interpreter ("python3" . python-mode)
  :config
  (setq python-shell-interpreter "python3.11")
  (add-hook 'python-mode
			(lambda () (setq forward-sexp-function nil))))
#+end_src

Note that you also need =pyright= for this! Installation will depend on your
system. It's available from [[https://pypi.org/project/pyright/][PyPI]]. On Ubuntu, I had the most luck installing via
snap:

#+begin_src shell :tangle no
sudo snap install pyright --classic
#+end_src

Then, I want to hide the modeline for inferior Python processes to save screen
space. There's a [[https://github.com/hlissner/emacs-hide-mode-line][dedicated package]] for this.

#+begin_src emacs-lisp
(use-package hide-mode-line
  :defer t
  :hook (inferior-python-mode . hide-mode-line-mode))
#+end_src

[[https://github.com/pythonic-emacs/blacken][Blacken]] is a package that uses the Python =black= package to reformat Python
buffers. I'll set it to work by default and enforce max line length.

#+begin_src emacs-lisp
(use-package blacken
  :defer t
  :custom
  (blacken-line-length t)
  :hook (python-mode-hook . blacken-mode))
#+end_src


* Custom Keybindings

*** Extra Keybindings

#+begin_src emacs-lisp
(use-package emacs
  :config
  (define-key custom-bindings-map (kbd "C-c C-t") (cycle-themes))
  (define-key custom-bindings-map [C-backspace] 'custom/backward-delete))
#+end_src

*** Activating the Keymap

Throughout the configuration, I've added bindings to my custom-bindings-map.
The last thing we need to to before we can call it a day, is to define a minor
mode for it and activate that mode. The below code does just that.

#+begin_src emacs-lisp
(define-minor-mode custom-bindings-mode
  "A mode that activates custom keybindings."
  :init-value t
  :keymap custom-bindings-map)
#+end_src




