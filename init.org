
#+TITLE: Sophie's Emacs Configuration
#+AUTHOR: Sophie Bosio
#+PROPERTY: header-args :tangle yes
#+OPTIONS: toc:2

[[./images/config-screenshot.png]]

* About

This is my attempt at keeping my Emacs configuration organised and readable.

I write all my initialisation code in this document as code blocks and then use
=org-babel-tangle= to extract those code blocks into a separate file. That new,
generated file becomes my =init.el=. This way, I can document my code and explain
my choices to my future self - and to anyone else who might be interested in looking at it.

If you're interested in this approach to writing and sharing your config, it's
called a "literate configuration" and there are lots of great blog posts out
there with inspiration and tips!

I've lifted a lot of code from the setups of [[https://github.com/rougier][Nicolas Rougier]] (especially his Org setup),
[[https://github.com/larstvei/dot-emacs/blob/master/init.org][Lars Tveito]], and [[https://github.com/jakebox/jake-emacs][Jacob Boxerman]], and I can heartily recommend checking those out.

I'm still relatively new to Emacs, so if you have any suggestions or
improvements, I would be very happy to hear about them!

* Table of Contents :TOC_2_gh:
- [[#about][About]]
- [[#setup][Setup]]
  - [[#initel-code][=init.el= Code]]
  - [[#git-tracking--practicalities][Git Tracking & Practicalities]]
  - [[#lexical-scoping][Lexical Scoping]]
  - [[#tangling][Tangling]]
  - [[#start-up][Start-Up]]
  - [[#packages][Packages]]
  - [[#external-software][External Software]]
- [[#sane-defaults][Sane Defaults]]
  - [[#ui-elements--default-behaviours][UI Elements & Default Behaviours]]
  - [[#short-answers][Short Answers]]
  - [[#auto-saved-directory][Auto-Saved Directory]]
  - [[#editor-config][Editor Config]]
  - [[#smoother-scrolling][Smoother Scrolling]]
- [[#custom-keybindings][Custom Keybindings]]
- [[#visuals][Visuals]]
  - [[#open-in-fullscreen][Open in Fullscreen]]
  - [[#frame-border][Frame Border]]
  - [[#programming-specific-visuals][Programming-Specific Visuals]]
  - [[#fonts-ligatures-and-symbols][Fonts, Ligatures, and Symbols]]
  - [[#themes][Themes]]
  - [[#mode-line][Mode Line]]
  - [[#dashboard][Dashboard]]
  - [[#text-centring][Text Centring]]
- [[#interaction][Interaction]]
  - [[#tweaking-default-behaviour][Tweaking Default Behaviour]]
  - [[#auto-saving][Auto-Saving]]
  - [[#tabs--indentation][Tabs & Indentation]]
  - [[#deleting-instead-of-killing][Deleting Instead of Killing]]
  - [[#killing-buffers][Killing Buffers]]
  - [[#selecting-regions][Selecting Regions]]
  - [[#undoredo][Undo/Redo]]
  - [[#ripgrep][Ripgrep]]
  - [[#terminal-emulator][Terminal Emulator]]
  - [[#completion-suite][Completion Suite]]
  - [[#snippets][Snippets]]
  - [[#better-help-buffers][Better Help Buffers]]
  - [[#spelling][Spelling]]
  - [[#version-control][Version Control]]
  - [[#project-management][Project Management]]
  - [[#viewing-pdfs][Viewing PDFs]]
  - [[#latex][LaTeX]]
  - [[#browser-preference][Browser Preference]]
  - [[#switching-windows][Switching Windows]]
  - [[#multiple-cursors][Multiple Cursors]]
- [[#org][Org]]
  - [[#visuals-1][Visuals]]
  - [[#tasks][Tasks]]
  - [[#get-things-done-setup]["Get Things Done" Setup]]
  - [[#registers][Registers]]
  - [[#agenda][Agenda]]
  - [[#pasting-images][Pasting Images]]
  - [[#toc-in-org-files][TOC in Org Files]]
  - [[#babel][Babel]]
  - [[#roam][Roam]]
  - [[#hugo][Hugo]]
  - [[#revealjs][RevealJS]]
- [[#programming][Programming]]
  - [[#preferences--extras][Preferences & Extras]]
  - [[#eglot][Eglot]]
  - [[#haskell][Haskell]]
  - [[#ocaml][OCaml]]
  - [[#python][Python]]
  - [[#clojure][Clojure]]
  - [[#coq][Coq]]
  - [[#nix][Nix]]
- [[#elfeed][Elfeed]]
- [[#activating-custom-keybindings][Activating Custom Keybindings]]

* Setup
** =init.el= Code

As mentioned, I use =org-babel-tangle= and this document, written in Org mode.

The code below extracts the elisp configuration code and creates/overwrites the
=~/.emacs.d/init.el= configuration file when the =.org=-file is saved.
Therefore, changes are only done in the =.org=-file, where writing longer
comments about how things work and why things are added is easier, and then the resulting =init.el=-file remains clean and without excessive comments.

This is what the =init.el= file should look like, prompting it to tangle the =init.org= file and replace itself with that code.

#+BEGIN_SRC emacs-lisp :tangle no
;; We need org in order to make use of the tangling functionality
(require 'org)
;; Open the org-mode configuration
(find-file (concat user-emacs-directory "init.org"))
;; Tangle the file
(org-babel-tangle)
;; Load the tangled file
(load-file (concat user-emacs-directory "init.el"))
;; Byte-compile it
(byte-compile-file (concat user-emacs-directory "init.el"))
#+END_SRC

** Git Tracking & Practicalities

Now we also don't need to track the generated =init.el= file on Git, since it is directly derived from =init.org=.

This code makes Git ignore changes to =init.el=:

#+BEGIN_SRC sh :tangle no
git update-index --assume-unchanged init.el
#+END_SRC

If you do want to start tracking the file again, you can use:

#+BEGIN_SRC sh :tangle no
git update-index --no-assume-unchanged init.el
#+END_SRC

** Lexical Scoping

First, I want lexical scoping for the =init=-file, so I will add that to the top of the file.

#+BEGIN_SRC emacs-lisp
;;; -*- lexical-binding: t -*-
#+END_SRC

** Tangling

Now to tangling! The rest of the text and code in this section is lifted directly from Lars' configuration.

The =init.el= should (after the first run) mirror the source blocks in the =init.org=. We can use =C-c C-v t= to run =org-babel-tangle=, which extracts the code blocks from the current file into a source-specific file (in this case a =.el=-file).

To avoid doing this each time a change is made we can add a function to the =after-save-hook= ensuring to always tangle and byte-compile =.org=-document after changes.

#+BEGIN_SRC emacs-lisp
   (defun tangle-init ()
     "If the current buffer is init.org the code-blocks are
   tangled, and the tangled file is compiled."
     (when (equal (buffer-file-name)
                  (expand-file-name (concat user-emacs-directory "init.org")))
       ;; Avoid running hooks when tangling.
       (let ((prog-mode-hook nil))
         (org-babel-tangle)
         (byte-compile-file (concat user-emacs-directory "init.el")))))

   (add-hook 'after-save-hook 'tangle-init)
   #+END_SRC

** Start-Up

I want to make some tweaks to improve startup performance. First, a common tweak is to disable the garbage collector during initialisation, and then resetting it afterwards.

#+BEGIN_SRC emacs-lisp
(setq gc-cons-threshold (* 50 1000 1000))

;; Set and reset threshold
(let ((old-gc-treshold gc-cons-threshold))
  (setq gc-cons-threshold most-positive-fixnum)
  (add-hook 'after-init-hook
            (lambda () (setq gc-cons-threshold old-gc-treshold))))
#+END_SRC

Fix IO bugs.

#+begin_src emacs-lisp
(setq process-adaptive-read-buffering nil)
(setq read-process-output-max (* 4 1024 1024))
#+end_src

Set Emacs user directory explicitly:

#+BEGIN_SRC emacs-lisp
(setq user-emacs-directory "~/.emacs.d/")
(setq default-directory "~/")
#+END_SRC

Set UFT-8 as preferred coding system.

#+BEGIN_SRC emacs-lisp
(set-language-environment "UTF-8")
#+END_SRC

** Packages

To manage downloaded packages, Emacs comes with =package.el= installed. In
addition, I want to use =use-package= and the conveniently compatible =quelpa=, so let's make sure we have those loaded.

#+begin_src emacs-lisp
(require 'package)
(require 'use-package)
(setq use-package-always-ensure t)
#+end_src

Next, I'll set up my package sources. These are very common and well-maintained mirrors.

#+BEGIN_SRC emacs-lisp
(setq package-archives
      '(("GNU ELPA"     . "https://elpa.gnu.org/packages/")
        ("MELPA"        . "https://melpa.org/packages/")
        ("ORG"          . "https://orgmode.org/elpa/")
        ("MELPA Stable" . "https://stable.melpa.org/packages/")
        ("nongnu"       . "https://elpa.nongnu.org/nongnu/"))
      package-archive-priorities
      '(("GNU ELPA"     . 20)
        ("MELPA"        . 15)
        ("ORG"          . 10)
        ("MELPA Stable" . 5)
        ("nongnu"       . 0)))

(package-initialize)
#+END_SRC

I have a folder with extensions that have been downloaded manually. I'll add these to the =load-path= so Emacs knows where to look for them. My folder is called "local-extensions".

#+BEGIN_SRC emacs-lisp
(defvar local-extensions "~/.emacs.d/local-extensions/")
(add-to-list 'load-path  local-extensions)
(let ((default-directory local-extensions))
  (normal-top-level-add-subdirs-to-load-path))
#+END_SRC

And load custom settings from =custom.el= if it exists.

#+BEGIN_SRC emacs-lisp
(setq custom-file (concat user-emacs-directory "custom.el"))
(when (file-exists-p custom-file)
  (load custom-file))
#+END_SRC

** External Software

I have started using Nix to manage most of my software, but I haven't figured
out how to set up everything yet. In the meantime, I keep this list of software
that is *not* yet in my Nix config.

*Utilities:*

- Fish
- Brave browser

*Programming languages++:*

- GHCi
- Stack
- Java
- Leiningen
- OCaml
- Racket
- Lua
- Idris
- Erlang

*Misc:*

- Roboto Mono with ligatures

* Sane Defaults

I have some defaults that I like to have in my config. Please note that this is
behaviour that /I/ consider sane, and want in my configuration. You should
definitely modify these to your tastes!

** UI Elements & Default Behaviours

I want to reduce the number of UI elements that I don't use, so I'll remove those and inhibit some default behaviours. I'll also make the scrolling a little smoother.

#+BEGIN_SRC emacs-lisp
(setq inhibit-startup-message      t         ;; No startup message
      initial-scratch-message      nil       ;; Empty scratch buffer
      ring-bell-function          'ignore    ;; No bell
      display-time-default-load-average nil  ;; Don't show me load time
      default-directory            "~/"      ;; Set default directory
      scroll-margin                0         ;; Space between top/bottom
      use-dialog-box               nil       ;; Disable dialog
      auto-revert-interval         1         ;; Refresh buffers fast
      echo-keystrokes              0.1       ;; Show keystrokes fast
      frame-inhibit-implied-resize 1         ;; Don't resize frame implicitly
      sentence-end-double-space    nil       ;; No double spaces
      recentf-max-saved-items 1000           ;; Show more recent files
      save-interprogram-paste-before-kill t  ;; Save copies between programs
)

(set-fringe-mode 10)  ;; Fringe of 10
#+END_SRC

There are some default modes I want to disable to clean up the UI further.

#+BEGIN_SRC emacs-lisp
(dolist (mode
    '(tool-bar-mode        ;; Remove toolbar
      scroll-bar-mode      ;; Remove scollbars
      menu-bar-mode        ;; Remove menu bar
      blink-cursor-mode))  ;; Solid cursor, not blinking
    (funcall mode 0))
#+END_SRc

Some variables are buffer-local, so to change them globally, we need to use =setq-default= instead of the normal =setq=.

#+BEGIN_SRC emacs-lisp
(setq-default tab-width 4                       ;; Smaller tabs
              fill-column 80                    ;; Maximum line width
              split-width-threshold 160         ;; Split vertically by default
              split-height-threshold nil        ;; Split vertically by default
              frame-resize-pixelwise t          ;; Fine-grained frame resize
              auto-fill-function 'do-auto-fill  ;; Auto-fill-mode everywhere
)
#+END_SRC

** Short Answers

I want to only provide short answers to Emacs' prompts. E.g., I want to type "y"
or "n" instead of out "yes" or "no".

#+BEGIN_SRC emacs-lisp
(setq use-short-answers t)
#+END_SRC

** Auto-Saved Directory

To avoid clutter, let's put all the auto-saved files into one and the same directory.

#+BEGIN_SRC emacs-lisp
(defvar emacs-autosave-directory
  (concat user-emacs-directory "autosaves/")
  "This variable dictates where to put auto saves. It is set to a
  directory called autosaves located wherever your .emacs.d/ is
  located.")

;; Sets all files to be backed up and auto saved in a single directory.
(setq backup-directory-alist
      `((".*" . ,emacs-autosave-directory))
      auto-save-file-name-transforms
      `((".*" ,emacs-autosave-directory t)))
#+END_SRC

** Editor Config

I want to use the [[https://github.com/editorconfig/editorconfig-emacs][EditorConfig]] plugin, which helps maintain consistent coding
styles across editors when collaborating.

#+begin_src emacs-lisp
(use-package editorconfig
  :ensure t
  :config
  (editorconfig-mode 1))
#+end_src

** Smoother Scrolling

And finally, I want scrolling to be a *lot* slower than it is by default.

#+BEGIN_SRC emacs-lisp
;; Smoother scrolling
(setq mouse-wheel-scroll-amount '(1 ((shift) . 1))) ;; one line at a time
(setq mouse-wheel-progressive-speed            nil) ;; don't accelerate scrolling
(setq mouse-wheel-follow-mouse                  't) ;; scroll window under mouse
(setq scroll-step                                1) ;; keyboard scroll one line at a time
(setq use-dialog-box                           nil) ;; Disable dialog
#+END_SRC

* Custom Keybindings

I keep a custom keybinding map that I add to per package, and then activate at
the end of the configuration. This keeps my custom bindings from being
overwritten by extensions' own bindings.

The first step is to create the custom keybinding map. We'll add bindings to it
throughout the config, and then activate it at the end of the config file, at
[[*Activating Custom Keybindings][Activating Custom Keybindings]].

#+begin_src emacs-lisp
(defvar custom-bindings-map (make-keymap)
  "A keymap for custom keybindings.")
#+end_src

* Visuals

Note that Org-specific visuals are in the dedicated Org section :~)

** Open in Fullscreen

When I open Emacs, I want it to open maximised and fullscreen by default.

#+BEGIN_SRC emacs-lisp
(set-frame-parameter (selected-frame) 'fullscreen 'maximized)
(add-to-list 'default-frame-alist     '(fullscreen . maximized))
;; (add-hook 'window-setup-hook          'toggle-frame-fullscreen t)  ;; F11
#+END_SRC

** Frame Border

I want a small border around the whole frame, because I think it looks nicer. I
also want to set the fringe width.

#+BEGIN_SRC emacs-lisp
(add-to-list 'default-frame-alist '(internal-border-width . 22))
(set-fringe-mode 10)            ;; Set fringe width to 10
#+END_SRC

** Programming-Specific Visuals

I prefer a bar cursor over a block cursor.

#+begin_src emacs-lisp
(setq-default cursor-type 'bar)
#+end_src

When coding, I want my delimiters (parentheses, brackets, etc.) to be colourised
in pairs. [[https://github.com/Fanael/rainbow-delimiters/tree/7919681b0d883502155d5b26e791fec15da6aeca][rainbow-delimiters]] does exactly that.

#+begin_src emacs-lisp
(use-package rainbow-delimiters
  :ensure t)

(add-hook 'prog-mode-hook #'rainbow-delimiters-mode)
#+end_src

I usually only need column numbers in programming mode.

#+BEGIN_SRC emacs-lisp
(add-hook 'prog-mode-hook 'display-line-numbers-mode)
#+END_SRC

** Fonts, Ligatures, and Symbols

For the fixed-pitch font, I'm using a ligaturised version of Roboto Mono. It's a result of the
=a-better-ligaturizer= project and the ligaturised font can be found in the
[[https://github.com/lemeb/a-better-ligaturizer][repo]].

Please note that Org-specific faces are set in the "Org, Roam, & Obsidian" section.

#+begin_src emacs-lisp
(when (member "Roboto Mono" (font-family-list))
  (set-face-attribute 'default nil :font "Roboto Mono" :height 108)
  (set-face-attribute 'fixed-pitch nil :family "Roboto Mono"))

(when (member "Source Sans Pro" (font-family-list))
  (set-face-attribute 'variable-pitch nil :family "Source Sans Pro" :height 1.18))
#+end_src

=prettify-symbols-mode= displays greek letters nicely.

#+BEGIN_SRC emacs-lisp
(setq-default prettify-symbols-alist '(("lambda" . ?λ)
                                       ("delta"  . ?Δ)
                                       ("gamma"  . ?Γ)
                                       ("phi"    . ?φ)
                                       ("psi"    . ?ψ)))
#+END_SRC

The package =ligature.el= provides support for displaying the ligatures of
fonts that already have ligatures. Mine does, and seems to work just fine out
of the box with the ligatures defined on the package's page,

#+begin_src emacs-lisp
(require 'ligature)

(defvar ligature-def '("|||>" "<|||" "<==>" "<!--" "####" "~~>" "***" "||=" "||>"
                       ":::" "::=" "=:=" "===" "==>" "=!=" "=>>" "=<<" "=/=" "!=="
                       "!!." ">=>" ">>=" ">>>" ">>-" ">->" "->>" "-->" "---" "-<<"
                       "<~~" "<~>" "<*>" "<||" "<|>" "<$>" "<==" "<=>" "<=<" "<->"
                       "<--" "<-<" "<<=" "<<-" "<<<" "<+>" "</>" "###" "#_(" "..<"
                       "..." "+++" "/==" "///" "_|_" "www" "&&" "^=" "~~" "~@" "~="
                       "~>" "~-" "**" "*>" "*/" "||" "|}" "|]" "|=" "|>" "|-" "{|"
                       "[|" "]#" "::" ":=" ":>" ":<" "$>" "==" "=>" "!=" "!!" ">:"
                       ">=" ">>" ">-" "-~" "-|" "->" "--" "-<" "<~" "<*" "<|" "<:"
                       "<$" "<=" "<>" "<-" "<<" "<+" "</" "#{" "#[" "#:" "#=" "#!"
                       "##" "#(" "#?" "#_" "%%" ".=" ".-" ".." ".?" "+>" "++" "?:"
                       "?=" "?." "??" ";;" "/*" "/=" "/>" "//" "__" "~~" "(*" "*)"
                       "\\\\" "://"))

(ligature-set-ligatures 'prog-mode ligature-def)
(global-ligature-mode t)
#+end_src

I also want to be able to display emojis with the Apple emoji font. I usually
don't use it, though, so I won't activate the global mode.

#+BEGIN_SRC emacs-lisp
(use-package emojify
  :config
  (when (member "Apple Color Emoji" (font-family-list))
    (set-fontset-font
      t 'symbol (font-spec :family "Apple Color Emoji") nil 'prepend)))
#+END_SRC

** Themes

I really like =doom-themes=, =ef-themes= and =nano-theme=.

#+BEGIN_SRC emacs-lisp
(use-package doom-themes
  :config
  (setq doom-themes-enable-bold t    ; if nil, bold is universally disabled
        doom-themes-enable-italic t) ; if nil, italics is universally disabled
  (load-theme 'doom-nord t))

(use-package ef-themes)

(use-package nano-theme
  :init
  (setq nano-light-background "#fafafa"
        nano-light-highlight "#f5f7f8"))
#+END_SRC

*** Changing Themes on the Fly

This theme cycling function is borrowed from Lars' [[https://github.com/larstvei/dot-emacs#theme][configuration]].

#+begin_src emacs-lisp
(defvar favourite-themes '(doom-nord nano-light))

(defun cycle-themes ()
  "Returns a function that lets you cycle your themes."
  (let ((themes favourite-themes))
    (lambda ()
      (interactive)
      ;; Rotates the thme cycle and changes the current theme.
      (let ((rotated (nconc (cdr themes) (list (car themes)))))
        (load-theme (car (setq themes rotated)) t))
      (message (concat "Switched to " (symbol-name (car themes)))))))
#+end_src

Let's bind it to a key.

#+begin_src emacs-lisp
(define-key custom-bindings-map (kbd "C-c b") (cycle-themes))
#+end_src

When changing themes interactively, as with =M-x load-theme=, the current custom
theme is not disabled, causing weird issues such as lingering borders. I'll
advice =load-theme= to always disable the currently enabled themes when switching.

#+begin_src emacs-lisp
(defadvice load-theme
  (before disable-before-load (theme &optional no-confirm no-enable) activate)
  (disable-theme 'nano-theme)
  (mapc 'disable-theme custom-enabled-themes))
#+end_src

*** Removing Themes from List View

I have some packages with themes I really like -
e.g., Doom themes - that also contain a lot of themes I /don't/ use, and I don't
want to see those when selecting among available themes. This little code
snippet shows only the themes I do use.

#+begin_src emacs-lisp :tangle no
(defvar my/visible-themes '("dichromacy"
							"doom-flatwhite"
							"doom-nord"
							"ef-maris-light"
							"eink"
							"modus-operandi"
							"nano-dark"
							"nano-light"
							"os1"
							"doom-solarized-light"
							"twilight-bright"))

(defun my/valid-themes (orig-fun theme-name)
  (and (funcall orig-fun theme-name)
       (member (symbol-name theme-name) my/visible-themes)))
(advice-add 'custom-theme-name-valid-p :around #'my/valid-themes)
#+end_src

** Mode Line

*** Nano Modeline

I really like Nicolas Rougier's [[https://github.com/rougier/nano-modeline][Nano Modeline]]. It's minimal, pretty, and has
some neat built-in features, like the option to put the modeline in the header
bar instead of at the bottom of the screen. This is what I use 99% of the time.

#+begin_src emacs-lisp
(defun my-nano-modeline (&optional default)
    (funcall nano-modeline-position
             `((nano-modeline-buffer-status) " "
               (nano-modeline-buffer-name) " "
               (nano-modeline-git-info))
             `((nano-modeline-cursor-position) " "
               (nano-modeline-window-dedicated))
             default))

(use-package nano-modeline
  :init
  ;; Disable the default modeline
  (setq-default mode-line-format nil)
  :config
  (setq nano-modeline-padding '(0.45 . 0.45))
  (my-nano-modeline 1))
#+end_src

*** Mini Echo

If I need to save some space, I think that [[https://github.com/liuyinz/mini-echo.el][mini-echo]] is pretty cool and a great
alternative. It displays the modeline in the echo area, making the screen feel
nice and spacious.

#+begin_src emacs-lisp :tangle no
(use-package mini-echo
  :config
  (setq mini-echo-default-segments
  '(:long ("major-mode" "buffer-name" "vcs" "buffer-position")
    :short ("buffer-position" "macro")))
  (setq mini-echo-window-divider-args '(t 1 1))
  (mini-echo-mode))
#+end_src

** Dashboard

A friendly welcome screen! Note that I point it to my own image, but the ='logo= banner is also really nice.

#+BEGIN_SRC emacs-lisp
(use-package dashboard
  :config
  (setq dashboard-display-icons-p     t) ;; display icons on both GUI and terminal
  (setq dashboard-icon-type 'nerd-icons) ;; use `nerd-icons' package
  (dashboard-setup-startup-hook)
  (setq dashboard-startup-banner         "~/Documents/dotfiles/images/emacs-standalone-E.png"
		dashboard-image-banner-max-width 110
		dashboard-banner-logo-title      "ELISP YOUR WAY TO HEAV3N"
		dashboard-center-content         t
		dashboard-set-footer             nil
		dashboard-page-separator         "\n\n\n"
		dashboard-items '((projects     . 5)
                          (recents      . 5)
                          (agenda       . 5))))
#+END_SRC

** Text Centring

[[https://github.com/rnkn/olivetti][Olivetti]] is a minor mode for centering text. For convenience, I'll bind it to =C-c C-o= to activate/deactivate it on the fly.

#+BEGIN_SRC emacs-lisp
(use-package olivetti
  :defer t
  :bind (:map custom-bindings-map ("C-c o" . olivetti-mode))
  :config
  (setq olivetti-style t))
  ;; (setq-default olivetti-body-width (+ fill-column 4)))
#+END_SRC

In addition, I use [[https://elpa.gnu.org/packages/adaptive-wrap.html][adaptive-wrap]] to visually wrap lines.

#+begin_src emacs-lisp
(use-package adaptive-wrap
  :defer t
  :hook (visual-line-mode . adaptive-wrap-prefix-mode))
#+end_src

* Interaction
** Tweaking Default Behaviour

#+BEGIN_SRC emacs-lisp
(dolist (mode
    '(column-number-mode        ;; Show current column number in mode line
      delete-selection-mode     ;; Replace selected text when yanking
      dirtrack-mode             ;; Directory tracking in shell
      global-so-long-mode       ;; Mitigate performance for long lines
      global-visual-line-mode   ;; Break lines instead of truncating them
      global-auto-revert-mode   ;; Revert buffers automatically when they change
      recentf-mode              ;; Remember recently opened files
      savehist-mode             ;; Remember minibuffer prompt history
      save-place-mode           ;; Remember last cursor location in file
      show-paren-mode))         ;; Highlight matching parentheses
    (funcall mode 1))

(setq history-length 25)        ;; Only save the last 25 minibuffer prompts
(setq global-auto-revert-non-file-buffers t) ;; Revert Dired and other buffers
#+END_SRC

** Auto-Saving

I prefer having my files save automatically. Any changes I don't want, I just
don't commit to git. I use =auto-save-buffers-enhanced= to automatically save all
buffers, not just the ones I have open.

But since saving this file - the =init.org=-file - triggers recompilation of
=init.el=, it's really annoying if this file is autosaved when I write to it.
Therefore, I'll disable automatic saving for this file in particular.

#+BEGIN_SRC emacs-lisp
(use-package auto-save-buffers-enhanced
  :config
  (auto-save-buffers-enhanced t)
  (setq auto-save-buffers-enhanced-exclude-regexps '("init.org")))
#+END_SRC

** Tabs & Indentation

One of the things that drove me the most insane when I first downloaded Emacs,
was the way it deals with indentation.

I want to use spaces instead of tabs. But if I'm working on a project that does
use tabs, I don't want to mess with other people's code, so I've used this
[[https://www.emacswiki.org/emacs/NoTabs][snippet]] from the Emacs Wiki to infer indentation style.

#+begin_src emacs-lisp
(defun infer-indentation-style ()
  "Default to no tabs, but use tabs if already in project"
  (let ((space-count (how-many "^  " (point-min) (point-max)))
        (tab-count   (how-many "^\t" (point-min) (point-max))))
    (if (> space-count tab-count) (setq indent-tabs-mode nil))
    (if (> tab-count space-count) (setq indent-tabs-mode t))))

(setq indent-tabs-mode nil)
(infer-indentation-style)
#+end_src

I want to disable electric indent mode.

#+begin_src emacs-lisp
(electric-indent-mode -1)
#+end_src

Set backtab to =indent-rigidly-left=. Then I can easily unindent regions that use
spaces instead of tabs.

#+begin_src emacs-lisp
(define-key custom-bindings-map (kbd "<backtab>") 'indent-rigidly-left)
#+end_src

And finally, make backspace remove the whole tab instead of just deleting one space.

#+begin_src emacs-lisp
(setq backward-delete-char-untabify-method 'hungry)
#+end_src

** Deleting Instead of Killing

Another thing that bothered me, was how the =backward-kill-word= command
(C-delete/backspace) would delete not only trailing backspaces, but everything
behind it until it had deleted a word. Additionally, this was automatically
added to the kill ring. With this the help of some regexps, it behaves more like normal Ctrl-Backspace.

#+BEGIN_SRC emacs-lisp
;; Delete a word, a character, or whitespace
(defun custom/backward-delete ()
  (interactive)
  (cond
   ;; If you see a word, delete all of it
   ((looking-back (rx (char word)) 1)
    (custom/delete-dont-kill 1))
   ;; If you see a single whitespace and a word, delete both together
   ((looking-back (rx (seq (char word) (= 1 blank))) 1)
	(custom/delete-dont-kill 1))
   ;; If you see several whitespaces, delete them until the next word
   ((looking-back (rx (char blank)) 1)
    (delete-horizontal-space t))
   ;; If you see a single non-word character, delete that
   (t
    (backward-delete-char 1))))

;; Delete a word without adding it to the kill ring
(defun custom/delete-dont-kill (arg)
  "Delete characters backward until encountering the beginning of a word.
   With argument ARG, do this that many times.
   Don't kill, just delete."
  (interactive "p")
  (delete-region (point) (progn (backward-word arg) (point))))
#+END_SRC

Let's bind this in my custom keybindings map.

#+begin_src emacs-lisp
(define-key custom-bindings-map [C-backspace] 'custom/backward-delete)
#+end_src

Speaking of killing text, it's nice to be able to browse the kill ring.

#+begin_src emacs-lisp
(use-package browse-kill-ring
  :ensure t)
#+end_src

** Killing Buffers

Sometimes, I'm putting some work away and I don't want those files to show up in
the buffer list. Killing a buffer with =C-x k= or marking several buffers in the
buffer list to kill them is fine, but can be a bit cumbersome.

I found this function in a [[https://superuser.com/questions/895920/how-can-i-close-all-buffers-in-emacs][Stack Exchange answer]]. It allows me to close the
current buffer easily by pressing =C-k=. If I prefix it, by writing =C-u C-k=, then
all "interesting" buffers are killed, leaving internal Emacs buffers intact.
This cleans up all the buffers I've opened or used myself.

#+begin_src emacs-lisp
(defun custom-kill-buffer-fn (&optional arg)
"When called with a prefix argument -- i.e., C-u -- kill all interesting
buffers -- i.e., all buffers without a leading space in the buffer-name.
When called without a prefix argument, kill just the current buffer
-- i.e., interesting or uninteresting."
(interactive "P")
  (cond
    ((and (consp arg) (equal arg '(4)))
      (mapc
        (lambda (x)
          (let ((name (buffer-name x)))
            (unless (eq ?\s (aref name 0))
              (kill-buffer x))))
        (buffer-list)))
    (t
      (kill-buffer (current-buffer)))))

(define-key custom-bindings-map (kbd "C-k") 'custom-kill-buffer-fn)
#+end_src

** Selecting Regions

[[https://github.com/magnars/expand-region.el][expand-region]] expand the region (selected text) with semantic units (e.g.,
symbol, word, sentence, paragraph). It's super handy!

#+begin_src emacs-lisp
(use-package expand-region
  :bind (:map custom-bindings-map ("C-<dead-diaeresis>" . er/expand-region)
			                      ("C-å" . er/contract-region)))
#+end_src

** Undo/Redo

The default "undo until you can redo" behaviour of Emacs still trips me up.
[[https://github.com/emacsmirror/undo-fu][undo-fu]] lets me specify keys to "only undo" or "only redo".

#+begin_src emacs-lisp
(use-package undo-fu
  :bind (:map custom-bindings-map
			  ("C-_"   . undo-fu-only-undo)
			  ("C-M-y" . undo-fu-only-redo)))
#+end_src

** Ripgrep

I want to use =ripgrep= as =grep=.

#+BEGIN_SRC emacs-lisp
(setq grep-command "rg -nS --no-heading "
      grep-use-null-device nil)
#+END_SRC

** Terminal Emulator

I like [[https://github.com/akermu/emacs-libvterm][vterm]] and usually just use that. I don't want it to double check with me
before killing an instance of the terminal, so I'll set it to just kill it.
I also really Lars' [[https://github.com/larstvei/dot-emacs#vterm][vterm functions]], so I'll use those as well. One is for
toggling the =vterm= buffer with the other open buffer, and another binds a
separate =vterm= instance to each =M-n= keystroke.

Lastly, deleting whole words doesn't work well in vterm by
default, so if anyone has a good tip for how to overwrite my custom bindings map
in just vterm, please do let me know :~)

#+begin_src emacs-lisp
(use-package vterm
  :defer  t

  :preface
  (let ((last-vterm ""))
    (defun toggle-vterm ()
      (interactive)
      (cond ((string-match-p "^\\vterm<[1-9][0-9]*>$" (buffer-name))
             (goto-non-vterm-buffer))
            ((get-buffer last-vterm) (switch-to-buffer last-vterm))
            (t (vterm (setq last-vterm "vterm<1>")))))

    (defun goto-non-vterm-buffer ()
      (let* ((r "^\\vterm<[1-9][0-9]*>$")
             (vterm-buffer-p (lambda (b) (string-match-p r (buffer-name b))))
             (non-vterms (cl-remove-if vterm-buffer-p (buffer-list))))
        (when non-vterms
          (switch-to-buffer (car non-vterms)))))

	(defun switch-vterm (n)
      (let ((buffer-name (format "vterm<%d>" n)))
        (setq last-vterm buffer-name)
        (cond ((get-buffer buffer-name)
               (switch-to-buffer buffer-name))
              (t (vterm buffer-name)
                 (rename-buffer buffer-name))))))

  :bind (:map custom-bindings-map
              ("C-z" . toggle-vterm)
              ("M-1" . (lambda () (interactive) (switch-vterm 1)))
              ("M-2" . (lambda () (interactive) (switch-vterm 2)))
              ("M-3" . (lambda () (interactive) (switch-vterm 3)))
              ("M-4" . (lambda () (interactive) (switch-vterm 4)))
              ("M-5" . (lambda () (interactive) (switch-vterm 5)))
              ("M-6" . (lambda () (interactive) (switch-vterm 6)))
              ("M-7" . (lambda () (interactive) (switch-vterm 7)))
              ("M-8" . (lambda () (interactive) (switch-vterm 8)))
              ("M-9" . (lambda () (interactive) (switch-vterm 9))))
  :bind (:map vterm-mode-map
			  ("C-c C-c" . (lambda () (interactive) (vterm-send-key (kbd "C-c")))))

  :config
  ;; Don't query about killing vterm buffers, just kill it
  (defadvice vterm (after kill-with-no-query nil activate)
    (set-process-query-on-exit-flag (get-buffer-process ad-return-value) nil)))
#+end_src

** Completion Suite

For completions, I use [[https://github.com/minad/vertico][Vertico]] and a suite of other extensions that play well together:

- [[https://github.com/tumashu/vertico-posframe][vertico-posframe]]
- [[https://github.com/minad/consult][consult]]
- [[https://github.com/minad/marginalia][marginalia]]
- [[https://github.com/minad/corfu][corfu]]
- [[https://github.com/minad/cape][cape]]
- [[https://github.com/oantolin/orderless][orderless]]

*** Vertico

The heart of the completion UI!

#+begin_src emacs-lisp
(use-package vertico
  :config
  (vertico-mode 1)
  (setq vertico-count 25                       ; Show more candidates
		read-extended-command-predicate 'command-completion-default-include-p
		read-file-name-completion-ignore-case t  ; Ignore case of file names
		read-buffer-completion-ignore-case t     ; Ignore case in buffer completion
		completion-ignore-case t                 ; Ignore case in completion
))
#+end_src

*** Vertico Posframe

=vertico-posframe= makes Vertico appear in a small child frame, instead of as a
traditional minibuffer. I like to have mine in the middle of the frame.

#+begin_src emacs-lisp
(use-package vertico-posframe
  :config
  (vertico-posframe-mode 1)
  (setq vertico-posframe-width 100
        vertico-posframe-height vertico-count))

#+end_src

*** Consult

Consult provides a /ton/ of search, navigation, and completion functionality. I
would definitely recommend looking at the documentation to learn more about all
that it can do.

#+begin_src emacs-lisp
(use-package consult
  :bind (:map custom-bindings-map
              ("C-x b"   . consult-buffer)
			  ("C-s"     . consult-line)
              ("M-s"     . consult-ripgrep)
			  ("C-c C-g" . consult-goto-line)))
#+end_src

*** Marginalia

=Marginalia= gives me annotations in the minibuffer.

#+begin_src emacs-lisp
(use-package marginalia
  :init 
  (marginalia-mode 1))
#+end_src

*** Corfu & Cape

=corfu= gives me text completion at point.

#+begin_src emacs-lisp
(use-package corfu
  :custom
  (corfu-cycle t)                ;; Enable cycling for `corfu-next/previous'
  (corfu-auto t)                 ;; Enable auto completion
  (corfu-auto-delay 0)           ;; No delay
  (corfu-auto-prefix 2)          ;; Start when this many characters have been typed
  (corfu-popupinfo-delay 0.5)    ;; Short delay
  ;; (corfu-separator ?\s)          ;; Orderless field separator
  ;; (corfu-quit-at-boundary nil)   ;; Never quit at completion boundary
  ;; (corfu-quit-no-match nil)      ;; Never quit, even if there is no match
  ;; (corfu-preview-current nil)    ;; Disable current candidate preview
  (corfu-preselect 'prompt)      ;; Preselect the prompt
  ;; (corfu-on-exact-match nil)     ;; Configure handling of exact matches

  :init
  (global-corfu-mode))

(use-package emacs
  :init
  ;; TAB cycle if there are only few candidates
  (setq completion-cycle-threshold 3)

  ;; Hide commands in M-x which do not apply to the current mode.
  ;; Corfu commands are hidden, since they are not supposed to be used via M-x.
  (setq read-extended-command-predicate
        #'command-completion-default-include-p)

  ;; Enable indentation+completion using the TAB key.
  ;; `completion-at-point' is often bound to M-TAB.
  (setq tab-always-indent 'complete))
#+end_src

=corfu= also uses some of [[https://github.com/minad/cape][cape]]'s functionalities, so let's add that, too.

#+begin_src emacs-lisp
(use-package cape
  ;; Bind dedicated completion commands
  ;; Alternative prefix keys: C-c p, M-p, M-+, ...
  :bind (("C-c p p"  . completion-at-point) ;; capf
         ("C-c p t"  . complete-tag)        ;; etags
         ("C-c p d"  . cape-dabbrev)        ;; or dabbrev-completion
         ("C-c p h"  . cape-history)
         ("C-c p f"  . cape-file)
         ("C-c p k"  . cape-keyword)
         ("C-c p s"  . cape-symbol)
         ("C-c p a"  . cape-abbrev)
         ("C-c p l"  . cape-line)
         ("C-c p w"  . cape-dict)
         ("C-c p \\" . cape-tex)
         ("C-c p _"  . cape-tex)
         ("C-c p ^"  . cape-tex)
         ("C-c p &"  . cape-sgml)
         ("C-c p r"  . cape-rfc1345))
  :init
  ;; Add `completion-at-point-functions', used by `completion-at-point'.
  ;; NOTE: The order matters!
  (add-to-list 'completion-at-point-functions #'cape-dabbrev)
  (add-to-list 'completion-at-point-functions #'cape-file)
  (add-to-list 'completion-at-point-functions #'cape-elisp-block)
  (add-to-list 'completion-at-point-functions #'cape-history)
  (add-to-list 'completion-at-point-functions #'cape-keyword)
  (add-to-list 'completion-at-point-functions #'cape-tex)
  ;;(add-to-list 'completion-at-point-functions #'cape-sgml)
  ;;(add-to-list 'completion-at-point-functions #'cape-rfc1345)
  ;;(add-to-list 'completion-at-point-functions #'cape-abbrev)
  (add-to-list 'completion-at-point-functions #'cape-dict)
  ;;(add-to-list 'completion-at-point-functions #'cape-symbol)
  ;;(add-to-list 'completion-at-point-functions #'cape-line)
)
#+end_src

*** Orderless

And [[https://github.com/oantolin/orderless][Orderless]] is a package for a completion /style/, that matches multiple
regexes, in any order. Let's use it together with Corfu.

#+begin_src emacs-lisp
(use-package orderless
  :ensure t
  :config
  (setq completion-styles '(orderless basic partial-completion)
        completion-category-overrides '((file (styles basic partial-completion)))
        orderless-component-separator "[ |]"))
#+end_src

** Snippets

[[https://github.com/joaotavora/yasnippet][YASnippet]] is a template system for Emacs that allows you to predefine snippets
you use often and insert them easily. I want snippets for basic Org-files,
Roam-notes, and other sequences often used.

#+begin_src emacs-lisp
(use-package yasnippet
  :diminish yas-minor-mode
  :defer 5
  :config
  (setq yas-snippet-dirs '("~/.emacs.d/snippets/"))
  (yas-global-mode 1)) ;; or M-x yas-reload-all if you've started YASnippet already.

;; Silences the warning when running a snippet with backticks (runs a command in the snippet)
(require 'warnings)
(add-to-list 'warning-suppress-types '(yasnippet backquote-change)) 
#+end_src

** Better Help Buffers

[[https://github.com/Wilfred/helpful][Helpful]] is an improvement on Emacs' built-in *help* buffer. It's more user-friendly and easier to read.

#+BEGIN_SRC emacs-lisp
(use-package helpful
  :bind (:map custom-bindings-map
			  ("C-h f" . #'helpful-callable)
			  ("C-h v" . #'helpful-variable)
			  ("C-h k" . #'helpful-key)
			  ("C-h x" . #'helpful-command)
			  ("C-h d" . #'helpful-at-point)
			  ("C-h F" . #'helpful-function)))
#+END_SRC

[[https://github.com/justbur/emacs-which-key][which-key]] shows you available keybindings in the minibuffer. When you've started
to enter a command, it will show you where you can go from there.

#+begin_src emacs-lisp
(use-package which-key
  :config
  (which-key-mode))
#+end_src

** Spelling

[[https://www.emacswiki.org/emacs/FlySpell][Flyspell]] enables on-the-fly spell checking and highlights misspelled words in
the way that you'd expect.

I've borrowed [[https://github.com/larstvei/dot-emacs#flyspell][Lars' function]] for cycling through languages from his config. The
below code ensures changing spelling language in one buffer does not affect the
spelling languages of other buffers. I mostly write in British English, but
adapt to American English when collaborating, so I'll add both.

#+begin_src emacs-lisp
(defun cycle-languages ()
  "Changes the ispell dictionary to the first element in
ISPELL-LANGUAGES, and returns an interactive function that cycles
the languages in ISPELL-LANGUAGES when invoked."
  (let ((ispell-languages (list "british" "norsk" "american" "italiano" "francais")))
    (lambda ()
      (interactive)
      ;; Rotates the languages cycle and changes the ispell dictionary.
      (let ((rotated (nconc (cdr ispell-languages) (list (car ispell-languages)))))
        (ispell-change-dictionary (car (setq ispell-languages rotated)))))))
#+end_src

I'll enable =flyspell-mode= for all text modes and use =flyspell-prog-mode= for
spell checking comments and strings in all programming modes. =C-c l= is bound to
a function returned from =cycle-languages=, giving a language switcher for every
buffer where flyspell is enabled.

#+begin_src emacs-lisp
(use-package flyspell
  :defer t
  :if (executable-find "aspell")
  :hook ((text-mode . flyspell-mode)
         (prog-mode . flyspell-prog-mode)
         (flyspell-mode . (lambda ()
                            (local-set-key
                             (kbd "C-c l")
                             (cycle-languages)))))
  :config
  (ispell-change-dictionary "british" t))
#+end_src

** Version Control

[[https://github.com/magit/magit][Magit]] is a Git client specifically for Emacs, and it's super powerful.

Let's first make sure we're highlighting uncommitted changes.

#+begin_src emacs-lisp
(use-package diff-hl
  :config
  (global-diff-hl-mode))
#+end_src

Then configure Magit.

#+begin_src emacs-lisp
(use-package magit
  :config
  (add-hook 'magit-pre-refresh-hook 'diff-hl-magit-pre-refresh)
  (add-hook 'magit-post-refresh-hook 'diff-hl-magit-post-refresh))
#+end_src

** Project Management
 
[[https://projectile.mx/][Projectile]] provides a convenient project interaction interface. I keep most of
my projects in a specific folder, so I'll set Projectile to check that path specifically.

#+begin_src emacs-lisp
(use-package projectile
  :bind (:map custom-bindings-map ("C-c p" . projectile-command-map))
  :config
  (setq projectile-project-search-path '("~/Dropbox/projects/")))
#+end_src

** Viewing PDFs

This displays PDFs in a much more beautiful way.

However, it takes a long time to load, so we'll wait to load it until we try to open a PDF. Then it'll take a long time to open the first PDF, but all the others will load quickly, and we don't need to spend any extra start-up time when we don't need to open any PDFs.

#+begin_src emacs-lisp
(use-package pdf-tools
  :defer t
  :mode "\\.pdf\\'"
  :bind (:map pdf-view-mode-map
              ("c" . (lambda ()
                       (interactive)
                       (if header-line-format
                           (setq header-line-format nil)
                         (nano-modeline-pdf-mode))))
              ("j" . pdf-view-next-line-or-next-page)
              ("k" . pdf-view-previous-line-or-previous-page))
  :init (pdf-loader-install)
  :config (add-to-list 'revert-without-query ".pdf"))
#+end_src

** LaTeX

I use AUCTeX to work with LaTeX files from within Emacs and it's a massive help.
It has a lot of different features, and I'd recommend checking out the
documentation to see all the stuff you can do with it.

#+begin_src emacs-lisp
(use-package auctex
  :hook
  (LaTeX-mode . turn-on-prettify-symbols-mode)
  (LaTeX-mode . turn-on-flyspell))
#+end_src

** Browser Preference

Open links with Brave by default.

#+begin_src emacs-lisp
(setq browse-url-browser-function 'browse-url-generic
      browse-url-generic-program "brave-browser")
#+end_src

** Switching Windows

Opening, switching and deleting windows becomes super easy with [[https://github.com/dimitri/switch-window][switch-window]].

#+begin_src emacs-lisp
(use-package switch-window
  :bind (:map custom-bindings-map
			  ("C-x o" . 'switch-window)
			  ("C-x 1" . 'switch-window-then-maximize)
			  ("C-x 2" . 'switch-window-then-split-below)
			  ("C-x 3" . 'switch-window-then-split-right)
			  ("C-x 0" . 'switch-window-then-delete)))
#+end_src

** TODO Multiple Cursors

* Org

[[https://orgmode.org/][Org Mode]] is a smart text system that is used for organising notes, literate programming, time management, and a wide variety of other use cases. I've been interested in switching from my previous note-taking app, Obsidian, to using Org and Roam (described in the next section).

Let's first make sure we're using Org.

#+BEGIN_SRC emacs-lisp
(use-package org)
#+END_SRC

** Visuals
*** Folded Startup

When opening an Org file, all headers are folded by default.

#+begin_src emacs-lisp
(setq-default org-startup-folded t)
#+end_src

*** Decluttering

	We'll declutter by adapting the indentation and hiding leading starts in headings. We'll also use [[https://orgmode.org/manual/Special-Symbols.html]["pretty entities"]], which allow us to
insert special characters LaTeX-style by using a leading backslash (e.g., =\alpha= to
write the greek letter alpha) and display ellipses in a condensed way.

#+begin_src emacs-lisp
(setq org-adapt-indentation t
      org-hide-leading-stars t
      org-pretty-entities t
	  org-ellipsis "  ·")
#+end_src

For source code blocks specifically, I want Org to display the contents using
the major mode of the relevant language. I also want TAB to behave inside the
source code block like it normally would when writing code in that language.

#+begin_src emacs-lisp
(setq org-src-fontify-natively t
	  org-src-tab-acts-natively t
      org-edit-src-content-indentation 0)
#+end_src

Many people hide emphasis markers (e.g., =/.../= for italics, =*...*= for bold,
etc.) to have a cleaner visual look, but I got frustrated trying to go back and
edit text in these markers, as sometimes I would delete the markers itself or
write outside the markers. [[https://github.com/awth13/org-appear][org-appear]] is the solution to all my troubles. It
displays the markers when the cursor is within them and hides them otherwise,
making edits easy while looking pretty.

#+begin_src emacs-lisp
(use-package org-appear
  :commands (org-appear-mode)
  :hook     (org-mode . org-appear-mode)
  :config 
  (setq org-hide-emphasis-markers t)  ; Must be activated for org-appear to work
  (setq org-appear-autoemphasis   t   ; Show bold, italics, verbatim, etc.
        org-appear-autolinks      t   ; Show links
		org-appear-autosubmarkers t)) ; Show sub- and superscripts
#+end_src

Some Org options to deal with headers and TODO's nicely.

#+begin_src emacs-lisp
(setq org-log-done                       t
	  org-auto-align-tags                t
	  org-tags-column                    -80
	  org-fold-catch-invisible-edits     'show-and-error
	  org-special-ctrl-a/e               t
	  org-insert-heading-respect-content t)
#+end_src

Next, I always want to center the text and enable linebreaks in Org. I've added
a hook to activate =olivetti-mode= and =visual-fill-mode=
is always on.

#+begin_src emacs-lisp
(add-hook 'org-mode-hook 'olivetti-mode)
#+end_src

*** Org Text Faces

Make sure =variable-pitch-mode= is always active in Org buffers.

#+begin_src emacs-lisp
(add-hook 'org-mode-hook 'variable-pitch-mode)
#+end_src

Set the sizes and fonts for the various headings.

#+begin_src emacs-lisp
;; Resize Org headings
(dolist (face '((org-level-1 . 1.35)
                (org-level-2 . 1.3)
                (org-level-3 . 1.2)
                (org-level-4 . 1.1)
                (org-level-5 . 1.1)
                (org-level-6 . 1.1)
                (org-level-7 . 1.1)
                (org-level-8 . 1.1)))
  (set-face-attribute (car face) nil :font "Source Sans Pro" :weight 'bold :height (cdr face)))

;; Make the document title a bit bigger
(set-face-attribute 'org-document-title nil :font "Source Sans Pro" :weight
'bold :height 1.8)
#+END_src

Ensure some parts of the Org-document still uses =fixed-pitch= even when
=variable-pitch-mode= is on.

#+begin_src emacs-lisp
(require 'org-indent)
(set-face-attribute 'org-indent nil :inherit '(org-hide fixed-pitch))

;; Ensure that anything that should be fixed-pitch in Org files appears that way
(set-face-attribute 'org-block nil            :foreground nil :inherit
'fixed-pitch :height 0.85)
(set-face-attribute 'org-code nil             :inherit '(shadow fixed-pitch) :height 0.85)
(set-face-attribute 'org-indent nil           :inherit '(org-hide fixed-pitch) :height 0.85)
(set-face-attribute 'org-verbatim nil         :inherit '(shadow fixed-pitch) :height 0.85)
(set-face-attribute 'org-special-keyword nil  :inherit '(font-lock-comment-face
fixed-pitch))
(set-face-attribute 'org-meta-line nil        :inherit '(font-lock-comment-face fixed-pitch))
(set-face-attribute 'org-checkbox nil         :inherit 'fixed-pitch)
#+end_src

*** LaTeX Previews

Increase the size of LaTeX previews in Org.

#+begin_src emacs-lisp
(plist-put org-format-latex-options :scale 1.35)
#+end_src

[[https://github.com/io12/org-fragtog][org-fragtog]] works like org-appear, but for LaTeX fragments: It toggles LaTeX
previews on and off automatically, depending on the cursor position. If you move the
cursor to a preview, it's toggled off so you can edit the LaTeX snippet. When
you move the cursor away, the preview is turned on again.

#+begin_src emacs-lisp
(use-package org-fragtog
  :hook (org-mode-hook . org-fragtog-mode))
#+end_src

*** Bullets

=org-superstar= styles some of my UI elements, such as bullets and special
checkboxes for TODOs.

#+begin_src emacs-lisp
(use-package org-superstar
  :config
  (setq org-superstar-leading-bullet " ")
  (setq org-superstar-headline-bullets-list '("◉" "○" "⚬" "◈" "◇"))
  (setq org-superstar-special-todo-items t) ;; Makes TODO header bullets into boxes
  (setq org-superstar-todo-bullet-alist '(("TODO"  . 9744)
                                          ("WAIT"  . 9744)
                                          ("READ"  . 9744)
                                          ("PROG"  . 9744)
										  ("DONE"  . 9745)))
  :hook (org-mode . org-superstar-mode))
#+end_src

*** SVG Elements

[[https://github.com/rougier/svg-tag-mode][svg-tag-mode]] lets you replace keywords such as TODOs, tags, and progress bars with nice
SVG graphics. I use it for dates, progress bars, and citations.

#+begin_src emacs-lisp
(use-package svg-tag-mode
  :config
  (defconst date-re "[0-9]\\{4\\}-[0-9]\\{2\\}-[0-9]\\{2\\}")
  (defconst time-re "[0-9]\\{2\\}:[0-9]\\{2\\}")
  (defconst day-re "[A-Za-z]\\{3\\}")
  (defconst day-time-re (format "\\(%s\\)? ?\\(%s\\)?" day-re time-re))

  (defun svg-progress-percent (value)
	(svg-image (svg-lib-concat
				(svg-lib-progress-bar (/ (string-to-number value) 100.0)
			      nil :margin 0 :stroke 2 :radius 3 :padding 2 :width 11)
				(svg-lib-tag (concat value "%")
				  nil :stroke 0 :margin 0)) :ascent 'center))

  (defun svg-progress-count (value)
	(let* ((seq (mapcar #'string-to-number (split-string value "/")))
           (count (float (car seq)))
           (total (float (cadr seq))))
	  (svg-image (svg-lib-concat
				  (svg-lib-progress-bar (/ count total) nil
					:margin 0 :stroke 2 :radius 3 :padding 2 :width 11)
				  (svg-lib-tag value nil
					:stroke 0 :margin 0)) :ascent 'center)))
  (setq svg-tag-tags
      `(
        ;; Org tags
        ;; (":\\([A-Za-z0-9]+\\)" . ((lambda (tag) (svg-tag-make tag))))
        ;; (":\\([A-Za-z0-9]+[ \-]\\)" . ((lambda (tag) tag)))
        
        ;; Task priority
        ("\\[#[A-Z]\\]" . ( (lambda (tag)
                              (svg-tag-make tag :face 'org-priority 
                                            :beg 2 :end -1 :margin 0))))

        ;; Progress
        ("\\(\\[[0-9]\\{1,3\\}%\\]\\)" . ((lambda (tag)
          (svg-progress-percent (substring tag 1 -2)))))
        ("\\(\\[[0-9]+/[0-9]+\\]\\)" . ((lambda (tag)
          (svg-progress-count (substring tag 1 -1)))))
        
        ;; TODO / DONE
        ;; ("TODO" . ((lambda (tag) (svg-tag-make "TODO" :face 'org-todo
		;; 									           :inverse t :margin 0))))
		;; ("WAIT" . ((lambda (tag) (svg-tag-make "WAIT" :face 'org-todo
		;; 									           :inverse t :margin 0))))
		;; ("READ" . ((lambda (tag) (svg-tag-make "READ" :face 'org-todo
		;; 									           :inverse t :margin 0))))
		;; ("PROG" . ((lambda (tag) (svg-tag-make "PROG"  :face 'org-todo
		;; 									           :inverse t :margin 0))))
        ;; ("DONE" . ((lambda (tag) (svg-tag-make "DONE" :face 'org-done :margin 0))))


        ;; Citation of the form [cite:@Knuth:1984] 
        ("\\(\\[cite:@[A-Za-z]+:\\)" . ((lambda (tag)
                                          (svg-tag-make tag
                                                        :inverse t
                                                        :beg 7 :end -1
                                                        :crop-right t))))
        ("\\[cite:@[A-Za-z]+:\\([0-9]+\\]\\)" . ((lambda (tag)
                                                (svg-tag-make tag
                                                              :end -1
                                                              :crop-left t))))

        
        ;; Active date (with or without day name, with or without time)
        (,(format "\\(<%s>\\)" date-re) .
         ((lambda (tag)
            (svg-tag-make tag :beg 1 :end -1 :margin 0))))
        (,(format "\\(<%s \\)%s>" date-re day-time-re) .
         ((lambda (tag)
            (svg-tag-make tag :beg 1 :inverse nil :crop-right t :margin 0))))
        (,(format "<%s \\(%s>\\)" date-re day-time-re) .
         ((lambda (tag)
            (svg-tag-make tag :end -1 :inverse t :crop-left t :margin 0))))

        ;; Inactive date  (with or without day name, with or without time)
         (,(format "\\(\\[%s\\]\\)" date-re) .
          ((lambda (tag)
             (svg-tag-make tag :beg 1 :end -1 :margin 0 :face 'org-date))))
         (,(format "\\(\\[%s \\)%s\\]" date-re day-time-re) .
          ((lambda (tag)
             (svg-tag-make tag :beg 1 :inverse nil
						       :crop-right t :margin 0 :face 'org-date))))
         (,(format "\\[%s \\(%s\\]\\)" date-re day-time-re) .
          ((lambda (tag)
             (svg-tag-make tag :end -1 :inverse t
						       :crop-left t :margin 0 :face 'org-date)))))))

(add-hook 'org-mode-hook 'svg-tag-mode)
#+end_src

*** Prettify Tags & Keywords

I have a custom function to prettify tags and other elements, lifted from [[https://github.com/jakebox/jake-emacs/blob/main/jake-emacs/jib-funcs.el][Jake
B's Emacs setup]].

#+begin_src emacs-lisp
(defun my/prettify-symbols-setup ()
  "Beautify keywords"

  (setq prettify-symbols-alist
		(mapcan (lambda (x) (list x (cons (upcase (car x)) (cdr x))))
				'(; Greek symbols
				  ("lambda" . ?λ)
				  ("delta"  . ?Δ)
				  ("gamma"  . ?Γ)
				  ("phi"    . ?φ)
				  ("psi"    . ?ψ)
				  ; Org headers
				  ("#+title:"  . "")
				  ("#+author:" . "")
				  ; Checkboxes
				  ("[ ]" . "")
				  ("[X]" . "")
				  ("[-]" . "" )
				  ; Blocks
				  ("#+begin_src"   . "")
				  ("#+end_src"     . "")
				  ("#+begin_QUOTE" . "‟")
				  ("#+begin_QUOTE" . "”")
				  ; Drawers
				  (":properties:" . "")
				  ; Agenda scheduling
				  ("SCHEDULED:"   . "")
				  ("DEADLINE:"    . "")
				  ; Agenda tags 
				  (":@projects:"  . "")
				  (":work:"       . "")
				  (":@inbox:"     . "")
				  (":task:"       . "")
				  (":@thesis:"    . "")
				  (":thesis:"     . "")
				  (":uio:"        . "")
				  (":emacs:"      . "")
				  (":learn:"      . "")
				  (":code:"       . "")
				  (":fix:"        . "")
				  (":bug:"        . "")
				  ; Roam tags
				  ("#+filetags:"  . " ")
				  (":wip:"        . "")
				  )))
  (prettify-symbols-mode))

(add-hook 'org-mode-hook        #'my/prettify-symbols-setup)
(add-hook 'org-agenda-mode-hook #'my/prettify-symbols-setup)
#+end_src

*** Right-Align Tags

Code snippet from [[https://www.reddit.com/r/emacs/comments/185e4k1/comment/kb39xvy/?utm_source=share&utm_medium=web2x&context=3][this Reddit post]]. It actually right-aligns tags, using
font-lock and the display property.

#+begin_src emacs-lisp
(add-to-list 'font-lock-extra-managed-props 'display)
(font-lock-add-keywords 'org-mode
                        `(("^.*?\\( \\)\\(:[[:alnum:]_@#%:]+:\\)$"
                           (1 `(face nil
                                     display (space :align-to (- right ,(org-string-width (match-string 2)) 3)))
                              prepend))) t)
#+end_src

*** Super Agenda

[[https://github.com/alphapapa/org-super-agenda][org-super-agenda]] lets you group agenda items into sections, so it's easier to
navigate.

#+begin_src emacs-lisp
(use-package org-super-agenda
  :after org
  :config
  (setq org-super-agenda-header-prefix "❯ ")
  ;; Hide the thin width char glyph
  (add-hook 'org-agenda-mode-hook
            #'(lambda () (setq-local nobreak-char-display nil)))
  (setq org-super-agenda-groups
		'((:name "Today"
				 :time-grid t
				 :order 1)
		  (:name "Important"
				:priority "A"
				:order 2)
		  (:name "Inbox"
				 :tag "@inbox"
				 :order 3)
		  (:name "Thesis"
				 :tag "@thesis"
				 :order 4)
		  (:name "Projects"
				 :tag "@projects"
				 :order 5)))
  (org-super-agenda-mode))
#+end_src

** Tasks
*** Task Priorities

Let's increase the number of possible priorities for Org tasks. I'll set
mine to =E= so that we have =A= through =E=, in total five levels.

#+begin_src emacs-lisp
(setq org-lowest-priority ?F)  ;; Gives us priorities A through F
(setq org-default-priority ?E) ;; If an item has no priority, it is considered [#E].

(setq org-priority-faces
      '((65 . "#BF616A")
        (66 . "#EBCB8B")
        (67 . "#B48EAD")
        (68 . "#81A1C1")
        (69 . "#5E81AC")
        (70 . "#4C566A")))
#+end_src

*** Custom TODO States

I'll expand the list of default task states.

#+begin_src emacs-lisp
(setq org-todo-keywords
      '((sequence
		 "TODO(t)" "WAIT(w)" "READ(r)" "PROG(p)" ; Needs further action
		 "|"
		 "DONE(d)")))                            ; Needs no action currently
#+end_src

*** Mark As Done

Finally, to mark any TODO task, of any state, as DONE quickly, I have a helper
function that I'll bind to =C-c d=.

#+begin_src emacs-lisp
(defun org-mark-as-done ()
  (interactive)
  (save-excursion
    (org-back-to-heading t) ;; Make sure command works even if point is
                            ;; below target heading
    (cond ((looking-at "\*+ TODO")
           (org-todo "DONE"))
          ((looking-at "\*+ WAIT")
           (org-todo "DONE"))
		  ((looking-at "\*+ READ")
           (org-todo "DONE"))
		  ((looking-at "\*+ PROG")
           (org-todo "DONE"))
		  ((looking-at "\*+ DONE")
           (org-todo "DONE"))
          (t (message "Undefined TODO state.")))))

(define-key custom-bindings-map (kbd "C-c d") 'org-mark-as-done)
#+end_src

** "Get Things Done" Setup

I'm trying out the Get Things Done method by David Allen, using Nicolas
Rougier's [[https://github.com/rougier/emacs-gtd][GTD configuration]] and Nicolas Petton's [[https://emacs.cafe/emacs/orgmode/gtd/2017/06/30/orgmode-gtd.html][blog post]] on the subject.

The first step is to set the relevant directories.

#+BEGIN_SRC emacs-lisp
(setq org-directory "~/Dropbox/org/")
(setq org-agenda-files (list "inbox.org" "projects.org" "thesis.org"))
#+END_SRC

Set the archive location to a unified archive.

#+begin_src emacs-lisp
(setq org-archive-location (concat org-directory "archive.org::"))
#+end_src

Then to set up the relevant capture templates, with accompanying keybindings.

#+BEGIN_SRC emacs-lisp
(setq org-capture-templates
       `(("i" "Inbox" entry  (file "inbox.org")
        ,(concat "* TODO %?\n"
                 "/Entered on/ %U"))
		 ("p" "Projects" entry  (file "projects.org")
        ,(concat "* TODO %?\n"
                 "/Entered on/ %U"))
		 ("t" "Thesis" entry  (file "thesis.org")
        ,(concat "* TODO %?\n"
                 "/Entered on/ %U"))))
(defun org-capture-inbox ()
     (interactive)
     (call-interactively 'org-store-link)
     (org-capture nil "i"))
#+END_SRC

And then I have some keybindings for these functions.

For basic agenda and TODO-related keybindings, I'll use =C-c= followed by a
single, lower-case letter.

#+BEGIN_SRC emacs-lisp
(define-key custom-bindings-map (kbd "C-c l") 'org-store-link)
(define-key custom-bindings-map (kbd "C-c a") 'org-agenda)
(define-key custom-bindings-map (kbd "C-c c") 'org-capture)
(define-key custom-bindings-map (kbd "C-c t") 'org-todo)
#+END_SRC

For whatever reason, I've had an issue with clocking in, where the default
keybinding used =TAB= instead of =C-i= to clock in, so I'll set that manually.

#+begin_src emacs-lisp
(define-key org-mode-map (kbd "C-c C-x C-i") 'org-clock-in)
#+end_src

** Registers

[[https://www.gnu.org/software/emacs/manual/html_node/emacs/Registers.html][Registers]] are easier to access than bookmarks and much more flexible. I'll set
up registers for my GTD files.

#+begin_src emacs-lisp
(set-register ?1 (cons 'file (concat org-directory "inbox.org")))
(set-register ?2 (cons 'file (concat org-directory "projects.org")))
(set-register ?3 (cons 'file (concat org-directory "thesis.org")))
#+end_src

Since I have =C-s= bound to =consult-line= which lets me search everywhere in a
file, I don't really need =C-r= to be bound to the default =isearch-backward=.
Instead, I can use it as the leader key combination to jump to a register.

#+begin_src emacs-lisp
(define-key custom-bindings-map (kbd "C-r") 'jump-to-register)
#+end_src

** Agenda

Open day view with =C-c a d= and extended three-day view with =C-c a e=.

#+begin_src emacs-lisp
(setq org-agenda-custom-commands
	  '(("d" "Day View"
               ((agenda "" ((org-agenda-overriding-header "Day View")
                            (org-agenda-span 'day))
					     	(org-super-agenda-groups '(
                                                       (:name "Today:"
                                                              :scheduled t
                                                              :order 2)
                                                       (:name "Deadlines:"
                                                              :deadline t
                                                              :order 3)
                                                       (:name "Today's Schedule:"
                                                              :time-grid t
                                                              :discard (:deadline t)
                                                              :order 1)
													   (:name "Priority:"
															  :priority "A"
															  :order 4))))))
		("e" "Three-Day View"
               ((agenda "" ((org-agenda-span 3)
                            (org-agenda-entry-types '(:deadline :scheduled))
                            (org-agenda-start-on-weekday nil)
                            (org-deadline-warning-days 0)))))))
#+end_src

Don't show me deadlines or scheduled items if they are done.

#+begin_src emacs-lisp
(setq org-agenda-skip-deadline-if-done  t
	  org-agenda-skip-scheduled-if-done t)
#+end_src

Modify dealine leader text.

#+begin_src emacs-lisp
(setq org-agenda-deadline-leaders '("Deadline:  " "In %2d d.: " "%2d d. ago: "))
#+end_src

I also want to open my agenda on the current day, not on any specific weekday.

#+begin_src emacs-lisp
(setq org-agenda-start-on-weekday nil)
#+end_src

** Pasting Images

[[https://github.com/abo-abo/org-download][org-download]] lets me easily put copied screenshots into my org-documents.

#+begin_src emacs-lisp
(use-package org-download
  :after org
  :bind
  (:map org-mode-map
        (("s-t" . org-download-screenshot)
         ("s-y" . org-download-clipboard))))
#+end_src

Show inline images by default

#+begin_src haskell
(setq org-startup-with-inline-images t)
#+end_src

** TOC in Org Files

[[https://github.com/snosov1/toc-org][toc-org]] creates nice, Markdown compatible tables of content for your Org files.
Perfect for GitHub READMEs.

#+begin_src emacs-lisp
(use-package toc-org
  :config
  (add-hook 'org-mode-hook 'toc-org-mode)

  ;; enable in markdown, too
  (add-hook 'markdown-mode-hook 'toc-org-mode))
#+end_src

** Babel

For working with code blocks in Org mode, I want to make sure code blocks are
not evaluated by default on export. I also want to add some languages.

#+begin_src emacs-lisp
(use-package ob
  :ensure nil
  :after org
  :config
  (setq org-export-use-babel nil
        org-confirm-babel-evaluate nil)
  (org-babel-do-load-languages
   'org-babel-load-languages
   '((emacs-lisp . t)
     (python     . t)
     (haskell    . t)
	 (clojure    . t))))
#+end_src

For Python, use whatever interpreter is set by =python-shell-interpreter=.

#+begin_src emacs-lisp
(use-package ob-python
  :ensure nil
  :after (ob python)
  :config
  (setq org-babel-python-command python-shell-interpreter))
#+end_src

** Roam

[[https://roamresearch.com/][Roam]] is a smart note-taking system in the style of a personal knowledge
management system. [[https://www.orgroam.com/][org-roam]] is a port of this system that uses all plain-text Org-files.

I'm planning to transition some/all of my notetaking from Obsidian (see below)
to Roam, but have not done so yet. Details are described in the "Obsidian"
section.

For now, I have set up a Roam directory and added a simple configuration for
navigating Roam nodes.

#+begin_src emacs-lisp
(use-package org-roam
  :init
  (setq org-roam-v2-ack t)
  :custom
  (org-roam-directory "~/Dropbox/org/roam")
  (org-roam-completion-everywhere t)
  :bind (:map org-mode-map
		 ("C-c n l" . org-roam-buffer-toggle)
         ("C-c n f" . org-roam-node-find)
         ("C-c n i" . org-roam-node-insert))
  :config
  (org-roam-db-autosync-enable))
#+end_src

Set up searching for nodes by tags.

#+begin_src emacs-lisp
(setq org-roam-node-display-template
	  (concat "${title:*} "
			  (propertize "${tags:10}" 'face 'org-tag)))
#+end_src

** Hugo

[[https://gohugo.io/][Hugo]] is a static site generator. By default, it uses a Markdown flavour called
Blackfriday. The package [[https://github.com/kaushalmodi/ox-hugo/][ox-hugo]] can export Org files to this format, and
also generate appropriate front-matter. I use it to write my blog in Org and
easily put it online.

#+BEGIN_SRC emacs-lisp
(use-package ox-hugo
  :after ox)
#+END_SRC

I've had a great time blogging with =ox-hugo=, but it's a little bothersome to
have to rewrite the front-matter required in the blog post for it to export
property every time, so below is a little snippet lifted from [[https://ox-hugo.scripter.co/doc/org-capture-setup/][ox-hugo's blog]].

The file =all-posts,org= needs to be present in 'org-directory' and the file's
heading must be "Blog Posts". It can even be a symlink pointing to the actual location of all-posts.org! If you've named yours differently, change these values.

#+begin_src emacs-lisp
(with-eval-after-load 'org-capture
  (defun org-hugo-new-subtree-post-capture-template ()
    "Returns `org-capture' template string for new Hugo post.
See `org-capture-templates' for more information."
    (let* ((title (read-from-minibuffer "Post Title: "))
           (fname (org-hugo-slug title)))
      (mapconcat #'identity
                 `(
                   ,(concat "* TODO " title)
                   ":PROPERTIES:"
                   ,(concat ":EXPORT_FILE_NAME: " fname)
                   ":END:"
                   "%?\n")          ;Place the cursor here finally
                 "\n")))

  (add-to-list 'org-capture-templates
               '("h"                ;`org-capture' binding + h
                 "Hugo post"
                 entry
                 (file+olp "all-posts.org" "Blog Posts")
                 (function org-hugo-new-subtree-post-capture-template))))
#+end_src

** RevealJS

[[https://github.com/yjwen/org-reveal][org-reveal]] is exports your Org documents to [[https://revealjs.com/][RevealJS]] presentations. For nice
syntax highlighting, let's also add =htmlize.el=.

#+begin_src emacs-lisp
(use-package ox-reveal
  :config
  (setq org-reveal-root "file:///home/sophie/reveal.js"))
(use-package htmlize)
#+end_src

#+RESULTS:

In the properties of each Org presentation document, you can set the
=REVEAL-ROOT= either to the CDN distribution of reveal.js or to your download
location.

CDN: =#+REVEAL_ROOT: https://cdn.jsdelivr.net/npm/reveal.js=
Local copy: =#+REVEAL_ROOT: file:///d:/reveal.js=

* Programming
** Preferences & Extras
*** Custom File Endings

For my MSc thesis, I'm implementing a small functional programming language
called Contra. It's pretty similar to Haskell, so using Haskell mode does a
fairly good job of syntax highlighting my =.con=-files.

#+begin_src emacs-lisp
(add-to-list 'auto-mode-alist '("\\.con\\'" . haskell-mode))
#+end_src

*** Language-Specific Commenting

I use =C-'= to comment/uncomment lines with [[https://github.com/redguardtoo/evil-nerd-commenter][Evil Nerd Commenter]]. It automatically
detects most programming languages and applies appropriate comment style.

#+begin_src emacs-lisp
(use-package evil-nerd-commenter
  :ensure t
  :bind (:map custom-bindings-map ("C-'" . evilnc-comment-or-uncomment-lines)))
#+end_src

*** Subword Mode

[[https://wikemacs.org/wiki/Subword-mode][subword-mode]] lets you work on each subword in camel case words as individual
words. It makes it much easier to delete and mark parts of function and variable
names.

#+begin_src emacs-lisp
(add-hook 'prog-mode-hook 'subword-mode)
#+end_src

*** WakaTime

[[https://wakatime.com][WakaTime]] is an automatic time-tracking plugin.
[[https://github.com/wakatime/wakatime-mode][wakatime-mode]] integrates it with Emacs.

#+begin_src emacs-lisp
(use-package wakatime-mode
  :config
  (setq wakatime-cli-path "~/.wakatime/wakatime-cli-linux-amd64")
  (setq wakatime-api-key (auth-source-pick-first-password :host "wakatime"))
  (global-wakatime-mode))
#+end_src

** Eglot

[[https://github.com/joaotavora/eglot][Eglot]] (Emacs polyGLOT) is an LSP server client for Emacs that comes
pre-installed from Emacs 29. If using a previous version, you can of course also install
it manually!

#+begin_src emacs-lisp
(use-package eglot
  :defer t
  :hook
  (eglot-managed-mode . (lambda () (eglot-inlay-hints-mode -1)))
  (python-mode . eglot-ensure))
#+end_src

** Haskell

For Haskell, I think the regular =haskell-mode= is nice. I'll add =haskell-doc-mode=
which uses eldoc consistently throughout.

I also want to use the tool [[https://github.com/ndmitchell/hoogle][Hoogle]] from directly within Emacs to quickly
look up functions and packages. I've set it up according to the GitHub docs, so
that =C-c h= opens a prompt and querying the database opens a help buffer inside
Emacs with the results.

#+BEGIN_SRC emacs-lisp
(use-package haskell-mode
  :defer t
  :hook ((haskell-mode . haskell-doc-mode))
  :config
  (setq haskell-hoogle-command                  "hoogle"
		haskell-compile-stack-build-command     "stack build"
		haskell-compile-stack-build-alt-command "stack build --pedantic")
  :bind (:map haskell-mode-map
			  ("\C-ch"   . haskell-hoogle)
			  ("C-c C-c" . haskell-compile)))
#+END_SRC

** OCaml

OCaml requires some setup for =ocp-indent=,

#+begin_src emacs-lisp
(use-package ocp-indent)
#+end_src

and for =merlin=.
 
#+begin_src emacs-lisp
(let ((opam-share (ignore-errors (car (process-lines "opam" "var" "share")))))
      (when (and opam-share (file-directory-p opam-share))
       ;; Register Merlin
       (add-to-list 'load-path (expand-file-name "emacs/site-lisp" opam-share))
       (autoload 'merlin-mode "merlin" nil t nil)
       ;; Automatically start it in OCaml buffers
       (add-hook 'tuareg-mode-hook 'merlin-mode t)
       (add-hook 'caml-mode-hook 'merlin-mode t)
       ;; Use opam switch to lookup ocamlmerlin binary
       (setq merlin-command 'opam)))
#+end_src

Then I want integration with Dune, Merlin, and utop for the full IDE-experience.

#+begin_src emacs-lisp
;; Major mode for OCaml programming
(use-package tuareg
  :mode (("\\.ocamlinit\\'" . tuareg-mode)))

;; Major mode for editing Dune project files
(use-package dune
  :ensure t)

;; Merlin provides advanced IDE features
(use-package merlin
  :config
  (add-hook 'tuareg-mode-hook #'merlin-mode)
  ;; we're using flycheck instead
  (setq merlin-error-after-save nil))

(use-package merlin-eldoc
  :hook ((tuareg-mode) . merlin-eldoc-setup))

;; utop REPL configuration
(use-package utop
  :config
  (add-hook 'tuareg-mode-hook #'utop-minor-mode))
#+end_src

** Python

Let's first set the language interpreter.

#+begin_src emacs-lisp
(use-package python
  :interpreter ("python3" . python-mode)
  :config
  (setq python-shell-interpreter "python3.11")
  (add-hook 'python-mode
			(lambda () (setq forward-sexp-function nil))))
#+end_src

Note that you also need =pyright= for this! Installation will depend on your
system. It's available from [[https://pypi.org/project/pyright/][PyPI]]. On Ubuntu, I had the most luck installing via
snap:

#+begin_src shell :tangle no
sudo snap install pyright --classic
#+end_src

Then, I want to hide the modeline for inferior Python processes to save screen
space. There's a [[https://github.com/hlissner/emacs-hide-mode-line][dedicated package]] for this.

#+begin_src emacs-lisp
(use-package hide-mode-line
  :defer t
  :hook (inferior-python-mode . hide-mode-line-mode))
#+end_src

[[https://github.com/pythonic-emacs/blacken][Blacken]] is a package that uses the Python =black= package to reformat Python
buffers. I'll set it to work by default and enforce max line length.

#+begin_src emacs-lisp
(use-package blacken
  :defer t
  :custom
  (blacken-line-length t)
  :hook (python-mode-hook . blacken-mode))
#+end_src

** Clojure

[[https://github.com/clojure-emacs/cider][CIDER]] adds support for interactive Clojure programming in Emacs. It's provides
built-in support for firing up a REPL and looking up documentation and source
code, but it also has very Emacs-like shortcuts for expected actions, such as
=C-x C-e= to evaluate the s-exp at point.
[[https://www.emacswiki.org/emacs/ParEdit][ParEdit]] will protect your parentheses and keep you sane.

#+begin_src emacs-lisp
(use-package cider
  :defer t
  :hook ((cider-mode      . paredit-mode)
         (cider-repl-mode . paredit-mode)
		 (clojure-mode    . paredit-mode))
  :bind (:map cider-repl-mode-map ("C-l" . cider-repl-clear-buffer)))
#+end_src

[[https://github.com/clojure-emacs/clj-refactor.el][clj-refactor]] is a CIDER extension for refactoring.

#+begin_src emacs-lisp
(use-package clj-refactor
  :defer t)
#+end_src

** Coq

[[https://proofgeneral.github.io/][Proof General]] is a generic interface for proof assistants in Emacs. This is a
simple setup to use it with Coq.

#+begin_src emacs-lisp
(use-package proof-general
  :defer t)
#+end_src

As the [[https://coq.inria.fr/user-interfaces.html][Coq documentation]] suggests, I'll also add
[[https://github.com/cpitclaudel/company-coq][company-coq]] for completions.

#+begin_src emacs-lisp
(use-package company-coq
  :defer t
  :hook (coq-mode . company-coq-mode))
#+end_src

** Nix

#+begin_src emacs-lisp
(use-package nix-mode)
#+end_src

* Elfeed

[[https://github.com/skeeto/elfeed][Elfeed]] is a feed reader for Emacs!

#+begin_src emacs-lisp
(use-package elfeed
  :bind (:map custom-bindings-map ("C-x w" . elfeed))
  :config
  (setq elfeed-feeds
      '("http://nullprogram.com/feed/"
        "https://planet.emacslife.com/atom.xml"
		"https://deniskyashif.com/index.xml"
		"https://sophiebos.io/index.xml")))
#+end_src

* Activating Custom Keybindings
*** Extra Keybindings

Most of my custom keybindings are bound directly in the section with the
relevant package, but here are a few extra ones.

Switch to the other window  =C-x o= \to  =M-o=.

#+begin_src emacs-lisp
(define-key custom-bindings-map (kbd "M-o") 'other-window)
#+end_src

I also plan to use =win-switch= to get nicer macros for switching and managing windows.

Run a shell command and insert the results into current buffer.

#+begin_src emacs-lisp
(define-key custom-bindings-map (kbd "M-+") #'(lambda ()
                       (interactive)
                       (let ((current-prefix-arg '(4)))
                         (call-interactively 'shell-command))))
#+end_src

*** Activating the Keymap

Throughout the configuration, I've added bindings to my custom-bindings-map.
The last thing we need to to before we can call it a day, is to define a minor
mode for it and activate that mode. The below code does just that.

#+begin_src emacs-lisp
(define-minor-mode custom-bindings-mode
  "A mode that activates custom keybindings."
  :init-value t
  :keymap custom-bindings-map)
#+end_src




