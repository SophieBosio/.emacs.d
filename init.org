
#+TITLE: Sophie's Emacs Configuration
#+AUTHOR: Sophie Bosio
:PROPERTIES:
#+PROPERTY: header-args :tangle yes
#+OPTIONS: toc:2
#+STARTUP: overview
:END:

[[./images/config-screenshot.png]]

* About

This is my attempt at keeping my Emacs configuration organised and readable.

I write all my initialisation code in this document as code blocks and then use
=org-babel-tangle= to extract those code blocks into a separate file. That new,
generated file becomes my =init.el=. This way, I can document my code and explain
my choices to my future self - and to anyone else who might be interested in looking at it.

If you're interested in this approach to writing and sharing your config, it's
called a "literate configuration" and there are lots of great blog posts out
there with inspiration and tips!

I've lifted a lot of code from the setups of [[https://github.com/rougier][Nicolas Rougier]] (especially his Org setup),
[[https://github.com/larstvei/dot-emacs/blob/master/init.org][Lars Tveito]], and [[https://github.com/jakebox/jake-emacs][Jacob Boxerman]], and I can heartily recommend checking those out.

I'm still relatively new to Emacs, so if you have any suggestions or
improvements, I would be very happy to hear about them!

* Table of Contents :toc_2_gh:
- [[#about][About]]
- [[#setup][Setup]]
  - [[#initel-code][=init.el= Code]]
  - [[#git-tracking--practicalities][Git Tracking & Practicalities]]
  - [[#lexical-scoping][Lexical Scoping]]
  - [[#tangling][Tangling]]
- [[#start-up][Start-Up]]
  - [[#performance][Performance]]
  - [[#house-keeping][House-Keeping]]
  - [[#packages][Packages]]
  - [[#external-software][External Software]]
- [[#custom-keybindings][Custom Keybindings]]
  - [[#custom-keymap][Custom Keymap]]
  - [[#mac-os-modifier-keys][Mac OS Modifier Keys]]
- [[#visuals][Visuals]]
  - [[#decluttering][Decluttering]]
  - [[#frames--windows][Frames & Windows]]
  - [[#programming-specific-visuals][Programming-Specific Visuals]]
  - [[#icons][Icons]]
  - [[#fonts-ligatures-and-emojis][Fonts, Ligatures, and Emojis]]
  - [[#themes][Themes]]
  - [[#mode-line][Mode Line]]
  - [[#text-display-modes][Text Display Modes]]
- [[#interaction][Interaction]]
  - [[#tweaking-default-behaviour][Tweaking Default Behaviour]]
  - [[#text-editing-preferences][Text Editing Preferences]]
  - [[#managing-buffers-windows--projects][Managing Buffers, Windows, & Projects]]
  - [[#terminal-emulator][Terminal Emulator]]
  - [[#completion--search][Completion & Search]]
  - [[#version-control][Version Control]]
  - [[#auto-saving][Auto-Saving]]
  - [[#trying-packages][Trying Packages]]
  - [[#snippets][Snippets]]
  - [[#better-help-buffers][Better Help Buffers]]
  - [[#spelling][Spelling]]
  - [[#latex][LaTeX]]
  - [[#editor-config][Editor Config]]
  - [[#browser-preference][Browser Preference]]
  - [[#elfeed][Elfeed]]
  - [[#code-screenshots][Code Screenshots]]
  - [[#config-profiling][Config Profiling]]
- [[#org][Org]]
  - [[#visuals-1][Visuals]]
  - [[#org-ql][Org QL]]
  - [[#tasks][Tasks]]
  - [[#agenda][Agenda]]
  - [[#babel][Babel]]
  - [[#roam][Roam]]
  - [[#hugo][Hugo]]
  - [[#org-conveniencies][Org Conveniencies]]
- [[#programming][Programming]]
  - [[#preferences--extras][Preferences & Extras]]
  - [[#tree-sitter][Tree-Sitter]]
  - [[#eglot][Eglot]]
  - [[#flycheck][Flycheck]]
  - [[#http][HTTP]]
  - [[#programming-languages][Programming Languages]]
- [[#activating-custom-keybindings][Activating Custom Keybindings]]
- [[#todos][TODOs]]

* Setup
** =init.el= Code

As mentioned, I use =org-babel-tangle= and this document, written in Org mode.

The code below extracts the elisp configuration code and creates/overwrites the
=~/.emacs.d/init.el= configuration file when the =.org=-file is saved.
Therefore, changes are only done in the =.org=-file, where writing longer
comments about how things work and why things are added is easier, and then the resulting =init.el=-file remains clean and without excessive comments.

This is what the =init.el= file should look like, prompting it to tangle the =init.org= file and replace itself with that code.

#+BEGIN_SRC emacs-lisp :tangle no
;; We need org in order to make use of the tangling functionality
(require 'org)
;; Open the org-mode configuration
(find-file (concat user-emacs-directory "init.org"))
;; Tangle the file
(org-babel-tangle)
;; Load the tangled file
(load-file (concat user-emacs-directory "init.el"))
;; Byte-compile it
(byte-compile-file (concat user-emacs-directory "init.el"))
#+END_SRC

** Git Tracking & Practicalities

Now we also don't need to track the generated =init.el= file on Git, since it is directly derived from =init.org=.

This code makes Git ignore changes to =init.el=:

#+BEGIN_SRC sh :tangle no
git update-index --assume-unchanged init.el
#+END_SRC

If you do want to start tracking the file again, you can use:

#+BEGIN_SRC sh :tangle no
git update-index --no-assume-unchanged init.el
#+END_SRC

** Lexical Scoping

First, I want lexical scoping for the =init=-file, so I will add that to the top of the file.

#+BEGIN_SRC emacs-lisp
;;; -*- lexical-binding: t -*-
#+END_SRC

** Tangling

Now to tangling! The rest of the text and code in this section is lifted directly from Lars' configuration.

The =init.el= should (after the first run) mirror the source blocks in the =init.org=. We can use =C-c C-v t= to run =org-babel-tangle=, which extracts the code blocks from the current file into a source-specific file (in this case a =.el=-file).

To avoid doing this each time a change is made we can add a function to the =after-save-hook= ensuring to always tangle and byte-compile =.org=-document after changes.

#+BEGIN_SRC emacs-lisp
   (defun tangle-init ()
     "If the current buffer is init.org the code-blocks are
   tangled, and the tangled file is compiled."
     (when (equal (buffer-file-name)
                  (expand-file-name (concat user-emacs-directory "init.org")))
       ;; Avoid running hooks when tangling.
       (let ((prog-mode-hook nil))
         (org-babel-tangle)
         (byte-compile-file (concat user-emacs-directory "init.el")))))

   (add-hook 'after-save-hook 'tangle-init)
   #+END_SRC

* Start-Up
** Performance

I want to make some tweaks to improve startup performance. First, a common tweak is to disable the garbage collector during initialisation, and then resetting it afterwards.

#+BEGIN_SRC emacs-lisp
(setq gc-cons-percentage 0.6)
(setq gc-cons-threshold (* 50 1000 1000))

;; Set and reset threshold
(let ((old-gc-treshold gc-cons-threshold))
  (setq gc-cons-threshold most-positive-fixnum)
  (add-hook 'after-init-hook
            (lambda () (setq gc-cons-threshold old-gc-treshold))))
#+END_SRC

Compilation warnings.

#+begin_src emacs-lisp
(setq native-comp-async-report-warnings-errors 'silent) ;; native-comp warning
(setq byte-compile-warnings '(not free-vars unresolved noruntime lexical make-local))
#+end_src

This is an optimisation borrowed from Doom Emacs' =core.el=.

#+begin_src emacs-lisp
(setq idle-update-delay 1.0)
#+end_src

Fix IO bugs.

#+begin_src emacs-lisp
(setq process-adaptive-read-buffering nil)
(setq read-process-output-max (* 4 1024 1024))
#+end_src

Prevent Emacs from freezing when updating ELPA.

#+begin_src emacs-lisp
(setq gnutls-algorithm-priority "NORMAL:-VERS-TLS1.3")
#+end_src

** House-Keeping

Then I want to do some house keeping. First, let's set the Emacs user
and default directories explicitly:

#+BEGIN_SRC emacs-lisp
(setq user-emacs-directory "~/.emacs.d/")
(setq default-directory "~/")
#+END_SRC

Set UFT-8 as preferred coding system.

#+BEGIN_SRC emacs-lisp
(set-language-environment "UTF-8")
#+END_SRC

** Packages

To manage downloaded packages, Emacs comes with =package.el= installed. In
addition, I want to use =use-package=, so let's make sure we have those loaded.

#+begin_src emacs-lisp
(require 'package)
(require 'use-package)
(require 'use-package-ensure)
(setq use-package-always-ensure t)
#+end_src

Next, I'll set up my package sources. These are very common and well-maintained mirrors.

#+BEGIN_SRC emacs-lisp
(setq package-archives
      '(("GNU ELPA"     . "https://elpa.gnu.org/packages/")
        ("MELPA"        . "https://melpa.org/packages/")
        ("ORG"          . "https://orgmode.org/elpa/")
        ("MELPA Stable" . "https://stable.melpa.org/packages/")
        ("nongnu"       . "https://elpa.nongnu.org/nongnu/"))
      package-archive-priorities
      '(("GNU ELPA"     . 20)
        ("MELPA"        . 15)
        ("ORG"          . 10)
        ("MELPA Stable" . 5)
        ("nongnu"       . 0)))
(package-initialize)
#+END_SRC

I have a folder with extensions that have been downloaded manually. I'll add these to the =load-path= so Emacs knows where to look for them. My folder is called "local-lisp".

#+BEGIN_SRC emacs-lisp
(defvar local-lisp "~/.emacs.d/local-lisp/")
(add-to-list 'load-path  local-lisp)
(let ((default-directory local-lisp))
  (normal-top-level-add-subdirs-to-load-path))
#+END_SRC

And load custom settings from =custom.el= if it exists.

#+BEGIN_SRC emacs-lisp
(setq custom-file (concat user-emacs-directory "custom.el"))
(when (file-exists-p custom-file)
  (load custom-file))
#+END_SRC

** External Software

I have started using Nix to manage most of my software, but I haven't figured
out how to set up everything yet. In the meantime, I keep this list of software
that is *not* yet in my Nix config.

*Utilities:*
- Fish
- Starship
- Firefox

*Programming languages++:*
- GHCi (Haskell)
- Stack (Haskell)
- Java
- Clojure
- Leiningen
- OCaml
- Racket
- Lua
- Idris
- Erlang
- Agda
- Alex (Haskell/Agda)
- Happy (Haskell/Agda)

*Fonts:*
- [[https://github.com/weiweihuanghuang/fragment-mono][Fragment Mono]]
- [[https://fonts.google.com/specimen/Open+Sans][Open Sans]]
- [[https://github.com/lemeb/a-better-ligaturizer/blob/master/output-fonts/RobotoMono.ttf][Roboto Mono with Ligatures]]

* Custom Keybindings
** Custom Keymap

I keep a custom keybinding map that I add to per package, and then activate at
the end of the configuration. This keeps my custom bindings from being
overwritten by extensions' own bindings.

The first step is to create the custom keybinding map. We'll add bindings to it
throughout the config, and then activate it at the end of the config file, at
[[#activating-custom-keybindings][Activating Custom Keybindings]].

#+begin_src emacs-lisp
(defvar custom-bindings-map (make-keymap)
  "A keymap for custom keybindings.")
#+end_src

** Mac OS Modifier Keys

On a Mac, I would want to add some specific settings. As a note to myself, I
have the following settings in Mac OS:

#+begin_src
caps-lock -> control (ctrl)
control   -> control (ctrl)
option    -> option  (alt)
command   -> command (meta)
#+end_src

#+begin_src emacs-lisp
(setq mac-command-modifier       'meta
      mac-right-command-modifier 'meta
      mac-option-modifier        nil
      mac-right-option-modifier  nil)
#+end_src

* Visuals
** Decluttering

Let's declutter a little. This should have gone into =early-init.el=, but I get
strange compilation warnings (optimiser says there's too much on the stack).

#+begin_src emacs-lisp
(dolist (mode
		 '(tool-bar-mode                     ;; Remove toolbar
		   scroll-bar-mode                   ;; Remove scollbars
		   menu-bar-mode                     ;; Remove menu bar
		   blink-cursor-mode))               ;; Solid cursor, not blinking
  (funcall mode 0))
#+end_src

This wouldn't go into =early-init= anyways.

#+begin_src emacs-lisp
(setq inhibit-startup-message           t         ;; No startup message
	  initial-scratch-message           nil       ;; Empty scratch buffer
	  ring-bell-function                'ignore   ;; No bell
	  display-time-default-load-average nil       ;; Don't show me load time
	  scroll-margin                     0         ;; Space between top/bottom
	  use-dialog-box                    nil)      ;; Disable dialog
#+end_src

** Frames & Windows
*** Open in Fullscreen

When I open Emacs, I want it to open maximised and fullscreen by default.

#+BEGIN_SRC emacs-lisp
(set-frame-parameter (selected-frame) 'fullscreen 'maximized)
(add-to-list 'default-frame-alist     '(fullscreen . maximized))
;; (add-hook 'window-setup-hook          'toggle-frame-fullscreen t)  ;; F11
#+END_SRC

*** Frame Transparency

This doesn't work ideally, but it does the job. I use it very rarely.

#+begin_src emacs-lisp
 (defun toggle-transparency ()
   (interactive)
   (let ((alpha (frame-parameter nil 'alpha)))
     (set-frame-parameter
      nil 'alpha
      (if (eql (cond ((numberp alpha) alpha)
                     ((numberp (cdr alpha)) (cdr alpha))
                     ;; Also handle undocumented (<active> <inactive>) form.
                     ((numberp (cadr alpha)) (cadr alpha)))
               100)
          '(90 . 55) '(100 . 100)))))
 (global-set-key (kbd "C-c v") 'toggle-transparency)
#+end_src

*** Frame Border

I want a small border around the whole frame, because I think it looks nicer.

#+BEGIN_SRC emacs-lisp
(add-to-list 'default-frame-alist '(internal-border-width . 16))
#+END_SRC

Some settings to fringes.

#+begin_src emacs-lisp
(set-fringe-mode 10)                          ;; Set fringe width to 10

(setq-default fringes-outside-margins nil)
(setq-default indicate-buffer-boundaries nil) ;; Otherwise shows a corner icon on the edge
(setq-default indicate-empty-lines nil)       ;; Otherwise there are weird fringes on blank lines

(set-face-attribute 'header-line t :inherit 'default)
#+end_src

*** Splitting Windows

I want maximum two windows by default. I have a function, taken from [[https://emacs.stackexchange.com/a/40517][this Stack
Overflow post]], that rewrites the =split-window-sensibly= function to reverse its
preference and essentially prefer splitting side-by-side.

#+begin_src emacs-lisp
(defun split-window-sensibly-prefer-horizontal (&optional window)
"Based on `split-window-sensibly', but prefers to split WINDOW side-by-side."
  (let ((window (or window (selected-window))))
    (or (and (window-splittable-p window t)
         ;; Split window horizontally
         (with-selected-window window
           (split-window-right)))
    (and (window-splittable-p window)
         ;; Split window vertically
         (with-selected-window window
           (split-window-below)))
    (and
         ;; If WINDOW is the only usable window on its frame (it is
         ;; the only one or, not being the only one, all the other
         ;; ones are dedicated) and is not the minibuffer window, try
         ;; to split it horizontally disregarding the value of
         ;; `split-height-threshold'.
         (let ((frame (window-frame window)))
           (or
            (eq window (frame-root-window frame))
            (catch 'done
              (walk-window-tree (lambda (w)
                                  (unless (or (eq w window)
                                              (window-dedicated-p w))
                                    (throw 'done nil)))
                                frame)
              t)))
     (not (window-minibuffer-p window))
     (let ((split-width-threshold 0))
       (when (window-splittable-p window t)
         (with-selected-window window
               (split-window-right))))))))

(defun split-window-really-sensibly (&optional window)
  (let ((window (or window (selected-window))))
    (if (> (window-total-width window) (* 2 (window-total-height window)))
        (with-selected-window window (split-window-sensibly-prefer-horizontal window))
      (with-selected-window window (split-window-sensibly window)))))

(setq split-window-preferred-function 'split-window-really-sensibly)
#+end_src

If I have already split the frame into
two windows and then call a function that opens a new window (for example a
Magit or a compilation buffer), then I want Emacs to reuse the inactive window
instead of creating a new one. Setting both =split-height-threshold= and
=split-width-threshold= to =nil= seems to ensure this.

#+begin_src emacs-lisp
(setq-default split-height-threshold nil
              split-width-threshold  nil)
              ;; fill-column            80)  ;; Maximum line width
              ;; window-min-width       80) ;; No smaller windows than this
#+end_src

*** Transparent Title Bar on Mac OS

*TODO:* I've started using =emacs-plus= instead of =emacs-mac=. I need to update this text to reflect that, but a similar option does exist for =emacs-plus= :~)

Using the [[https://github.com/railwaycat/homebrew-emacsmacport][emacsmacport]] version of Mithuarus's [[https://bitbucket.org/mituharu/emacs-mac/src/master/][emacs-mac]], you can get a
transparent title bar (e.g., title bar is same colour as theme background),
which I think is really nice.

To get it, build Emacs with the =--with-natural-title-bar= flag. Alternatively, for no title bar at all, you can
build it with =--with-no-title-bars=.

#+begin_src shell :tangle no
# enable tap
brew tap railwaycat/emacsmacport

# build with transparent/natural title bar
brew tap emacs-mac --with-natural-title-bar

# or alternatively,
brew tap emacs-mac --with-no-title-bars
#+end_src

Then add the corresponding settings to your =init=-file. For natural title bar,
use =ns-transparent-titlebar= and for no title bar, use =undecorated=. Here, I'm
using the natural title bar.

I also set some other options. For example, I don't need info in the title bar
about which buffer is in focus, since this info is already in the mode line. I
found these options in [[https://notes.alexkehayias.com/emacs-natural-title-bar-with-no-text-in-macos/][this blog post]].

#+begin_src emacs-lisp
(when (eq system-type 'darwin)
  ; use transparent/natural title bar
  (add-to-list 'default-frame-alist '(ns-transparent-titlebar . t))
  ; don't use proxy icon
  (setq ns-use-proxy-icon nil)
  ; don't show buffer name in title bar
  (setq frame-title-format nil))
#+end_src

Finally, in your terminal, run these commands to use transparent title bar and
to hide the icon from the middle of the title bar. I found these in the
aforementioned blog post and in the Emacs-Mac Port's
[[https://github.com/railwaycat/homebrew-emacsmacport/wiki/Natural-Title-Bar][wiki
page]] on the subject.

#+begin_src shell :tangle no
# for dark themes
defaults write org.gnu.Emacs TransparentTitleBar DARK

# for light themes
defaults write org.gnu.Emacs TransparentTitleBar LIGHT

# hide document icon from title bar
defaults write org.gnu.Emacs HideDocumentIcon YES
#+end_src

*** Undecorated Title Bar on Gnome

[[https://www.gnu.org/software/emacs/manual/html_node/elisp/Management-Parameters.html][It's possible]] to set the Emacs window to be "undecorated", i.e.,
without a title bar and thus with no buttons on Gnome.

#+begin_src emacs-lisp
(when (eq system-type 'gnu/linux)
  ; don't show buffer name in title bar
  (setq frame-title-format nil)
  ; use undecorated title bar
  (add-to-list 'default-frame-alist '(undecorated . t)))
#+end_src

** Programming-Specific Visuals
*** Cursor

I prefer a bar cursor over a block cursor.

#+begin_src emacs-lisp
(setq-default cursor-type 'bar)
#+end_src

But sometimes, that makes it hard to spot the cursor when switching between buffers. [[https://github.com/Boruch-Baum/emacs-cursor-flash][cursor-flash]] highlights the cursor temporarily when switching buffer or window.

#+begin_src emacs-lisp
(use-package cursor-flash
  :defer t)
#+end_src

*** Delimiters (Parentheses etc.)

When coding, I want my delimiters (parentheses, brackets, etc.) to be colourised
in pairs. [[https://github.com/Fanael/rainbow-delimiters/tree/7919681b0d883502155d5b26e791fec15da6aeca][rainbow-delimiters]] does exactly that.

#+begin_src emacs-lisp
(use-package rainbow-delimiters
  :hook (prog-mode-hook . rainbow-delimiters-mode))
#+end_src

*** Line Numbers

I usually only need line numbers in programming mode.

#+BEGIN_SRC emacs-lisp
(add-hook 'prog-mode-hook 'display-line-numbers-mode)
#+END_SRC

*** Uniquify Buffers

When opening the files =foo/bar/name= and =baz/bar/name=, use forward slashes to
distinguish them. Default behaviour is angle brackets, which would yield =name<foo/bar>= and =name<baz/bar>=..

#+begin_src emacs-lisp
(require 'uniquify)
(setq uniquify-buffer-name-style 'forward)
#+end_src

*** Highlight Long Lines

Highlight lines over 100 characters long.

#+begin_src emacs-lisp
(setq my-whitespace-style '(face tabs lines-tail)
      whitespace-style my-whitespace-style
      whitespace-line-column 100
      fill-column 100
      whitespace-display-mappings
      '((space-mark 32 [183] [46])
        (newline-mark 10 [36 10])
        (tab-mark 9 [9655 9] [92 9])))

;; in e.g. clojure-mode-hook
;; (whitespace-mode 1)
;; or globally
;; (global-whitespace-mode 1)
(add-hook 'prog-mode 'whitespace-mode)
#+end_src

** Icons

Add =nerd-icons=.

#+begin_src emacs-lisp
(use-package nerd-icons)
#+end_src

** Fonts, Ligatures, and Emojis
*** Default, Fixed, and Variable Fonts

Please note that I scale and set Org-specific faces in the [[#visuals-1][Org > Visuals]] section.

For the fixed-pitch font, I'm using the excellent [[https://github.com/weiweihuanghuang/fragment-mono][Fragment Mono]], which
has great ligature support.

I have Open Sans configured as my variable-pitch font.

#+begin_src emacs-lisp
(defvar my/font-height 102)

(when (eq system-type 'darwin)
  (setq my/font-height 134))

(when (member "Fragment Mono" (font-family-list))
  (set-face-attribute 'default nil :font "Fragment Mono" :height my/font-height)
  (set-face-attribute 'fixed-pitch nil :family "Fragment Mono"))

(when (member "Open Sans" (font-family-list))
  (set-face-attribute 'variable-pitch nil :family "Open Sans"))
#+end_src

*** Mixed Pitch Fonts

[[https://gitlab.com/jabranham/mixed-pitch][mixed-pitch]] allows you to mix fixed and variable pitched faces in Org and LaTeX mode.

#+begin_src emacs-lisp
(use-package mixed-pitch
  :defer t
  :hook ((org-mode   . mixed-pitch-mode)
         (LaTeX-mode . mixed-pitch-mode)))
#+end_src

*** Monitor-Dependent Text Size Scaling

[[https://github.com/WJCFerguson/textsize][textsize.el]] is a package for automatically resizing your text size
based on the display you're using. Super useful when, like me, you
switch between a laptop screen and a large monitor.

On my MacBook, I set it to 19 default points and on Linux to 15
(laptop) and 12 (monitor). For now, I have a dumb approach. I'll need to figure out a better system for this in the future.

#+begin_src emacs-lisp :tangle no
(use-package textsize
  :init (textsize-mode)
  :bind (:map custom-bindings-map
			  ("C-x C-+" . textsize-increment)
			  ("C-x C--" . textsize-decrement)
			  ("C-x C-0" . textsize-reset))
  :config
  (if (eq system-type 'gnu/linux)
	(setq textsize-default-points 12)
	;; (setq textsize-default-points 15)
	;; (setq textsize-default-points 19)
	nil
))
#+end_src

*** Ligatures

The package =ligature.el= provides support for displaying the ligatures of
fonts that already have ligatures. Mine does, and seems to work just fine out
of the box with the ligatures defined on the package's page,

#+begin_src emacs-lisp
(defvar ligature-def '("|||>" "<|||" "<==>" "<!--" "####" "~~>" "***" "||=" "||>"
                       ":::" "::=" "=:=" "===" "==>" "=!=" "=>>" "=<<" "=/=" "!=="
                       "!!." ">=>" ">>=" ">>>" ">>-" ">->" "->>" "-->" "---" "-<<"
                       "<~~" "<~>" "<*>" "<||" "<|>" "<$>" "<==" "<=>" "<=<" "<->"
                       "<--" "<-<" "<<=" "<<-" "<<<" "<+>" "</>" "###" "#_(" "..<"
                       "..." "+++" "/==" "///" "_|_" "www" "&&" "^=" "~~" "~@" "~="
                       "~>" "~-" "**" "*>" "*/" "||" "|}" "|]" "|=" "|>" "|-" "{|"
                       "[|" "]#" "::" ":=" ":>" ":<" "$>" "==" "=>" "!=" "!!" ">:"
                       ">=" ">>" ">-" "-~" "-|" "->" "--" "-<" "<~" "<*" "<|" "<:"
                       "<$" "<=" "<>" "<-" "<<" "<+" "</" "#{" "#[" "#:" "#=" "#!"
                       "##" "#(" "#?" "#_" "%%" ".=" ".-" ".." ".?" "+>" "++" "?:"
                       "?=" "?." "??" ";;" "/*" "/=" "/>" "//" "__" "~~" "(*" "*)"
                       "\\\\" "://"))

(use-package ligature
  :config
  (ligature-set-ligatures 'prog-mode ligature-def)
  (global-ligature-mode t))
#+end_src

*** Emojis

I also want to be able to display emojis with the Apple emoji font. I usually
don't use it, though, so I won't activate the global mode.

#+BEGIN_SRC emacs-lisp
(use-package emojify
  :config
  (when (member "Apple Color Emoji" (font-family-list))
    (set-fontset-font
      t 'symbol (font-spec :family "Apple Color Emoji") nil 'prepend)))
#+END_SRC

** Themes

I really like the =doom-themes= package.

#+BEGIN_SRC emacs-lisp
(use-package doom-themes
  :config
  (setq doom-themes-enable-bold t    ; if nil, bold is universally disabled
        doom-themes-enable-italic t) ; if nil, italics is universally disabled
  (load-theme 'doom-nord t))
#+END_SRC

*** Setting Favourite Themes

To change themes quickly, I keep a list of my favourite themes.

#+begin_src emacs-lisp
(defvar my/favourite-themes
  '(doom-nord
    doom-tomorrow-day
    doom-tomorrow-night
    doom-solarized-light
    doom-oksolar-light))
#+end_src

*** Changing Themes on the Fly

I have this snippet from Lars'
[[https://github.com/larstvei/dot-emacs#theme][configuration]]. I use it to switch between my favourite themes quickly.

Note that I've bound it to =C-c ø=, which may (likely) not be available
on your keyboard.

#+begin_src emacs-lisp
(defun cycle-themes ()
  "Returns a function that lets you cycle your themes."
  (let ((themes my/favourite-themes))
    (lambda ()
      (interactive)
      ;; Rotates the thme cycle and changes the current theme.
      (let ((rotated (nconc (cdr themes) (list (car themes)))))
        (load-theme (car (setq themes rotated)) t))
      (message (concat "Switched to " (symbol-name (car themes)))))))

(define-key custom-bindings-map (kbd "C-c ø") (cycle-themes))
#+end_src

When changing themes interactively, as with =M-x load-theme=, the current custom
theme is not disabled, causing weird issues such as lingering borders. I'll
advice =load-theme= to always disable the currently enabled themes when switching.

#+begin_src emacs-lisp
(defadvice load-theme
  (before disable-before-load (theme &optional no-confirm no-enable) activate)
  (mapc 'disable-theme custom-enabled-themes))
#+end_src

*** Removing Themes from List View

I have some packages with themes I really like -
e.g., Doom themes - that also contain a lot of themes I /don't/ use, and I don't
want to see those when selecting among available themes. This little code
snippet shows only the themes I do use.

Convert the list of pure theme names in =my/favourite-themes= to a list of strings, then for each
installed theme, check if the theme name is in =my/favourite-themes=. If it is,
include it in the list of valid theme names.

#+begin_src emacs-lisp
(defun my/valid-themes (orig-fun theme-name)
  (and (funcall orig-fun theme-name)
       (member (symbol-name theme-name) (mapcar #'(lambda (x) (format "%s" x)) my/favourite-themes))))
(advice-add 'custom-theme-name-valid-p :around #'my/valid-themes)
#+end_src

** Mode Line
*** Custom Mode Line

Customising the default modeline is thankfully pretty easy. Note that I use the
[[https://github.com/rainstormstudio/nerd-icons.el][nerd-icons]] package for the VC branch symbol in the code below. I've also
borrowed some code from [[https://amitp.blogspot.com/2011/08/emacs-custom-mode-line.html][this blog post]] by Amit Patel on writing a custom mode
line.

This mode line is heavily inspired by Nicolas Rougier's [[https://github.com/rougier/nano-modeline][Nano Modeline]] and he
even helped me figure out [[https://www.reddit.com/r/emacs/comments/18ktlkg/comment/kdx3aam/?context=3][how to add vertical padding]] to it.

#+begin_src emacs-lisp
(setq-default mode-line-format
  '("%e"
	(:propertize " " display (raise +0.4)) ;; Top padding
	(:propertize " " display (raise -0.4)) ;; Bottom padding

	(:propertize "λ " face font-lock-comment-face)
	mode-line-frame-identification
	mode-line-buffer-identification

	;; Version control info
	(:eval (when-let (vc vc-mode)
			 ;; Use a pretty branch symbol in front of the branch name
					 (list (propertize "   " 'face 'font-lock-comment-face)
						   (propertize (substring vc 5)
									   'face 'font-lock-comment-face))))

	;; Add space to align to the right
	(:eval (propertize
			 " " 'display
			 `((space :align-to
					  (-  (+ right right-fringe right-margin)
						 ,(+ 2 (string-width "%4l:3%c")))))))
	
	;; Line and column numbers
	(:propertize "%4l:%c" face mode-line-buffer-id)))
#+end_src

** Text Display Modes
*** Olivetti

[[https://github.com/rnkn/olivetti][Olivetti]] is a minor mode for centering text. For convenience, I'll bind it to =C-c C-o= to activate/deactivate it on the fly.

#+BEGIN_SRC emacs-lisp
(use-package olivetti
  :defer t
  :bind (:map custom-bindings-map ("C-c o" . olivetti-mode))
  :config
  (setq olivetti-style t))

(add-hook 'olivetti-mode-on-hook (lambda () (olivetti-set-width 88)))
#+END_SRC

*** Adaptive Wrap

In addition, I use [[https://elpa.gnu.org/packages/adaptive-wrap.html][adaptive-wrap]] to visually wrap lines.

#+begin_src emacs-lisp
(use-package adaptive-wrap
  :defer t
  :hook (visual-line-mode . adaptive-wrap-prefix-mode))
#+end_src

*** Writeroom Mode

[[https://github.com/joostkremers/writeroom-mode][Writeroom Mode]] gives you a distraction-free writing environment.

#+begin_src emacs-lisp
(use-package writeroom-mode
  :defer t)
#+end_src

*** Focus

 [[https://github.com/larstvei/Focus][Focus]] dims surrounding text in a semantic manner (sentences,
 paragraphs, sections, code blocks, etc.) making it easier to, well,
 focus. I find this especially helpful when editing LaTeX.

 #+begin_src emacs-lisp
 (use-package focus
   :defer t)
 #+end_src

*** Presentation Mode

 For presenting (e.g., code or Org mode buffers), it's useful to increase the
 font size, without necessarily increasing the size of everything else.

 #+begin_src emacs-lisp
 (use-package presentation
   :defer t
   :hook (presentation-mode . (lambda () (mixed-pitch-mode 'toggle)))
   :config
   (setq presentation-default-text-scale 2))
 #+end_src

* Interaction
** Tweaking Default Behaviour
*** With =setq=

#+BEGIN_SRC emacs-lisp
(setq auto-revert-interval         1         ;; Refresh buffers fast
      echo-keystrokes              0.1       ;; Show keystrokes fast
      frame-inhibit-implied-resize 1         ;; Don't resize frame implicitly
      sentence-end-double-space    nil       ;; No double spaces
      recentf-max-saved-items      1000      ;; Show more recent files
      use-short-answers            t         ;; 'y'/'n' instead of 'yes'/'no' etc.
      save-interprogram-paste-before-kill t  ;; Save copies between programs
      history-length 25                      ;; Only save the last 25 minibuffer prompts
      global-auto-revert-non-file-buffers t) ;; Revert Dired and other buffers
#+END_SRC

*** With =setq-default=

#+BEGIN_SRC emacs-lisp
(setq-default tab-width              4              ;; Smaller tabs
              frame-resize-pixelwise t              ;; Fine-grained frame resize
              ;; auto-fill-function     'do-auto-fill ;; Auto-fill-mode
)
#+END_SRC

*** With modes

#+BEGIN_SRC emacs-lisp
(dolist (mode
    '(column-number-mode        ;; Show current column number in mode line
      delete-selection-mode     ;; Replace selected text when yanking
      dirtrack-mode             ;; Directory tracking in shell
      global-so-long-mode       ;; Mitigate performance for long lines
      global-visual-line-mode   ;; Break lines instead of truncating them
      global-auto-revert-mode   ;; Revert buffers automatically when they change
      recentf-mode              ;; Remember recently opened files
      savehist-mode             ;; Remember minibuffer prompt history
      save-place-mode           ;; Remember last cursor location in file
      show-paren-mode))         ;; Highlight matching parentheses
    (funcall mode 1))
#+END_SRC

*** Smoother Scrolling

I want scrolling to be a *lot* slower than it is by default.

#+begin_src emacs-lisp
(setq scroll-conservatively            101
      mouse-wheel-follow-mouse         't
      mouse-wheel-progressive-speed    nil
      ;; Scroll 2 lines at a time, instead of default 5
      ;; Hold shift to scroll x2 and control to scroll x3 as fast
      mouse-wheel-scroll-amount        '(1 ((shift) . 3) ((control) . 6)))

(setq mac-redisplay-dont-reset-vscroll t
      mac-mouse-wheel-smooth-scroll    nil)
#+end_src

*** Don't Trap Me in the Minibuffer

And finally, don't trap me in the minibuffer! I don't want to get "attempted
command inside minibuffer."

#+begin_src emacs-lisp
(setq minibuffer-prompt-properties
	  '(read-only t intangible t cursor-intangible t face minibuffer-prompt))
(add-hook 'minibuffer-setup-hook #'cursor-intangible-mode)
#+end_src

** Text Editing Preferences
*** Tabs & Indentation

One of the things that drove me the most insane when I first downloaded Emacs,
was the way it deals with indentation.

I want to use spaces instead of tabs. But if I'm working on a project that does
use tabs, I don't want to mess with other people's code, so I've used this
[[https://www.emacswiki.org/emacs/NoTabs][snippet]] from the Emacs Wiki to infer indentation style.

#+begin_src emacs-lisp
(defun infer-indentation-style ()
  "Default to no tabs, but use tabs if already in project"
  (let ((space-count (how-many "^  " (point-min) (point-max)))
        (tab-count   (how-many "^\t" (point-min) (point-max))))
    (if (> space-count tab-count) (setq indent-tabs-mode nil))
    (if (> tab-count space-count) (setq indent-tabs-mode t))))

(setq indent-tabs-mode nil)
(infer-indentation-style)
#+end_src

I want to disable electric indent mode.

#+begin_src emacs-lisp
(electric-indent-mode -1)
#+end_src

Set backtab to =indent-rigidly-left=. Then I can easily unindent regions that use
spaces instead of tabs.

#+begin_src emacs-lisp
(define-key custom-bindings-map (kbd "<backtab>") 'indent-rigidly-left)
#+end_src

And finally, make backspace remove the whole tab instead of just deleting one space.

#+begin_src emacs-lisp
(setq backward-delete-char-untabify-method 'hungry)
#+end_src

*** Deleting Instead of Killing

Another thing that bothered me, was how the =backward-kill-word= command
(C-delete/backspace) would delete not only trailing backspaces, but everything
behind it until it had deleted a word. Additionally, this was automatically
added to the kill ring. With this the help of some regexps, it behaves more like normal Ctrl-Backspace.

#+BEGIN_SRC emacs-lisp
;; Delete a word, a character, or whitespace
(defun custom/backward-delete ()
  (interactive)
  (cond
   ;; If you see a word, delete all of it
   ((looking-back (rx (char word)) 1)
    (custom/delete-dont-kill 1))
   ;; If you see a single whitespace and a word, delete both together
   ((looking-back (rx (seq (char word) (= 1 blank))) 1)
	(custom/delete-dont-kill 1))
   ;; If you see several whitespaces, delete them until the next word
   ((looking-back (rx (char blank)) 1)
    (delete-horizontal-space t))
   ;; If you see a single non-word character, delete that
   (t
    (backward-delete-char 1))))

;; Delete a word without adding it to the kill ring
(defun custom/delete-dont-kill (arg)
  "Delete characters backward until encountering the beginning of a word.
   With argument ARG, do this that many times.
   Don't kill, just delete."
  (interactive "p")
  (delete-region (point) (progn (backward-word arg) (point))))
#+END_SRC

Let's bind this in my custom keybindings map.

#+begin_src emacs-lisp
(define-key custom-bindings-map [C-backspace] 'custom/backward-delete)
#+end_src

Speaking of killing text, it's nice to be able to browse the kill ring.

#+begin_src emacs-lisp
(use-package browse-kill-ring
  :defer t)
#+end_src

*** Selecting Regions

[[https://github.com/magnars/expand-region.el][expand-region]] expand the region (selected text) with semantic units (e.g.,
symbol, word, sentence, paragraph). It's super handy!

#+begin_src emacs-lisp
(use-package expand-region
  :defer t
  :bind (:map custom-bindings-map ("C-<dead-diaeresis>" . er/expand-region)
			                      ("C-å" . er/contract-region)))
#+end_src

*** Filling/Unfilling

In Emacs, paragraphs can be padded by a bunch of newlines, meaning a what looks
like a normal paragraph in Emacs (one line) is actually several lines with =\n=
all over. This function removes those and makes the selected region one line
again.

#+begin_src emacs-lisp
;;; Stefan Monnier <foo at acm.org>. It is the opposite of fill-paragraph
(defun unfill-paragraph (&optional region)
  "Takes a multi-line paragraph and makes it into a single line of text."
  (interactive (progn (barf-if-buffer-read-only) '(t)))
  (let ((fill-column (point-max))
		;; This would override `fill-column' if it's an integer.
		(emacs-lisp-docstring-fill-column t))
	(fill-paragraph nil region)))
;; Handy key definition
(define-key custom-bindings-map "\M-Q" 'unfill-paragraph)
#+end_src

*** Multiple Cursors

Makes life so much easier!

#+begin_src emacs-lisp
(use-package multiple-cursors
  :defer t
  :bind (:map custom-bindings-map
              ("M-n" . mc/mark-next-like-this)))
#+end_src

*** Undo/Redo

The default "undo until you can redo" behaviour of Emacs still trips me up.
[[https://github.com/emacsmirror/undo-fu][undo-fu]] lets me specify keys to "only undo" or "only redo".

#+begin_src emacs-lisp
(use-package undo-fu
  :defer t
  :bind (:map custom-bindings-map
			  ("C-_"   . undo-fu-only-undo)
			  ("M-_" . undo-fu-only-redo)))
#+end_src

*** Move Lines

[[https://github.com/wyuenho/move-dup][move-dup]] provides bindings for moving and duplicating whole lines. It's super convenient.

#+begin_src emacs-lisp
(use-package move-dup
  :bind (:map prog-mode-map
			  (("M-<up>"     . move-dup-move-lines-up)
			   ("C-M-<up>"   . move-dup-duplicate-up)
			   ("M-<down>"   . move-dup-move-lines-down)
			   ("C-M-<down>" . move-dup-duplicate-down))))
#+end_src

** Managing Buffers, Windows, & Projects
*** Killing Buffers

Sometimes, I'm putting some work away and I don't want those files to show up in
the buffer list. Killing a buffer with =C-x k= or marking several buffers in the
buffer list to kill them is fine, but can be a bit cumbersome.

I found this function in a [[https://superuser.com/questions/895920/how-can-i-close-all-buffers-in-emacs][Stack Exchange answer]]. It allows me to close the
current buffer easily by pressing =C-k=. If I prefix it, by writing =C-u C-k=, then
all "interesting" buffers are killed, leaving internal Emacs buffers intact.
This cleans up all the buffers I've opened or used myself.

#+begin_src emacs-lisp
(defun custom-kill-buffer-fn (&optional arg)
"When called with a prefix argument -- i.e., C-u -- kill all interesting
buffers -- i.e., all buffers without a leading space in the buffer-name.
When called without a prefix argument, kill just the current buffer
-- i.e., interesting or uninteresting."
(interactive "P")
  (cond
    ((and (consp arg) (equal arg '(4)))
      (mapc
        (lambda (x)
          (let ((name (buffer-name x)))
            (unless (eq ?\s (aref name 0))
              (kill-buffer x))))
        (buffer-list)))
    (t
      (kill-buffer (current-buffer)))))

(define-key custom-bindings-map (kbd "C-k") 'custom-kill-buffer-fn)
#+end_src

*** Opening, Closing, & Switching Windows

Opening, switching and deleting windows becomes super easy with [[https://github.com/dimitri/switch-window][switch-window]].

#+begin_src emacs-lisp
(use-package switch-window
  :bind (:map custom-bindings-map
			  ("C-x o" . 'switch-window)
			  ("C-x 1" . 'switch-window-then-maximize)
			  ("C-x 2" . 'switch-window-then-split-below)
			  ("C-x 3" . 'switch-window-then-split-right)
			  ("C-x 0" . 'switch-window-then-delete)))
#+end_src

And [[https://www.emacswiki.org/emacs/TransposeFrame][Transpose
Frame]] has some nice functions for shifting windows around. I only really use the
one to swap the left- and right-hand sides of the frame, but there are
others you might find useful.

#+begin_src emacs-lisp
(use-package transpose-frame
  :bind (:map custom-bindings-map
			  ("C-c f" . 'flop-frame)))
#+end_src

*** Project Management
 
[[https://projectile.mx/][Projectile]] provides a convenient project interaction interface. I keep most of
my projects in a specific folder, so I'll set Projectile to check that path specifically.

#+begin_src emacs-lisp
(use-package projectile
  :bind ((:map custom-bindings-map    ("C-c p" . projectile-command-map))
		 (:map projectile-command-map ("s r"   . 'my-consult-ripgrep-wrapper)))
  :config
  (setq projectile-project-search-path '("~/Dropbox/projects/"))
  (projectile-mode))
#+end_src

*** Workspace Management

[[https://github.com/alphapapa/burly.el][Burly]] uses Emacs bookmarks to act as a lightweight workspace manager.

#+begin_src emacs-lisp
(use-package burly
  :bind (:map custom-bindings-map
			  ("C-c b b" . 'burly-open-bookmark)
			  ("C-c b l" . 'burly-last-open-bookmark)
			  ("C-c b s" . 'burly-bookmark-frames)    ; Bookmark all frames + configs
			  ("C-c b c" . 'burly-bookmark-windows))) ; Bookmark current frame + configs
#+end_src

** Terminal Emulator
*** Mac OS Environment Variables

On Mac, the environment variables aren't synchronised automatically between the
shell and Emacs.
[[https://github.com/purcell/exec-path-from-shell][exec-path-from-shell]] fixes that.

#+begin_src emacs-lisp
(use-package exec-path-from-shell
  :if (memq window-system '(mac ns))
  :config
  (exec-path-from-shell-initialize))
#+end_src

*** vterm

I like [[https://github.com/akermu/emacs-libvterm][vterm]] and usually just use that. I don't want it to double check with me
before killing an instance of the terminal, so I'll set it to just kill it.
I also really Lars' [[https://github.com/larstvei/dot-emacs#vterm][vterm functions]], so I'll use those as well. One is for
toggling the =vterm= buffer with the other open buffer, and another binds a
separate =vterm= instance to each =M-n= keystroke.

Lastly, deleting whole words doesn't work well in vterm by
default, so if anyone has a good tip for how to overwrite my custom bindings map
in just vterm, please do let me know :~)

#+begin_src emacs-lisp
(use-package vterm
  :defer t

  :preface
  (let ((last-vterm ""))
    (defun toggle-vterm ()
      (interactive)
      (cond ((string-match-p "^\\vterm<[1-9][0-9]*>$" (buffer-name))
             (goto-non-vterm-buffer))
            ((get-buffer last-vterm) (switch-to-buffer last-vterm))
            (t (vterm (setq last-vterm "vterm<1>")))))

    (defun goto-non-vterm-buffer ()
      (let* ((r "^\\vterm<[1-9][0-9]*>$")
             (vterm-buffer-p (lambda (b) (string-match-p r (buffer-name b))))
             (non-vterms (cl-remove-if vterm-buffer-p (buffer-list))))
        (when non-vterms
          (switch-to-buffer (car non-vterms)))))

	(defun switch-vterm (n)
      (let ((buffer-name (format "vterm<%d>" n)))
        (setq last-vterm buffer-name)
        (cond ((get-buffer buffer-name)
               (switch-to-buffer buffer-name))
              (t (vterm buffer-name)
                 (rename-buffer buffer-name))))))

  :bind (:map custom-bindings-map
              ("C-z" . toggle-vterm)
              ("M-1" . (lambda () (interactive) (switch-vterm 1)))
              ("M-2" . (lambda () (interactive) (switch-vterm 2)))
              ("M-3" . (lambda () (interactive) (switch-vterm 3)))
              ("M-4" . (lambda () (interactive) (switch-vterm 4)))
              ("M-5" . (lambda () (interactive) (switch-vterm 5)))
              ("M-6" . (lambda () (interactive) (switch-vterm 6)))
              ("M-7" . (lambda () (interactive) (switch-vterm 7)))
              ("M-8" . (lambda () (interactive) (switch-vterm 8)))
              ("M-9" . (lambda () (interactive) (switch-vterm 9))))
  :bind (:map vterm-mode-map
			  ("C-c C-c" . (lambda () (interactive) (vterm-send-key (kbd "C-c")))))

  :config
  ;; Don't query about killing vterm buffers, just kill it
  (defadvice vterm (after kill-with-no-query nil activate)
    (set-process-query-on-exit-flag (get-buffer-process ad-return-value) nil)))

(when (eq system-type 'darwin)
  (setq vterm-shell "/opt/homebrew/bin/fish"))
#+end_src

** Completion & Search

For completions and search, I use [[https://github.com/minad/vertico][Vertico]] and a suite of other packages that play well together:

- [[https://github.com/tumashu/vertico-posframe][vertico-posframe]]
- [[https://github.com/minad/consult][consult]]
- [[https://github.com/minad/marginalia][marginalia]]
- [[https://github.com/minad/corfu][corfu]]
- [[https://github.com/minad/cape][cape]]
- [[https://github.com/oantolin/orderless][orderless]]
- [[https://github.com/BurntSushi/ripgrep][ripgrep]]

*** Vertico

[[https://github.com/minad/vertico][Vertico]] is heart of this completion UI!

#+begin_src emacs-lisp
(use-package vertico
  :config
  (vertico-mode 1)
  (setq vertico-count                         25  ; Show more candidates
        read-extended-command-predicate       'command-completion-default-include-p
        read-file-name-completion-ignore-case t   ; Ignore case of file names
        read-buffer-completion-ignore-case    t   ; Ignore case in buffer completion
        completion-ignore-case                t)) ; Ignore case in completion
#+end_src

*** Vertico Posframe

[[https://github.com/tumashu/vertico-posframe][vertico-posframe]] makes Vertico appear in a small child frame, instead of as a
traditional minibuffer. I like to have mine in the middle of the frame.

#+begin_src emacs-lisp
(use-package vertico-posframe
  :config
  (vertico-posframe-mode 1)
  (setq vertico-posframe-width  90
        vertico-posframe-height vertico-count))
#+end_src

I temporarily disable =vertico-posframe-mode= when searching with =consult=.
When selecting a search match, a preview is provided. That's kind of hard to see
with the posframe in the middle of the screen, so while searching I just use the
normal minibuffer.

#+begin_src emacs-lisp
(defun my-consult-line-wrapper ()
  (interactive)
  (vertico-posframe-mode -1)
  (consult-line)
  (vertico-posframe-mode 1))

(defun my-consult-ripgrep-wrapper ()
  (interactive)
  (vertico-posframe-mode -1)
  (consult-ripgrep)
  (vertico-posframe-mode 1))

(bind-key "C-s"   #'my-consult-line-wrapper custom-bindings-map)
(bind-key "C-M-s" #'my-consult-ripgrep-wrapper custom-bindings-map)

; Ensure posframe is always restored when exiting a minibuffer
(add-hook 'minibuffer-exit-hook
          (lambda ()
            (vertico-posframe-mode 1)))
#+end_src

*** Consult

[[https://github.com/minad/consult][Consult]] provides a /ton/ of search, navigation, and completion functionality. I
would definitely recommend looking at the documentation to learn more about all
that it can do.

#+begin_src emacs-lisp
(use-package consult
  :bind (:map custom-bindings-map
              ("C-x b"   . consult-buffer)
			  ;; ("C-s"     . consult-line)
			  ;; ("M-s"     . consult-ripgrep)
			  ("C-c C-g" . consult-goto-line)))
#+end_src

*** Marginalia

[[https://github.com/minad/marginalia][Marginalia]] gives me annotations in the minibuffer.

#+begin_src emacs-lisp
(use-package marginalia
  :init 
  (marginalia-mode 1))
#+end_src

*** Corfu & Cape

[[https://github.com/minad/corfu][corfu]] gives me text completion at point.

#+begin_src emacs-lisp
(use-package corfu
  :custom
  (corfu-auto t)                 ;; Enable auto completion
  (corfu-cycle t)                ;; Enable cycling for `corfu-next/previous'
  (corfu-auto-delay 0)           ;; No delay
  (corfu-auto-prefix 2)          ;; Start when this many characters have been typed
  (corfu-popupinfo-delay 0.5)    ;; Short delay
  (corfu-preselect 'prompt)      ;; Preselect the prompt
  :init
  (global-corfu-mode))

(use-package emacs
  :init
  ;; TAB cycle if there are only few candidates
  (setq completion-cycle-threshold 3)

  ;; Hide commands in M-x which do not apply to the current mode.
  ;; Corfu commands are hidden, since they are not supposed to be used via M-x.
  (setq read-extended-command-predicate
        #'command-completion-default-include-p)

  ;; Enable indentation+completion using the TAB key.
  ;; `completion-at-point' is often bound to M-TAB.
  (setq tab-always-indent 'complete))
#+end_src

=corfu= also uses some of [[https://github.com/minad/cape][cape]]'s functionalities, so let's add that, too.

#+begin_src emacs-lisp
(use-package cape
  ;; Bind dedicated completion commands
  ;; Alternative prefix keys: C-c p, M-p, M-+, ...
  :bind (("C-c p p"  . completion-at-point) ;; capf
         ("C-c p t"  . complete-tag)        ;; etags
         ("C-c p d"  . cape-dabbrev)        ;; or dabbrev-completion
         ("C-c p h"  . cape-history)
         ("C-c p f"  . cape-file)
         ("C-c p k"  . cape-keyword)
         ("C-c p s"  . cape-symbol)
         ("C-c p a"  . cape-abbrev)
         ("C-c p l"  . cape-line)
         ("C-c p w"  . cape-dict)
         ("C-c p \\" . cape-tex)
         ("C-c p _"  . cape-tex)
         ("C-c p ^"  . cape-tex)
         ("C-c p &"  . cape-sgml)
         ("C-c p r"  . cape-rfc1345))
  :init
  ;; Add `completion-at-point-functions', used by `completion-at-point'.
  ;; NOTE: The order matters!
  (add-to-list 'completion-at-point-functions #'cape-dabbrev)
  (add-to-list 'completion-at-point-functions #'cape-file)
  (add-to-list 'completion-at-point-functions #'cape-elisp-block)
  (add-to-list 'completion-at-point-functions #'cape-history)
  (add-to-list 'completion-at-point-functions #'cape-keyword)
  (add-to-list 'completion-at-point-functions #'cape-tex)
  (add-to-list 'completion-at-point-functions #'cape-dict)
  ;;(add-to-list 'completion-at-point-functions #'cape-sgml)
  ;;(add-to-list 'completion-at-point-functions #'cape-rfc1345)
  ;;(add-to-list 'completion-at-point-functions #'cape-abbrev)
  ;;(add-to-list 'completion-at-point-functions #'cape-symbol)
  ;;(add-to-list 'completion-at-point-functions #'cape-line)
)
#+end_src

*** Orderless

And [[https://github.com/oantolin/orderless][Orderless]] is a package for a completion /style/, that matches multiple
regexes, in any order. Let's use it together with Corfu.

#+begin_src emacs-lisp
(use-package orderless
  :ensure t
  :config
  (setq completion-styles '(orderless basic partial-completion)
        completion-category-overrides '((file (styles basic partial-completion)))
        orderless-component-separator "[ |]"))
#+end_src

*** Ripgrep

I want to use [[https://github.com/BurntSushi/ripgrep][ripgrep]] as =grep=.

#+BEGIN_SRC emacs-lisp
(setq grep-command "rg -nS --no-heading "
      grep-use-null-device nil)
#+END_SRC

** Version Control

[[https://github.com/magit/magit][Magit]] is a Git client specifically for Emacs, and it's super powerful.

Let's first make sure we're highlighting uncommitted changes.

#+begin_src emacs-lisp
(use-package diff-hl
  :config
  (global-diff-hl-mode))
#+end_src

Then configure Magit.

#+begin_src emacs-lisp
(use-package magit
  :defer t
  :config
  (setq magit.mode-quit-window 'magit-restore-window-configuration)
  (add-hook 'magit-pre-refresh-hook  'diff-hl-magit-pre-refresh)
  (add-hook 'magit-post-refresh-hook 'diff-hl-magit-post-refresh))
#+end_src

And finally use [[https://github.com/alphapapa/magit-todos][magit-todos]] to show the project's TODOs directly in the Magit buffer.

#+begin_src emacs-lisp
(use-package magit-todos
  :after magit
  :config
  (magit-todos-mode 1))
#+end_src

** Auto-Saving

To avoid clutter, let's put all the auto-saved files into one and the same directory.

#+BEGIN_SRC emacs-lisp
(defvar emacs-autosave-directory
  (concat user-emacs-directory "autosaves/")
  "This variable dictates where to put auto saves. It is set to a
  directory called autosaves located wherever your .emacs.d/ is
  located.")

;; Sets all files to be backed up and auto saved in a single directory.
(setq backup-directory-alist
      `((".*" . ,emacs-autosave-directory))
      auto-save-file-name-transforms
      `((".*" ,emacs-autosave-directory t)))
#+END_SRC

I prefer having my files save automatically. Any changes I don't want, I just
don't commit to git. I use =auto-save-buffers-enhanced= to automatically save all
buffers, not just the ones I have open.

But since saving this file - the =init.org=-file - triggers recompilation of
=init.el=, it's really annoying if this file is autosaved when I write to it.
Therefore, I'll disable automatic saving for this file in particular.

#+BEGIN_SRC emacs-lisp
(use-package auto-save-buffers-enhanced
  :ensure t
  :config
  (auto-save-buffers-enhanced t)
  (setq auto-save-buffers-enhanced-exclude-regexps '("init.org")))
#+END_SRC

** Trying Packages

Lars Tveito's [[https://github.com/larstvei/Try][Try]] package lets you try out packages and only save them
temporarily, saving you the hassle of cleaning up afterwards if you decide you
don't want to keep using the package. You can even =try= packages from =.el= files
from URLs directly.

#+begin_src emacs-lisp
(use-package try)
#+end_src

** Snippets

[[https://github.com/joaotavora/yasnippet][YASnippet]] is a template system for Emacs that allows you to predefine snippets
you use often and insert them easily. I want snippets for basic Org-files,
Roam-notes, and other sequences often used.

#+begin_src emacs-lisp
(use-package yasnippet
  :diminish yas-minor-mode
  :defer 5
  :config
  (setq yas-snippet-dirs '("~/.emacs.d/snippets/"))
  (yas-global-mode 1)) ;; or M-x yas-reload-all if you've started YASnippet already.

;; Silences the warning when running a snippet with backticks (runs a command in the snippet)
(require 'warnings)
(add-to-list 'warning-suppress-types '(yasnippet backquote-change)) 
#+end_src

** Better Help Buffers

[[https://github.com/Wilfred/helpful][Helpful]] is an improvement on Emacs' built-in *help* buffer. It's more user-friendly and easier to read.

#+BEGIN_SRC emacs-lisp
(use-package helpful
  :bind (:map custom-bindings-map
			  ("C-h f" . #'helpful-function)
			  ("C-h v" . #'helpful-variable)
			  ("C-h k" . #'helpful-key)
			  ("C-h x" . #'helpful-command)
			  ("C-h d" . #'helpful-at-point)
			  ("C-h c" . #'helpful-callable)))
#+END_SRC

[[https://github.com/justbur/emacs-which-key][which-key]] shows you available keybindings in the minibuffer. When you've started
to enter a command, it will show you where you can go from there.

#+begin_src emacs-lisp
(use-package which-key
  :config
  (which-key-mode))
#+end_src

** Spelling

[[https://github.com/minad/jinx][Jinx]] is a =libenchant=-powered spellchecker with a super nice UI. I'm
trying it out instead of Flyspell, which I used before.

#+begin_src emacs-lisp
(use-package jinx
  :hook (emacs-startup . global-jinx-mode)
  :bind (("M-$" . jinx-correct)
         ("C-M-$" . jinx-languages)))
#+end_src

** LaTeX

I use [[https://www.gnu.org/software/auctex/][AUCTeX]] to work with LaTeX files from within Emacs and it's a massive help.
It has a lot of different features, and I'd recommend checking out the
documentation to see all the stuff you can do with it.

I also really like =reftex-mode=, which gives you a table of contents with
clickable links for your file with the keybinding =C-c ==.

#+begin_src emacs-lisp
(use-package auctex
  :hook
  (LaTeX-mode . turn-on-prettify-symbols-mode)
  (LaTeX-mode . reftex-mode)
  (LaTeX-mode . (lambda () (corfu-mode -1)))
  (LaTeX-mode . outline-minor-mode)
  (LaTeX-mode . olivetti-mode))
#+end_src

When the =reftex= window opens, I want it on the left side of the screen and I
want it to take up less than half the screen.

#+begin_src emacs-lisp
(setq reftex-toc-split-windows-horizontally t
	  reftex-toc-split-windows-fraction     0.2)
#+end_src

** Editor Config

I want to use the [[https://github.com/editorconfig/editorconfig-emacs][EditorConfig]] plugin, which helps maintain consistent coding
styles across editors when collaborating.

#+begin_src emacs-lisp
(use-package editorconfig
  :defer t)
#+end_src

** Browser Preference

Open links with Brave by default.

#+begin_src emacs-lisp
(setq browse-url-browser-function 'browse-url-generic
      browse-url-generic-program "brave-browser")
#+end_src

** Elfeed

[[https://github.com/skeeto/elfeed][Elfeed]] is a feed reader for Emacs!

#+begin_src emacs-lisp
(use-package elfeed
  :bind (:map custom-bindings-map ("C-x w" . elfeed))
  :config
  (setq elfeed-feeds
      '("http://nullprogram.com/feed/"
        "https://planet.emacslife.com/atom.xml"
		"https://deniskyashif.com/index.xml"
		"https://sophiebos.io/index.xml")))
#+end_src

** Code Screenshots

Sometimes, you want to take a screenshot of your buffer to share or use in a
presentation. [[https://github.com/tecosaur/screenshot][screenshot]] is a great and convenient package that captures the
selected region and presents it nicely -- no cropping needed and perfect for code screenshots!

#+begin_src emacs-lisp :tangle no
(require 'screenshot)
#+end_src

** Config Profiling

[[https://github.com/jschaf/esup][ESUP]] is a package for profiling your config. You can use it to shave precious seconds off your
startup time, which is useful to me because I keep closing it when I'm done with
a task and then immediately needing it again.

#+begin_src emacs-lisp
(use-package esup
  :defer t
  :config
  (setq esup-depth 0))
#+end_src

* Org

[[https://orgmode.org/][Org Mode]] is a smart text system that is used for organising notes, literate programming, time management, and a wide variety of other use cases. I've been interested in switching from my previous note-taking app, Obsidian, to using Org and Roam (described in the next section).

Let's first make sure we're using Org. Note that I am leaving the last
parenthesis open, to include some options from the "Visuals" section inside the
=use-package= declaration for Org mode.

#+BEGIN_SRC emacs-lisp
(use-package org
  :defer t
#+END_SRC

** Visuals
*** Text Centring

*Note:* We are still in the =:config= section of the =use-package= declaration for Org
mode.

I always want to center the text and enable linebreaks in Org. I've added
a hook to activate =olivetti-mode=, and =visual-fill-mode=
is always on.

#+begin_src emacs-lisp
:hook (org-mode . olivetti-mode)
#+end_src

*** Fonts

*Note:* We are in the =:config= section of the =use-package= declaration for Org mode.

Set the sizes and fonts for the various headings.

#+begin_src emacs-lisp
  :config
  ;; Resize Org headings
  (custom-set-faces
  '(org-document-title ((t (:height 1.8))))
  '(outline-1          ((t (:height 1.35))))
  '(outline-2          ((t (:height 1.3))))
  '(outline-3          ((t (:height 1.2))))
  '(outline-4          ((t (:height 1.1))))
  '(outline-5          ((t (:height 1.1))))
  '(outline-6          ((t (:height 1.1))))
  '(outline-8          ((t (:height 1.1))))
  '(outline-9          ((t (:height 1.1)))))
#+END_src

*** Opening Links

*Note:* We are still in the =:config= section of the =use-package= declaration for Org
mode.

By default, when opening an Org-link, the current window is split into two. I'd like for the new window to replace the current one. To do this, we need to edit =org-link-frame-setup= and change the default cons =(file . find-file-other-window)= to =(file . find-file)=.

#+begin_src emacs-lisp :tangle no
(setq org-link-frame-setup
	  '((vm      . vm-visit-folder-other-frame)
		(vm-imap . vm-visit-imap-folder-other-frame)
		(gnus    . org-gnus-no-new-news)
		(file    . find-file)
		(wl      . wl-other-frame)))
#+end_src

*** LaTeX Previews

*Note:* We are in the =:config= section of the =use-package= declaration for Org mode.

Preview LaTeX fragments by default.

#+begin_src emacs-lisp
(setq org-startup-with-latex-preview t)
#+end_src

Increase the size of LaTeX previews in Org.

#+begin_src emacs-lisp
(plist-put org-format-latex-options :scale 1.35)
#+end_src

*** Folded Startup

*Note:* We are still in the =:config= section of the =use-package= declaration for Org
mode.

In general, show me all the headings.

#+begin_src emacs-lisp
(setq org-startup-folded 'content)
#+end_src

*** Decluttering

*Note:* We are still in the =:config= section of the =use-package= declaration for Org mode.

We'll declutter by adapting the indentation and hiding leading starts in headings. We'll also use [[https://orgmode.org/manual/Special-Symbols.html]["pretty entities"]], which allow us to
insert special characters LaTeX-style by using a leading backslash (e.g., =\alpha= to
write the greek letter alpha) and display ellipses in a condensed way.

#+begin_src emacs-lisp
  (setq org-adapt-indentation t
		org-hide-leading-stars t
		org-pretty-entities t
		org-ellipsis "  ·")
#+end_src

For source code blocks specifically, I want Org to display the contents using
the major mode of the relevant language. I also want TAB to behave inside the
source code block like it normally would when writing code in that language.

#+begin_src emacs-lisp
  (setq org-src-fontify-natively t
		org-src-tab-acts-natively t
		org-edit-src-content-indentation 0)
#+end_src

Some Org options to deal with headers and TODO's nicely.

#+begin_src emacs-lisp
  (setq org-log-done                       t
        org-auto-align-tags                t
        org-tags-column                    -80
        org-fold-catch-invisible-edits     'show-and-error
        org-special-ctrl-a/e               t
        org-insert-heading-respect-content t)
#+end_src

Let's finally close the =use-package= declaration with a parenthesis.

#+begin_src emacs-lisp
)
#+end_src

*** Hide Emphasis Markers

Many people hide emphasis markers (e.g., =/.../= for italics, =*...*= for bold,
etc.) to have a cleaner visual look, but I got frustrated trying to go back and
edit text in these markers, as sometimes I would delete the markers itself or
write outside the markers. [[https://github.com/awth13/org-appear][org-appear]] is the solution to all my troubles. It
displays the markers when the cursor is within them and hides them otherwise,
making edits easy while looking pretty.

#+begin_src emacs-lisp
(use-package org-appear
  :commands (org-appear-mode)
  :hook     (org-mode . org-appear-mode)
  :config 
  (setq org-hide-emphasis-markers t)  ; Must be activated for org-appear to work
  (setq org-appear-autoemphasis   t   ; Show bold, italics, verbatim, etc.
        org-appear-autolinks      t   ; Show links
        org-appear-autosubmarkers t)) ; Show sub- and superscripts
#+end_src

*** Inline Images

Show inline images by default

#+begin_src haskell
(setq org-startup-with-inline-images t)
#+end_src

*** Variable Pitch

Make sure =variable-pitch-mode= is always active in Org buffers. I normally
wouldn't need this, since I use the =mixed-pitch= package in the font section, but
for some reason, it seems the header bullet in Org mode are affected by this.

#+begin_src emacs-lisp
(add-hook 'org-mode-hook 'variable-pitch-mode)
#+end_src

*** Fragtog for LaTeX Previews

[[https://github.com/io12/org-fragtog][org-fragtog]] works like org-appear, but for LaTeX fragments: It toggles LaTeX
previews on and off automatically, depending on the cursor position. If you move the
cursor to a preview, it's toggled off so you can edit the LaTeX snippet. When
you move the cursor away, the preview is turned on again.

#+begin_src emacs-lisp
(use-package org-fragtog
  :after org
  :hook (org-mode . org-fragtog-mode))
#+end_src

*** Bullets

=org-superstar= styles some of my UI elements, such as bullets and special
checkboxes for TODOs.

#+begin_src emacs-lisp
(use-package org-superstar
  :after org
  :config
  (setq org-superstar-leading-bullet " ")
  (setq org-superstar-headline-bullets-list '("◇" "⚬" "•" "‣" "*"))
  (setq org-superstar-special-todo-items t) ;; Makes TODO header bullets into boxes
  (setq org-superstar-todo-bullet-alist '(("TODO"  . 9744)
                                          ("WAIT"  . 9744)
                                          ("READ"  . 9744)
                                          ("PROG"  . 9744)
										  ("DONE"  . 9745)))
  :hook (org-mode . org-superstar-mode))
#+end_src

*** SVG Elements

[[https://github.com/rougier/svg-tag-mode][svg-tag-mode]] lets you replace keywords such as TODOs, tags, and progress bars with nice
SVG graphics. I use it for dates, progress bars, and citations.

#+begin_src emacs-lisp
(use-package svg-tag-mode
  :after org
  :config
  (defconst date-re "[0-9]\\{4\\}-[0-9]\\{2\\}-[0-9]\\{2\\}")
  (defconst time-re "[0-9]\\{2\\}:[0-9]\\{2\\}")
  (defconst day-re "[A-Za-z]\\{3\\}")
  (defconst day-time-re (format "\\(%s\\)? ?\\(%s\\)?" day-re time-re))

  (defun svg-progress-percent (value)
	(svg-image (svg-lib-concat
				(svg-lib-progress-bar (/ (string-to-number value) 100.0)
			      nil :margin 0 :stroke 2 :radius 3 :padding 2 :width 11)
				(svg-lib-tag (concat value "%")
				  nil :stroke 0 :margin 0)) :ascent 'center))

  (defun svg-progress-count (value)
	(let* ((seq (mapcar #'string-to-number (split-string value "/")))
           (count (float (car seq)))
           (total (float (cadr seq))))
	  (svg-image (svg-lib-concat
				  (svg-lib-progress-bar (/ count total) nil
					:margin 0 :stroke 2 :radius 3 :padding 2 :width 11)
				  (svg-lib-tag value nil
					:stroke 0 :margin 0)) :ascent 'center)))
  (setq svg-tag-tags
      `(
        ;; Org tags
        ;; (":\\([A-Za-z0-9]+\\)" . ((lambda (tag) (svg-tag-make tag))))
        ;; (":\\([A-Za-z0-9]+[ \-]\\)" . ((lambda (tag) tag)))
        
        ;; Task priority
        ("\\[#[A-Z]\\]" . ( (lambda (tag)
                              (svg-tag-make tag :face 'org-priority 
                                            :beg 2 :end -1 :margin 0))))

        ;; Progress
        ("\\(\\[[0-9]\\{1,3\\}%\\]\\)" . ((lambda (tag)
          (svg-progress-percent (substring tag 1 -2)))))
        ("\\(\\[[0-9]+/[0-9]+\\]\\)" . ((lambda (tag)
          (svg-progress-count (substring tag 1 -1)))))
        
        ;; TODO / DONE
        ;; ("TODO" . ((lambda (tag) (svg-tag-make "TODO" :face 'org-todo
		;; 									           :inverse t :margin 0))))
        ;; ("DONE" . ((lambda (tag) (svg-tag-make "DONE" :face 'org-done :margin 0))))


        ;; Citation of the form [cite:@Knuth:1984] 
        ("\\(\\[cite:@[A-Za-z]+:\\)" . ((lambda (tag)
                                          (svg-tag-make tag
                                                        :inverse t
                                                        :beg 7 :end -1
                                                        :crop-right t))))
        ("\\[cite:@[A-Za-z]+:\\([0-9]+\\]\\)" . ((lambda (tag)
                                                (svg-tag-make tag
                                                              :end -1
                                                              :crop-left t))))

        
        ;; Active date (with or without day name, with or without time)
        (,(format "\\(<%s>\\)" date-re) .
         ((lambda (tag)
            (svg-tag-make tag :beg 1 :end -1 :margin 0))))
        (,(format "\\(<%s \\)%s>" date-re day-time-re) .
         ((lambda (tag)
            (svg-tag-make tag :beg 1 :inverse nil :crop-right t :margin 0))))
        (,(format "<%s \\(%s>\\)" date-re day-time-re) .
         ((lambda (tag)
            (svg-tag-make tag :end -1 :inverse t :crop-left t :margin 0))))

        ;; Inactive date  (with or without day name, with or without time)
         (,(format "\\(\\[%s\\]\\)" date-re) .
          ((lambda (tag)
             (svg-tag-make tag :beg 1 :end -1 :margin 0 :face 'org-date))))
         (,(format "\\(\\[%s \\)%s\\]" date-re day-time-re) .
          ((lambda (tag)
             (svg-tag-make tag :beg 1 :inverse nil
						       :crop-right t :margin 0 :face 'org-date))))
         (,(format "\\[%s \\(%s\\]\\)" date-re day-time-re) .
          ((lambda (tag)
             (svg-tag-make tag :end -1 :inverse t
						       :crop-left t :margin 0 :face 'org-date)))))))

(add-hook 'org-mode-hook 'svg-tag-mode)
#+end_src

*** Prettify Tags & Keywords

I have a custom function to prettify tags and other elements, lifted from [[https://github.com/jakebox/jake-emacs/blob/main/jake-emacs/jib-funcs.el][Jake
B's Emacs setup]].

#+begin_src emacs-lisp
(defun my/prettify-symbols-setup ()
  "Beautify keywords"
  (setq prettify-symbols-alist
		(mapcan (lambda (x) (list x (cons (upcase (car x)) (cdr x))))
				'(; Greek symbols
				  ("lambda" . ?λ)
				  ("delta"  . ?Δ)
				  ("gamma"  . ?Γ)
				  ("phi"    . ?φ)
				  ("psi"    . ?ψ)
				  ; Org headers
				  ("#+title:"  . "")
				  ("#+author:" . "")
				  ; Checkboxes
				  ("[ ]" . "")
				  ("[X]" . "")
				  ("[-]" . "" )
				  ; Blocks
				  ("#+begin_src"   . "") ; 
				  ("#+end_src"     . "")
				  ("#+begin_QUOTE" . "‟")
				  ("#+begin_QUOTE" . "”")
				  ; Drawers
				  ;    ⚙️
				  (":properties:" . "")
				  ; Agenda scheduling
				  ("SCHEDULED:"   . "🕘")
				  ("DEADLINE:"    . "⏰")
				  ; Agenda tags  
				  (":@projects:"  . "☕")
				  (":work:"       . "🚀")
				  (":@inbox:"     . "✉️")
				  (":goal:"       . "🎯")
				  (":task:"       . "📋")
				  (":@thesis:"    . "📝")
				  (":thesis:"     . "📝")
				  (":uio:"        . "🏛️")
				  (":emacs:"      . "")
				  (":learn:"      . "🌱")
				  (":code:"       . "💻")
				  (":fix:"        . "🛠️")
				  (":bug:"        . "🚩")
				  (":read:"       . "📚")
				  ; Roam tags
				  ("#+filetags:"  . "📎")
				  (":wip:"        . "🏗️")
				  (":ct:"         . "") ; Category Theory
				  )))
  (prettify-symbols-mode))

(add-hook 'org-mode-hook        #'my/prettify-symbols-setup)
(add-hook 'org-agenda-mode-hook #'my/prettify-symbols-setup)
#+end_src

*** Right-Align Tags

Code snippet from [[https://www.reddit.com/r/emacs/comments/185e4k1/comment/kb39xvy/?utm_source=share&utm_medium=web2x&context=3][this Reddit post]]. It actually right-aligns tags, using
font-lock and the display property.

#+begin_src emacs-lisp
(add-to-list 'font-lock-extra-managed-props 'display)
(font-lock-add-keywords 'org-mode
                        `(("^.*?\\( \\)\\(:[[:alnum:]_@#%:]+:\\)$"
                           (1 `(face nil
                                     display (space :align-to (- right ,(org-string-width (match-string 2)) 3)))
                              prepend))) t)
#+end_src

** Org QL

[[https://github.com/alphapapa/org-ql][org-ql]] is a query language for Org mode. I use it to find things and to set up a
pretty calendar view.

#+begin_src emacs-lisp
(use-package org-ql
  :defer t)
#+end_src

** Tasks
*** Task Priorities

Let's increase the number of possible priorities for Org tasks. I'll set
mine to =E= so that we have =A= through =E=, in total five levels.

#+begin_src emacs-lisp
(setq org-lowest-priority ?F)  ;; Gives us priorities A through F
(setq org-default-priority ?E) ;; If an item has no priority, it is considered [#E].

(setq org-priority-faces
      '((65 . "#BF616A")
        (66 . "#EBCB8B")
        (67 . "#B48EAD")
        (68 . "#81A1C1")
        (69 . "#5E81AC")
        (70 . "#4C566A")))
#+end_src

*** Custom TODO States

I'll expand the list of default task states.

#+begin_src emacs-lisp
(setq org-todo-keywords
      '((sequence
		 "TODO(t)" "WAIT(w)" "READ(r)" "PROG(p)" ; Needs further action
		 "|"
		 "DONE(d)")))                            ; Needs no action currently
#+end_src

*** Mark As Done

Finally, to mark any TODO task, of any state, as DONE quickly, I have a helper
function that I'll bind to =C-c d=.

#+begin_src emacs-lisp
(defun org-mark-as-done ()
  (interactive)
  (save-excursion
    (org-back-to-heading t) ;; Make sure command works even if point is
                            ;; below target heading
    (cond ((looking-at "\*+ TODO")
           (org-todo "DONE"))
          ((looking-at "\*+ WAIT")
           (org-todo "DONE"))
		  ((looking-at "\*+ READ")
           (org-todo "DONE"))
		  ((looking-at "\*+ PROG")
           (org-todo "DONE"))
		  ((looking-at "\*+ DONE")
           (org-todo "DONE"))
          (t (message "Undefined TODO state.")))))

(define-key custom-bindings-map (kbd "C-c d") 'org-mark-as-done)
#+end_src

*** "Get Things Done" Setup

I'm trying out the Get Things Done method by David Allen, using Nicolas
Rougier's [[https://github.com/rougier/emacs-gtd][GTD configuration]] and Nicolas Petton's [[https://emacs.cafe/emacs/orgmode/gtd/2017/06/30/orgmode-gtd.html][blog post]] on the subject.

The first step is to set the relevant directories.

#+BEGIN_SRC emacs-lisp
(setq org-directory "~/Dropbox/org/")
(setq org-agenda-files (list "inbox.org" "thesis.org"))
#+END_SRC

Set the archive location to a unified archive.

#+begin_src emacs-lisp
(setq org-archive-location (concat org-directory "archive.org::"))
#+end_src

Then to set up the relevant capture templates, with accompanying keybindings.

#+BEGIN_SRC emacs-lisp
(setq org-capture-templates
       `(("i" "Inbox" entry  (file "inbox.org")
        ,(concat "* TODO %?\n"
                 "/Entered on/ %U"))
		 ("t" "Thesis" entry  (file "thesis.org")
        ,(concat "* TODO %?\n"
                 "/Entered on/ %U"))))
(defun org-capture-inbox ()
     (interactive)
     (call-interactively 'org-store-link)
     (org-capture nil "i"))
#+END_SRC

*** Keybindings

For basic agenda and TODO-related keybindings, I'll use =C-c= followed by a
single, lower-case letter.

#+BEGIN_SRC emacs-lisp
(define-key custom-bindings-map (kbd "C-c l") 'org-store-link)
(define-key custom-bindings-map (kbd "C-c a") 'org-agenda)
(define-key custom-bindings-map (kbd "C-c c") 'org-capture)
(define-key custom-bindings-map (kbd "C-c t") 'org-todo)
#+END_SRC

For whatever reason, I've had an issue with clocking in, where the default
keybinding used =TAB= instead of =C-i= to clock in, so I'll set that manually.

#+begin_src emacs-lisp :tangle no
(define-key org-mode-map (kbd "C-c C-x C-i") 'org-clock-in)
#+end_src

*** Registers

[[https://www.gnu.org/software/emacs/manual/html_node/emacs/Registers.html][Registers]] are easier to access than bookmarks and much more flexible. I'll set
up registers for my GTD files.

#+begin_src emacs-lisp
(set-register ?1 (cons 'file (concat org-directory "inbox.org")))
(set-register ?2 (cons 'file (concat org-directory "thesis.org")))
(set-register ?3 (cons 'file (concat org-directory "roam/20240128135100-roam.org")))
(set-register ?4 (cons 'file (concat org-directory "projects.org")))
#+end_src

Since I have =C-s= bound to =consult-line= which lets me search everywhere in a
file, I don't really need =C-r= to be bound to the default =isearch-backward=.
Instead, I can use it as the leader key combination to jump to a register.

#+begin_src emacs-lisp
(define-key custom-bindings-map (kbd "C-r") 'jump-to-register)
#+end_src

** Agenda

I want to open my agenda on the current day, not on any specific weekday.

#+begin_src emacs-lisp
(setq org-agenda-start-on-weekday nil
	  org-agenda-block-separator  nil)
#+end_src

*** Super Agenda

[[https://github.com/alphapapa/org-super-agenda][org-super-agenda]] lets you group agenda items into sections, so it's easier to
navigate.

#+begin_src emacs-lisp
(use-package org-super-agenda
  :after org
  :config
  (setq org-super-agenda-header-prefix "❯ ")
  ;; Hide the thin width char glyph
  (add-hook 'org-agenda-mode-hook
            #'(lambda () (setq-local nobreak-char-display nil)))
  (setq org-super-agenda-groups
		'((:name "Today"
				 :scheduled t
				 :order 1)
		  (:name "In Progress"
				 :todo "PROG"
				 :order 2)
		  (:name "Deadlines"
				 :deadline t
				 :order 3)
		  (:name "Ardoq"
				 :tag "work"
				 :order 4)
		  (:name "Inbox"
				 :tag "@inbox"
				 :order 5)
		  (:name "Thesis"
				 :tag "@thesis"
				 :order 6)
		  (:name "Unscheduled important"
				 :priority "A"
				 :order 7)))
  (org-super-agenda-mode))
#+end_src

*** Day Views

Open day view with =C-c a d= and extended three-day view with =C-c a e=.

#+begin_src emacs-lisp
;; Delete defaults
(setq org-agenda-custom-commands nil)

(add-to-list 'org-agenda-custom-commands
	  '("d" "Day View"
		 ((agenda "" ((org-agenda-overriding-header "Day View")
					  (org-agenda-span 'day)))
          (org-ql-block '(todo "PROG") ((org-ql-block-header ""))))))


(add-to-list 'org-agenda-custom-commands
		'("e" "Three-Day View"
               ((agenda "" ((org-agenda-span 3)
                            (org-agenda-start-on-weekday nil)
                            (org-deadline-warning-days 0))))))
#+end_src

*** Displaying Scheduled & Deadline Items

Don't show me deadlines or scheduled items if they are done.

#+begin_src emacs-lisp
(setq org-agenda-skip-deadline-if-done  t
	  org-agenda-skip-scheduled-if-done t)
#+end_src

Modify dealine leader text.

#+begin_src emacs-lisp
(setq org-agenda-deadline-leaders '("Deadline:  " "In %2d d.: " "%2d d. ago: "))
#+end_src

*** Startup with Agenda View

I used to have a nice dashboard as a welcome screen, but when I open
Emacs, I usually just open a recently opened buffer with =C-x b=
or I open a project with =C-c p p=. It's more useful to me to
immediately get an overview of  my tasks so I can jump right into it.
The below hook runs my custom agenda function to open a day view, and
deletes other windows so I don't see the agenda *and* the scratch buffer.

#+begin_src emacs-lisp
(add-hook 'after-init-hook
		  (lambda () (progn (org-agenda nil "d")
					(delete-other-windows)
					(olivetti-mode))))
#+end_src

** Babel

For working with code blocks in Org mode, I want to make sure code blocks are
not evaluated by default on export. I also want to add some languages.

#+begin_src emacs-lisp
(setq org-export-use-babel       nil
	  org-confirm-babel-evaluate nil)
;; (org-babel-do-load-languages
;;  'org-babel-load-languages
;;  '((emacs-lisp . t)
;;    (python     . t)
;;    (haskell    . t)
;;    (clojure    . t)))
#+end_src

For Python, use whatever interpreter is set by =python-shell-interpreter=.

#+begin_src emacs-lisp
(use-package ob-python
  :ensure nil
  :after (ob python)
  :config
  (setq org-babel-python-command python-shell-interpreter))
#+end_src

** Roam   

[[https://roamresearch.com/][Roam]] is a smart note-taking system in the style of a personal knowledge
management system. [[https://www.orgroam.com/][org-roam]] is a port of this system that uses all plain-text Org-files.

I set up a Roam directory and added a simple configuration for navigating Roam nodes.

#+begin_src emacs-lisp
(use-package org-roam
  :after org
  :hook (org-roam-mode . org-roam-db-autosync-mode)
  :init
  (setq org-roam-v2-ack t)
  :custom
  (org-roam-directory "~/Dropbox/org/roam")
  (org-roam-completion-everywhere t)
  :bind
  ("C-c n t" . org-roam-buffer-toggle)
  ("C-c n f" . org-roam-node-find)
  ("C-c n i" . org-roam-node-insert)
  ("C-c q"   . org-roam-tag-add)
  :config
  (org-roam-db-autosync-enable))
#+end_src

*** Consult Org Roam

#+begin_src emacs-lisp
(use-package consult-org-roam
   :ensure t
   :after org-roam
   :init
   (require 'consult-org-roam)
   ;; Activate the minor mode
   (consult-org-roam-mode 1)
   :custom
   ;; Use `ripgrep' for searching with `consult-org-roam-search'
   (consult-org-roam-grep-func #'consult-ripgrep)
   ;; Configure a custom narrow key for `consult-buffer'
   (consult-org-roam-buffer-narrow-key ?r)
   ;; Display org-roam buffers right after non-org-roam buffers
   ;; in consult-buffer (and not down at the bottom)
   (consult-org-roam-buffer-after-buffers t)
   :config
   ;; Eventually suppress previewing for certain functions
   (consult-customize
    consult-org-roam-forward-links
    :preview-key "M-.")
   :bind
   ;; Define some convenient keybindings as an addition
   ("C-c n e" . consult-org-roam-file-find)
   ("C-c n b" . consult-org-roam-backlinks)
   ("C-c n l" . consult-org-roam-forward-links)
   ("C-c n r" . consult-org-roam-search))
#+end_src

*** Show Tags in Search

When searching for nodes, you can search either by name or by tag. Both are
shown in the menu.

#+begin_src emacs-lisp
(setq org-roam-node-display-template
	  (concat "${title:*} "
			  (propertize "${tags:10}" 'face 'org-tag)))
#+end_src

*** Follow Links

Follow links with RET.

#+begin_src emacs-lisp
(setq org-return-follows-link t)
#+end_src

*** Graph UI

[[https://github.com/org-roam/org-roam-ui][Org Roam UI]] gives you a pretty and functional graph of your notes, Obsidian-style.

#+begin_src emacs-lisp
(use-package org-roam-ui
    :after org-roam
    :config
    (setq org-roam-ui-sync-theme t
          org-roam-ui-follow t
          org-roam-ui-update-on-save t
          org-roam-ui-open-on-start t))
#+end_src

** Hugo

[[https://gohugo.io/][Hugo]] is a static site generator. By default, it uses a Markdown flavour called
Blackfriday. The package [[https://github.com/kaushalmodi/ox-hugo/][ox-hugo]] can export Org files to this format, and
also generate appropriate front-matter. I use it to write my blog in Org and
easily put it online.

#+BEGIN_SRC emacs-lisp
(use-package ox-hugo
  :after org)
#+END_SRC

I've had a great time blogging with =ox-hugo=, but it's a little bothersome to
have to rewrite the front-matter required in the blog post for it to export
property every time, so below is a little snippet lifted from [[https://ox-hugo.scripter.co/doc/org-capture-setup/][ox-hugo's blog]].

The file =all-posts,org= needs to be present in 'org-directory' and the file's
heading must be "Blog Posts". It can even be a symlink pointing to the actual location of all-posts.org! If you've named yours differently, change these values.

#+begin_src emacs-lisp
(with-eval-after-load 'org-capture
  (defun org-hugo-new-subtree-post-capture-template ()
    "Returns `org-capture' template string for new Hugo post.
See `org-capture-templates' for more information."
    (let* ((title (read-from-minibuffer "Post Title: "))
           (fname (org-hugo-slug title)))
      (mapconcat #'identity
                 `(
                   ,(concat "* TODO " title)
                   ":PROPERTIES:"
                   ,(concat ":EXPORT_FILE_NAME: " fname)
                   ":END:"
                   "%?\n")          ;Place the cursor here finally
                 "\n")))

  (add-to-list 'org-capture-templates
               '("h"                ;`org-capture' binding + h
                 "Hugo post"
                 entry
                 (file+olp "all-posts.org" "Blog Posts")
                 (function org-hugo-new-subtree-post-capture-template))))
#+end_src

** Org Conveniencies
*** Pasting Images with =org-download=

[[https://github.com/abo-abo/org-download][org-download]] lets me easily put copied screenshots into my org-documents.

#+begin_src emacs-lisp
(use-package org-download
  :after org
  :bind
  (:map org-mode-map
        (("s-t" . org-download-screenshot)
         ("s-y" . org-download-clipboard))))
#+end_src

*** TOC in Org Files

[[https://github.com/snosov1/toc-org][toc-org]] creates nice, Markdown compatible tables of content for your Org files.
Perfect for GitHub READMEs.

#+begin_src emacs-lisp
(use-package toc-org
  :after org
  :config
  (add-hook 'org-mode-hook 'toc-org-mode)

  ;; enable in markdown, too
  (add-hook 'markdown-mode-hook 'toc-org-mode))
#+end_src

* Programming
** Preferences & Extras
*** Custom File Endings

For my MSc thesis, I'm implementing a small functional programming language
called Contra. It's pretty similar to Haskell, so using Haskell mode does a
fairly good job of syntax highlighting my =.con=-files.

#+begin_src emacs-lisp
(add-to-list 'auto-mode-alist '("\\.con\\'" . haskell-mode))
#+end_src

*** Language-Specific Commenting

I use =C-'= to comment/uncomment lines with [[https://github.com/redguardtoo/evil-nerd-commenter][Evil Nerd Commenter]]. It automatically
detects most programming languages and applies appropriate comment style.

#+begin_src emacs-lisp
(use-package evil-nerd-commenter
  :defer t
  :bind (:map custom-bindings-map ("C-'" . evilnc-comment-or-uncomment-lines)))
#+end_src

*** Subword Mode

[[https://wikemacs.org/wiki/Subword-mode][subword-mode]] lets you work on each subword in camel case words as individual
words. It makes it much easier to delete and mark parts of function and variable
names.

#+begin_src emacs-lisp
(add-hook 'prog-mode-hook 'subword-mode)
#+end_src

*** WakaTime

[[https://wakatime.com][WakaTime]] is an automatic time-tracking plugin.
[[https://github.com/wakatime/wakatime-mode][wakatime-mode]] integrates it with Emacs.

#+begin_src emacs-lisp
(use-package wakatime-mode
  :config
  (when (eq system-type 'gnu/linux)
	(setq wakatime-cli-path "~/.wakatime/wakatime-cli-linux-amd64")
	(setq wakatime-api-key (auth-source-pick-first-password :host "wakatime"))
	(global-wakatime-mode)))
#+end_src

*** Markdown

Need-to-have for programmers.

#+begin_src emacs-lisp
(use-package markdown-mode
  :defer t)
#+end_src

** Tree-Sitter

[[https://github.com/emacs-tree-sitter/elisp-tree-sitter][Tree-sitter]] is an incremental parsing library, and Emacs bindings now come built into Emacs 29+ if you choose to build Emacs with tree-sitter support.

Once setup, you can get tree-sitter grammars by building them or downloading them. The hard work has already been done for us, for example [[https://github.com/casouri/tree-sitter-module/][here]] and [[https://github.com/emacs-tree-sitter/tree-sitter-langs][here]].

If you want to keep these in a location outside the =.emacs.d= directory, you can set =treesit-extra-load-path=.

** Eglot

[[https://github.com/joaotavora/eglot][Eglot]] (Emacs polyGLOT) is an LSP server client for Emacs that comes
pre-installed from Emacs 29. If using a previous version, you can of course also install
it manually!

#+begin_src emacs-lisp
(use-package eglot
  :defer t
  :hook
  ((eglot-managed-mode . (lambda () (eglot-inlay-hints-mode -1))))
  :custom
  (eglot-autoshutdown t)
  (eglot-events-buffer-size 0)
  (eglot-stay-out-of '(yasnippet)))
#+end_src

As [[https://andreyor.st/posts/2023-09-09-migrating-from-lsp-mode-to-eglot/][this blog post]] describes, the Java and Clojure LSPs use a dependency system
to go to definitions that came from external libraries. To make this work with
Eglot, we need a dedicated package.

#+begin_src emacs-lisp
(use-package jarchive
  :ensure t
  :after eglot
  :config
  (jarchive-mode))
#+end_src

** Flycheck

[[https://github.com/flycheck/flycheck][Flycheck]] is an on-the-fly syntax checker.

#+begin_src emacs-lisp
(use-package flycheck
  :ensure t
  :init (global-flycheck-mode))
#+end_src

** HTTP

[[https://github.com/pashky/restclient.el][restclient.el]] lets you run HTTP requests from a static, plain-text query file.

#+begin_src emacs-lisp
(use-package restclient
  :defer t)
#+end_src

** Programming Languages
*** Haskell

 For Haskell, I think the regular =haskell-mode= is nice. I'll add =haskell-doc-mode=
 which uses eldoc consistently throughout.

 I also want to use the tool [[https://github.com/ndmitchell/hoogle][Hoogle]] from directly within Emacs to quickly
 look up functions and packages. I've set it up according to the GitHub docs, so
 that =C-c h= opens a prompt and querying the database opens a help buffer inside
 Emacs with the results.

 #+BEGIN_SRC emacs-lisp
 (use-package haskell-mode
   :defer t
   :hook (haskell-mode . haskell-doc-mode)
   :config
   (setq haskell-hoogle-command                  "hoogle"
		 haskell-compile-stack-build-command     "stack build"
		 haskell-compile-stack-build-alt-command "stack build --pedantic")
   :bind (:map haskell-mode-map
			   ("C-c C-h" . haskell-hoogle)
			   ("C-c C-c" . haskell-compile)))
 #+END_SRC

*** Agda

 To install Agda, you need Haskell - stack or cabal - and a few other
 programs. Once those are installed, you can add this to your =init.el=.
 Or you can just let =agda-mode setup= do it for you.

 #+begin_src emacs-lisp :tangle no
 (load-file (let ((coding-system-for-read 'utf-8))
                 (shell-command-to-string "agda-mode locate")))
 #+end_src

*** OCaml

 OCaml requires some setup for =ocp-indent=,

 #+begin_src emacs-lisp :tangle no
 (use-package ocp-indent
   :defer t)
 #+end_src

 and for =merlin=.
 
 #+begin_src emacs-lisp
 (let ((opam-share (ignore-errors (car (process-lines "opam" "var" "share")))))
       (when (and opam-share (file-directory-p opam-share))
		;; Register Merlin
		(add-to-list 'load-path (expand-file-name "emacs/site-lisp" opam-share))
		(autoload 'merlin-mode "merlin" nil t nil)
		;; Automatically start it in OCaml buffers
		(add-hook 'tuareg-mode-hook 'merlin-mode t)
		(add-hook 'caml-mode-hook 'merlin-mode t)
		;; Use opam switch to lookup ocamlmerlin binary
		(setq merlin-command 'opam)))
 #+end_src

 Then I want integration with Dune, Merlin, and utop for the full IDE-experience.

 #+begin_src emacs-lisp
 ;; Major mode for OCaml programming
 (use-package tuareg
   :defer t
   :mode (("\\.ocamlinit\\'" . tuareg-mode)))

 ;; Major mode for editing Dune project files
 (use-package dune
   :defer t)

 ;; Merlin provides advanced IDE features
 (use-package merlin
   :defer t
   :config
   (add-hook 'tuareg-mode-hook #'merlin-mode)
   ;; we're using flycheck instead
   (setq merlin-error-after-save nil))

 (use-package merlin-eldoc
   :defer t
   :hook ((tuareg-mode) . merlin-eldoc-setup))

 ;; utop REPL configuration
 (use-package utop
   :defer t
   :config
   (add-hook 'tuareg-mode-hook #'utop-minor-mode))
 #+end_src

*** Python

 Let's first set the language interpreter.

 #+begin_src emacs-lisp
 (use-package python
   :interpreter ("python3" . python-mode)
   :defer t
   :config
   (setq python-shell-interpreter "python3.11")
   (add-hook 'python-mode
			 (lambda () (setq forward-sexp-function nil))))
 #+end_src

 Note that you also need =pyright= for this! Installation will depend on your
 system. It's available from [[https://pypi.org/project/pyright/][PyPI]]. On Ubuntu, I had the most luck installing via
 snap:

 #+begin_src shell :tangle no
 sudo snap install pyright --classic
 #+end_src

 Then, I want to hide the modeline for inferior Python processes to save screen
 space. There's a [[https://github.com/hlissner/emacs-hide-mode-line][dedicated package]] for this.

 #+begin_src emacs-lisp
 (use-package hide-mode-line
   :defer t
   :hook (inferior-python-mode . hide-mode-line-mode))
 #+end_src<

*** Clojure

 [[https://github.com/clojure-emacs/cider][CIDER]] adds support for interactive Clojure programming in Emacs. It's provides
 built-in support for firing up a REPL and looking up documentation and source
 code, but it also has very Emacs-like shortcuts for expected actions, such as
 =C-x C-e= to evaluate the s-exp at point.
 [[https://www.emacswiki.org/emacs/ParEdit][ParEdit]] will protect your parentheses and keep you sane.


 [[https://github.com/clj-kondo/clj-kondo][clj-kondo]] is a linter for Clojure. It even has its own flycheck-mode, [[https://github.com/borkdude/flycheck-clj-kondo][flycheck-clj-kondo]]. We need to install it first.

 #+begin_src emacs-lisp
 (use-package flycheck-clj-kondo
   :ensure t)
 #+end_src

 #+begin_src emacs-lisp
 (use-package clojure-mode
   :defer t
   :config
   (require 'flycheck-clj-kondo))

 (use-package cider
   :defer t
   :hook ((cider-mode      . paredit-mode)
          (cider-repl-mode . paredit-mode)
		  (clojure-mode    . paredit-mode))
   :bind (:map cider-repl-mode-map ("C-l" . cider-repl-clear-buffer))
   :config
   (setq cider-repl-display-help-banner nil))
 #+end_src

 [[https://github.com/clojure-emacs/clj-refactor.el][clj-refactor]] is a CIDER extension for refactoring.

 #+begin_src emacs-lisp
 (use-package clj-refactor
   :after clojure-mode
   :hook (clojure-mode . clj-refactor-mode))
 #+end_src

 [[https://github.com/alphapapa/prism.el][prism.el]] colourises your code blocks by depth. It works especially well for Lisp
 forms. I don't have it on all the time.

 #+begin_src emacs-lisp
 (use-package prism
   :defer t)
 #+end_src

*** Coq

 [[https://proofgeneral.github.io/][Proof General]] is a generic interface for proof assistants in Emacs. This is a
 simple setup to use it with Coq.

 #+begin_src emacs-lisp
 (use-package proof-general
   :defer t)
 #+end_src

 As the [[https://coq.inria.fr/user-interfaces.html][Coq documentation]] suggests, I'll also add
 [[https://github.com/cpitclaudel/company-coq][company-coq]] for completions.

 #+begin_src emacs-lisp
 (use-package company-coq
   :defer t
   :hook (coq-mode . company-coq-mode))
 #+end_src

*** Nix

 #+begin_src emacs-lisp
 (use-package nix-mode
   :defer t)
 #+end_src

* Activating Custom Keybindings
*** Extra Keybindings

Most of my custom keybindings are bound directly in the section with the
relevant package, but here are a few extra ones.

Switch to the other window  =C-x o= \to  =M-o=.

#+begin_src emacs-lisp
(define-key custom-bindings-map (kbd "M-o") 'other-window)
#+end_src

I also plan to use =win-switch= to get nicer macros for switching and managing windows.

Run a shell command and insert the results into current buffer.

#+begin_src emacs-lisp
(define-key custom-bindings-map (kbd "M-+") #'(lambda ()
                       (interactive)
                       (let ((current-prefix-arg '(4)))
                         (call-interactively 'shell-command))))
#+end_src

*** Activating the Keymap

Throughout the configuration, I've added bindings to my custom-bindings-map.
The last thing we need to to before we can call it a day, is to define a minor
mode for it and activate that mode. The below code does just that.

#+begin_src emacs-lisp
(define-minor-mode custom-bindings-mode
  "A mode that activates custom keybindings."
  :init-value t
  :keymap custom-bindings-map)
#+end_src

* TODOs
- [ ] Find prose font that scales well with TODO boxes and verbatim code
- [ ] Check out [[https://github.com/alphapapa/org-quick-peek][org-quick-peek]]
- [X] Check out [[https://github.com/cpitclaudel/quick-peek][quick-peek]] (not on MELPA)
- [ ] Check out  [[https://github.com/oantolin/embark][embark]]
- [ ] Bind function to flash/locate cursor to =M--=
- [ ] Check out [[https://github.com/rexim/org-cliplink][org-cliplink]]
- [ ] Check out [[https://github.com/mohkale/consult-eglot/][consult-eglot]]
- [ ] Check out [[https://github.com/otavioschwanck/harpoon.el][harpoon]]
- [ ] Check out [[https://github.com/alphapapa/bufler.el][bufler]]
