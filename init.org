
#+TITLE: Sophie's Emacs Configuration
#+AUTHOR: Sophie Bosio
#+PROPERTY: header-args :tangle yes
#+STARTUP: overview

* About

This is my attempt at keeping my Emacs configuration organised and readable.

It's what's known as a "literate" configuration, meaning I write all my
initialisation code in this document as code blocks and then use
=org-babel-tangle= to extract those code blocks into a separate file. That new,
generated file becomes my =init.el=. This way, I can document my code and
explain my choices to my future self - and to anyone else who might be
interested in looking at it.

I've tried to follow the way [[https://github.com/larstvei/][Lars Tveito]] has organised [[https://github.com/larstvei/dot-emacs/blob/master/init.org][his Emacs configuration]],
and a lot of this code is lifted from his config.

I'm at the very beginning of learning Emacs, so if you have any suggestions or improvements, I would be very happy to hear about them!


* Pre-Configuration

** =init.el= Code
As mentioned, I use =org-babel-tangle= and this document, written in Org mode.

The code below extracts the elisp configuration code and creates/overwrites the
=~/.emacs.d/init.el= configuration file when the =.org=-file is saved.
Therefore, changes are only done in the =.org=-file, where writing longer
comments about how things work and why things are added is easier, and then the resulting =init.el=-file remains clean and without excessive comments.

This is what the =init.el= file should look like, prompting it to tangle the =init.org= file and replace itself with that code.

#+BEGIN_SRC emacs-lisp :tangle no
;; We need org in order to make use of the tangling functionality
(require 'org)
;; Open the org-mode configuration
(find-file (concat user-emacs-directory "init.org"))
;; Tangle the file
(org-babel-tangle)
;; Load the tangled file
(load-file (concat user-emacs-directory "init.el"))
;; Byte-compile it
(byte-compile-file (concat user-emacs-directory "init.el"))
#+END_SRC

** Git Tracking & Practicalities

Now we also don't need to track the generated =init.el= file on Git, since it is directly derived from =init.org=.

This code makes Git ignore changes to =init.el=:

#+BEGIN_SRC sh :tangle no
git update-index --assume-unchanged init.el
#+END_SRC

If you do want to start tracking the file again, you can use:

#+BEGIN_SRC sh :tangle no
git update-index --no-assume-unchanged init.el
#+END_SRC

** Lexical Scoping

First, I want lexical scoping for the =init=-file, so I will add that to the top of the file.

#+BEGIN_SRC emacs-lisp
;;; -*- lexical-binding: t -*-
#+END_SRC

** Tangling

Now to tangling! The rest of the text and code in this section is lifted directly from Lars' configuration.

The =init.el= should (after the first run) mirror the source blocks in the =init.org=. We can use =C-c C-v t= to run =org-babel-tangle=, which extracts the code blocks from the current file into a source-specific file (in this case a =.el=-file).

To avoid doing this each time a change is made we can add a function to the =after-save-hook= ensuring to always tangle and byte-compile =.org=-document after changes.

#+BEGIN_SRC emacs-lisp
   (defun tangle-init ()
     "If the current buffer is init.org the code-blocks are
   tangled, and the tangled file is compiled."
     (when (equal (buffer-file-name)
                  (expand-file-name (concat user-emacs-directory "init.org")))
       ;; Avoid running hooks when tangling.
       (let ((prog-mode-hook nil))
         (org-babel-tangle)
         (byte-compile-file (concat user-emacs-directory "init.el")))))

   (add-hook 'after-save-hook 'tangle-init)
   #+END_SRC



* Interaction, Look & Feel

** Start-Up

I want to make some tweaks to improve startup performance. First, a common tweak is to disable the garbage collector during initialisation, and then resetting it afterwards.

#+BEGIN_SRC emacs-lisp
(setq gc-cons-threshold (* 50 1000 1000))

;; Set and reset threshold
(let ((old-gc-treshold gc-cons-threshold))
  (setq gc-cons-threshold most-positive-fixnum)
  (add-hook 'after-init-hook
            (lambda () (setq gc-cons-threshold old-gc-treshold))))
#+END_SRC

Set Emacs user directory explicitly:

#+BEGIN_SRC emacs-lisp
(setq user-emacs-directory "~/.emacs.d/")
(setq default-directory "~/")
#+END_SRC

Set UFT-8 as preferred coding system.

#+BEGIN_SRC emacs-lisp
(set-language-environment "UTF-8")
#+END_SRC

** Packages

To manage downloaded packages, Emacs comes with =package.el= installed. In
addition, I want to use =use-package=, so let's make sure we have those loaded.

#+begin_src emacs-lisp
(require 'package)
(require 'use-package)
(setq use-package-always-ensure t)
#+end_src

Next, I'll set up my package sources. These are very common and well-maintained mirrors.

#+BEGIN_SRC emacs-lisp
(setq package-archives
      '(("GNU ELPA"     . "https://elpa.gnu.org/packages/")
        ("MELPA"        . "https://melpa.org/packages/")
        ("ORG"          . "https://orgmode.org/elpa/")
        ("MELPA Stable" . "https://stable.melpa.org/packages/")
        ("nongnu"       . "https://elpa.nongnu.org/nongnu/"))
      package-archive-priorities
      '(("GNU ELPA"     . 20)
        ("MELPA"        . 15)
        ("ORG"          . 10)
        ("MELPA Stable" . 5)
        ("nongnu"       . 0)))

(package-initialize)
#+END_SRC

We also want to make sure packages are automatically installed and updated. The below code installs the listed packages if they are not already on the system.

#+BEGIN_SRC emacs-lisp
(let* ((package--builtins nil)
   (packages
	'(all-the-icons        ; Icon pack for pretty displays
	  async                ; Async library
	  auctex               ; Integrated environment for *TeX*
	  auto-compile         ; Automatically compile Emacs Lisp libraries
	  auto-save-buffers-enhanced ; Auto-save buffers on change
	  chatgpt-shell        ; Interaction mode for ChatGPT
	  cider                ; Clojure Interactive Development Environment
	  clj-refactor         ; Commands for refactoring Clojure code
	  company              ; Modular text completion framework
	  counsel              ; Various completion functions using Ivy
	  consult              ; Completion, navigation and search with Vertico
	  counsel-projectile   ; Ivy integration for Projectile
	  dashboard            ; A startup screen extracted from Spacemacs
	  define-word          ; display the definition of word at point
	  diff-hl              ; Highlight uncommitted changes using VC
	  direnv               ; direnv integration
	  doom-themes          ; An opinionated pack of modern color-themes
	  editorconfig         ; EditorConfig Emacs Plugin
	  emojify              ; Display and insert emojis
	  evil-nerd-commenter  ; Language-specific commenting
	  focus                ; Dim surrounding font colour to focus on region
	  golden-ratio         ; Automatic resizing windows to golden ratio
	  haskell-mode         ; A Haskell editing mode
	  helpful              ; Easy-to-read docs that work with Counsel
	  ivy                  ; Incremental Vertical completYon
	  ivy-posframe         ; Using posframe to show Ivy
	  ivy-fuz              ; Fuzzy searching with Ivy and fuz
	  ivy-prescient        ; Sort and filter Ivy candidates
	  ivy-rich             ; Friendly display transformer for Ivy
	  jedi                 ; Python auto-completion for Emacs
	  js2-mode             ; Improved JavaScript editing mode
	  json                 ; JSON file format
	  ligature             ; Font ligatures for Emacs
	  lua-mode             ; Major-mode for editing Lua scripts
	  magit                ; Control Git from Emacs
	  markdown-mode        ; Emacs Major mode for Markdown-formatted files
      mixed-pitch          ; Intelligently decide what pitch font to use
	  multiple-cursors     ; Multiple cursors for Emacs
	  nano-modeline        ; N Λ N O modeline
	  nano-theme           ; N Λ N O theme
	  nerd-icons           ; Nerdy icons for every occasion
      obsidian             ; Obsidian note taking integration
	  ob-chatgpt-shell     ; Org babel functions for ChatGPT evaluation
	  olivetti             ; Minor mode for a nice writing environment
	  org                  ; Outline-based notes management and organizer
	  org-bullets          ; Show bullets in org-mode as UTF-8 characters
      org-modern           ; Prettify Org mode files
	  org-msg              ; Org mode to send and reply to email in HTML
	  org-superstar        ; Prettier Org mode bullets
	  ox-gfm               ; Export Github Flavored Markdown from Org
	  ox-hugo              ; Export to Blackfriday markdown, for Hugo sites
	  paredit              ; minor mode for editing parentheses
	  pdf-tools            ; Emacs support library for PDF files
	  projectile           ; Manage and navigate projects in Emacs easily
	  proof-general        ; A generic Emacs interface for proof assistants
	  racket-mode          ; Major mode for Racket language
	  rainbow-delimiters   ; Coloured bracket pairs
	  slime                ; Superior Lisp Interaction Mode for Emacs
	  smex                 ; M-x interface with Ido-style fuzzy matching
      spacemacs-theme      ; Light and dark theme from Spacemacs
	  svg-tag-mode         ; Display beautified SVG tags
	  treemacs             ; Interactive file tree
	  try                  ; Try out Emacs packages
	  vertico              ; VERTical Interactive COmpletion
	  vertico-posframe     ; Separate frame for Vertico minibuffer
	  visual-fill-column   ; Center text
	  vterm                ; A terminal via libvterm
	  which-key)))         ; Display available keybindings in popup
  (let ((packages (seq-remove 'package-installed-p packages)))
	(when packages
  ;; Install uninstalled packages
  (package-refresh-contents)
  (mapc 'package-install packages))))
#+END_SRC

I have a folder with extensions that have been downloaded manually. I'll add these to the =load-path= so Emacs knows where to look for them. My folder is called "local-extensions".

#+BEGIN_SRC emacs-lisp
(defvar local-extensions "~/.emacs.d/local-extensions/")
(add-to-list 'load-path  local-extensions)
(let ((default-directory local-extensions))
  (normal-top-level-add-subdirs-to-load-path))
#+END_SRC

And load custom settings from =custom.el= if it exists.

#+BEGIN_SRC emacs-lisp
(setq custom-file (concat user-emacs-directory "custom.el"))
(when (file-exists-p custom-file)
  (load custom-file))
#+END_SRC

** Custom Keybindings

I keep a custom keybinding map that I add to per package, and then activate at
the end of the configuration. This keeps my custom bindings from being
overwritten by extensions' own bindings.

The first step is to create the custom keybinding map. We'll activate it in the
very last section, "Custom Keybindings".

#+begin_src emacs-lisp
(defvar custom-bindings-map (make-keymap)
  "A keymap for custom keybindings.")
#+end_src

** Sane Defaults

I have some defaults that I like to have in my config. Please note that this is
behaviour that /I/ consider sane, and want in my configuration. You should
definitely modify these to your tastes!

I want to reduce the number of UI elements that I don't use, so I'll remove those and inhibit some default behaviours. I'll also make the scrolling a little smoother.

#+BEGIN_SRC emacs-lisp
(setq inhibit-startup-message      t         ;; No startup message
      initial-scratch-message      nil       ;; Empty scratch buffer
      ring-bell-function          'ignore    ;; No bell
      display-time-default-load-average nil  ;; Don't show me load time
      default-directory            "~/"      ;; Set default directory
      scroll-margin                0         ;; Space between top/bottom
      use-dialog-box               nil       ;; Disable dialog
      auto-revert-interval         1         ;; Refresh buffers fast
      echo-keystrokes              0.1       ;; Show keystrokes fast
      frame-inhibit-implied-resize 1         ;; Don't resize frame implicitly
      sentence-end-double-space    nil       ;; No double spaces
      recentf-max-saved-items 1000           ;; Show more recent files
      save-interprogram-paste-before-kill t  ;; Save copies between programs
)

(set-fringe-mode 10)  ;; Fringe of 10
#+END_SRC

Some variables are buffer-local, so to change them globally, we need to use =setq-default= instead of the normal =setq=.

#+BEGIN_SRC emacs-lisp
(setq-default tab-width 4                       ;; Smaller tabs
              fill-column 80                    ;; Maximum line width
              split-width-threshold 160         ;; Split vertically by default
              split-height-threshold nil        ;; Split vertically by default
              frame-resize-pixelwise t          ;; Fine-grained frame resize
              auto-fill-function 'do-auto-fill  ;; Auto-fill-mode everywhere
)
#+END_SRC

I don't want to type out 'yes' or 'no' every time Emacs asks me something, so I'll set these to 'y' and 'n'.

#+BEGIN_SRC emacs-lisp
(fset 'yes-or-no-p 'y-or-n-p)
#+END_SRC

Make sure we have the =all-the-icons=  and =nerd-icons= packs in order to display icons properly.

#+begin_src emacs-lisp
(require 'all-the-icons)
(require 'nerd-icons)
#+end_src

To avoid clutter, let's put all the auto-saved files into one and the same directory.

#+BEGIN_SRC emacs-lisp
(defvar emacs-autosave-directory
  (concat user-emacs-directory "autosaves/")
  "This variable dictates where to put auto saves. It is set to a
  directory called autosaves located wherever your .emacs.d/ is
  located.")

;; Sets all files to be backed up and auto saved in a single directory.
(setq backup-directory-alist
      `((".*" . ,emacs-autosave-directory))
      auto-save-file-name-transforms
      `((".*" ,emacs-autosave-directory t)))
#+END_SRC

And finally, I want scrolling to be a *lot* slower.

#+BEGIN_SRC emacs-lisp
;; Smoother scrolling
(setq mouse-wheel-scroll-amount '(1 ((shift) . 1))) ;; one line at a time
(setq mouse-wheel-progressive-speed            nil) ;; don't accelerate scrolling
(setq mouse-wheel-follow-mouse                  't) ;; scroll window under mouse
(setq scroll-step                                1) ;; keyboard scroll one line at a time
(setq use-dialog-box                           nil) ;; Disable dialog
#+END_SRC

** Personal Defaults

Some of these, I can't argue are "sane" in general - but they're what I want.

*** Appearance

I want a small border around the whole frame, because I think it looks nicer.

#+BEGIN_SRC emacs-lisp
(add-to-list 'default-frame-alist '(internal-border-width . 22))
#+END_SRC

And when I open Emacs, I want it to open maximised and fullscreen by default.

#+BEGIN_SRC emacs-lisp
(set-frame-parameter (selected-frame) 'fullscreen 'maximized)
(add-to-list 'default-frame-alist     '(fullscreen . maximized))
(add-hook 'window-setup-hook          'toggle-frame-fullscreen t)  ;; F11
#+END_SRC

When coding, I want my delimiters (parentheses, brackets, etc.) to be colourised
in pairs. [[https://github.com/Fanael/rainbow-delimiters/tree/7919681b0d883502155d5b26e791fec15da6aeca][rainbow-delimiters]] does exactly that.

#+begin_src emacs-lisp
(use-package rainbow-delimiters
  :ensure t)

(add-hook 'prog-mode-hook #'rainbow-delimiters-mode)
#+end_src

*** Auto-Saving

I prefer having my files save automatically. Any changes I don't want, I just don't commit to git. I use =auto-save-buffers-enhanced= to automatically save all buffers, not just the ones I have open.

#+BEGIN_SRC emacs-lisp
(require 'auto-save-buffers-enhanced)
(auto-save-buffers-enhanced t)
#+END_SRC

But since saving this file - the =init.org=-file - triggers recompilation of
=init.el=, it's really annoying if this file is autosaved when I write to it.
Therefore, I'll disable automatic saving for this file in particular.

#+BEGIN_SRC emacs-lisp
(setq auto-save-buffers-enhanced-exclude-regexps '("init.org"))
#+END_SRC

*** Tabs/Indentation

One of the things that drove me the most insane when I first downloaded Emacs,
was the way it deals with indentation.

I want to use spaces instead of tabs. But if I'm working on a project that does
use tabs, I don't want to mess with other people's code, so I've used this
[[https://www.emacswiki.org/emacs/NoTabs][snippet]] from the Emacs Wiki to infer indentation style.

#+begin_src emacs-lisp
(defun infer-indentation-style ()
  ;; if our source file uses tabs, we use tabs, if spaces spaces, and if
  ;; neither, we use the current indent-tabs-mode
  (let ((space-count (how-many "^  " (point-min) (point-max)))
        (tab-count (how-many "^\t" (point-min) (point-max))))
    (if (> space-count tab-count) (setq indent-tabs-mode nil))
    (if (> tab-count space-count) (setq indent-tabs-mode t))))

(setq indent-tabs-mode nil)
(infer-indentation-style)
#+end_src

I want to disable electric indent mode when switching to a new major mode.

#+begin_src emacs-lisp
(add-hook 'after-change-major-mode-hook (lambda() (electric-indent-mode -1)))
#+end_src

Make backspace remove the whole tab instead of just deleting one space.

#+begin_src emacs-lisp
(setq backward-delete-char-untabify-method 'hungry)
#+end_src

Old configuration from a blog post. Note that I'm no longer using this:

#+BEGIN_SRC emacs-lisp :tangle no
;; Create a variable for our preferred tab width
(setq custom-tab-width 2)

;; Two callable functions for enabling/disabling tabs in Emacs
(defun disable-tabs () (setq indent-tabs-mode nil))
(defun enable-tabs  ()
  (local-set-key (kbd "TAB") 'tab-to-tab-stop)
  (setq indent-tabs-mode t)
  (setq tab-width custom-tab-width))

;; Hooks to Enable Tabs
(add-hook 'prog-mode-hook 'enable-tabs)
;; Hooks to Disable Tabs
(add-hook 'lisp-mode-hook 'disable-tabs)
(add-hook 'emacs-lisp-mode-hook 'disable-tabs)

;; Language-Specific Tweaks
(setq-default python-indent-offset custom-tab-width) ;; Python
(setq-default js-indent-level custom-tab-width)      ;; Javascript

;; Making electric-indent behave sanely
;; (setq-default electric-indent-inhibit t)

;; Inhibit electric indent mode when changing to new major mode
(add-hook 'after-change-major-mode-hook (lambda() (electric-indent-mode -1)))

;; Make the backspace properly erase the tab instead of
;; removing 1 space at a time.
(setq backward-delete-char-untabify-method 'hungry)

;;Visualize tabs as a pipe character - "|"
;; This will also show trailing characters as they are useful to spot.
(setq whitespace-style '(face tabs tab-mark trailing))
(custom-set-faces
 '(whitespace-tab ((t (:foreground "#636363")))))
(setq whitespace-display-mappings
  '((tab-mark 9 [124 9] [92 9]))) ; 124 is the ascii ID for '\|'
(global-whitespace-mode) ; Enable whitespace mode everywhere
#+END_SRC

*** Deleting vs Killing

Another thing that bothered me, was how the =backward-kill-word= command (C-delete/backspace) would delete not only trailing backspaces, but everything behind it until it had deleted a word. Additionally, this was automatically added to the kill ring. With this code, it behaves more like normal Ctrl-Backspace.

#+BEGIN_SRC emacs-lisp
(defun custom/backward-kill-word ()
  "Remove all whitespace if the character behind the cursor is whitespace,
   otherwise remove a word."
  (interactive)
  (if (looking-back "[ \n]")
      ;; delete horizontal space behind us and then check to see if we
      ;; are looking at a newline
      (progn (delete-horizontal-space 't)
             (while (looking-back "[ \n]")
               (backward-delete-char 1)))
    ;; otherwise, just do the normal kill word.
    (custom/delete-dont-kill 1)))

;; Delete a word without adding it to the kill ring
(defun custom/delete-dont-kill (arg)
  "Delete characters backward until encountering the beginning of a word.
With argument ARG, do this that many times.
Don't kill, just delete."
  (interactive "p")
  (delete-region (point) (progn (backward-word arg) (point))))
(global-set-key [C-backspace] 'custom/backward-kill-word)
#+END_SRC

Speaking of killing text, it's nice to be able to browse the kill ring.

#+begin_src emacs-lisp
(use-package browse-kill-ring
  :ensure t)
#+end_src

*** Selecting Text with =expand-region=

[[https://github.com/magnars/expand-region.el/tree/master][expand-region]] is one of those packages you didn't realise you needed until you
found it. Expand the selected region with ="C-+"= or contract it again with ="-"=.

#+begin_src emacs-lisp
(use-package expand-region
  :bind (:map custom-bindings-map ("C-+" . er/expand-region)))
#+end_src

*** Language-Specific Commenting

I use =C-,= to comment/uncomment lines with [[https://github.com/redguardtoo/evil-nerd-commenter][Evil Nerd Commenter]]. It automatically
detects most programming languages and applies appropriate comment style.

#+begin_src emacs-lisp
(use-package evil-nerd-commenter
  :ensure t
  :bind (:map custom-bindings-map ("C-'" . evilnc-comment-or-uncomment-lines)))
#+end_src

*** Utilities

And finally, I want to use =ripgrep= as =grep=.

#+BEGIN_SRC emacs-lisp
(setq grep-command "rg -nS --no-heading "
      grep-use-null-device nil)
#+END_SRC

** Built-In Minor Modes

There are some default modes I want to disable.

#+BEGIN_SRC emacs-lisp
(dolist (mode
    '(tool-bar-mode        ;; Remove toolbar
      scroll-bar-mode      ;; Remove scollbars
      menu-bar-mode        ;; Remove menu bar
      blink-cursor-mode))  ;; Solid cursor, not blinking
    (funcall mode 0))
#+END_SRc

And then there are some modes that I want to activate!

#+BEGIN_SRC emacs-lisp
(dolist (mode
    '(column-number-mode        ;; Show current column number in mode line
      delete-selection-mode     ;; Replace selected text when yanking
      dirtrack-mode             ;; Directory tracking in shell
      display-battery-mode      ;; Display battery percentage in mode line
      display-time-mode         ;; Display time in mode line
      editorconfig-mode         ;; Use the editorconfig plugin
      global-company-mode       ;; Auto-completion everywhere
      global-diff-hl-mode       ;; Highlight uncommitted changes
      global-so-long-mode       ;; Mitigate performance for long lines
      global-visual-line-mode   ;; Break lines instead of truncating them
	  global-auto-revert-mode   ;; Revert buffers automatically when they change
      counsel-projectile-mode   ;; Manage and navigate projects
      recentf-mode              ;; Remember recently opened files
	  savehist-mode             ;; Remember minibuffer prompt history
	  save-place-mode           ;; Remember last cursor location in file
      show-paren-mode           ;; Highlight matching parentheses
	  which-key-mode))          ;; Available key-bindings in popup
    (funcall mode 1))

(set-fringe-mode 10)            ;; Set fringe width to 10
(setq history-length 25)        ;; Only save the last 25 minibuffer prompts
(setq global-auto-revert-non-file-buffers t) ;; Revert Dired and other buffers
#+END_SRC

And I do want line numbers, but only in programming modes.

#+BEGIN_SRC emacs-lisp
(add-hook 'prog-mode-hook 'display-line-numbers-mode) ;; Only line numbers when coding
#+END_SRC

** Fonts

For the fixed-pitch font, I'm using a ligaturised version of Roboto Mono. It's a result of the
=a-better-ligaturizer= project and the ligaturised font can be found in the
[[https://github.com/lemeb/a-better-ligaturizer][repo]].

Please note that Org-specific faces are set in the "Org, Roam, & Obsidian" section.

#+begin_src emacs-lisp
(when (member "Roboto Mono" (font-family-list))
  (set-face-attribute 'default nil :font "Roboto Mono" :height 108)
  (set-face-attribute 'fixed-pitch nil :family "Roboto Mono"))

(when (member "Source Sans 3" (font-family-list))
  (set-face-attribute 'variable-pitch nil :family "Source Sans Pro" :height 1.8))
#+end_src

=prettify-symbols-mode= displays greek letters nicely.

#+BEGIN_SRC emacs-lisp
(setq-default prettify-symbols-alist '(("lambda" . ?λ)
                                       ("delta"  . ?Δ)
                                       ("gamma"  . ?Γ)
                                       ("phi"    . ?φ)
                                       ("psi"    . ?ψ)))
#+END_SRC

The package =ligature.el= provides support for displaying the ligatures of
fonts that already have ligatures. Mine does, and seems to work just fine out
of the box with the ligatures defined on the package's page,

#+begin_src emacs-lisp
(require 'ligature)

(defvar ligature-def '("|||>" "<|||" "<==>" "<!--" "####" "~~>" "***" "||=" "||>"
                       ":::" "::=" "=:=" "===" "==>" "=!=" "=>>" "=<<" "=/=" "!=="
                       "!!." ">=>" ">>=" ">>>" ">>-" ">->" "->>" "-->" "---" "-<<"
                       "<~~" "<~>" "<*>" "<||" "<|>" "<$>" "<==" "<=>" "<=<" "<->"
                       "<--" "<-<" "<<=" "<<-" "<<<" "<+>" "</>" "###" "#_(" "..<"
                       "..." "+++" "/==" "///" "_|_" "www" "&&" "^=" "~~" "~@" "~="
                       "~>" "~-" "**" "*>" "*/" "||" "|}" "|]" "|=" "|>" "|-" "{|"
                       "[|" "]#" "::" ":=" ":>" ":<" "$>" "==" "=>" "!=" "!!" ">:"
                       ">=" ">>" ">-" "-~" "-|" "->" "--" "-<" "<~" "<*" "<|" "<:"
                       "<$" "<=" "<>" "<-" "<<" "<+" "</" "#{" "#[" "#:" "#=" "#!"
                       "##" "#(" "#?" "#_" "%%" ".=" ".-" ".." ".?" "+>" "++" "?:"
                       "?=" "?." "??" ";;" "/*" "/=" "/>" "//" "__" "~~" "(*" "*)"
                       "\\\\" "://"))

(ligature-set-ligatures 'prog-mode ligature-def)
(global-ligature-mode t)
#+end_src

I also want to be able to display emojis with the Apple emoji font.

#+BEGIN_SRC emacs-lisp
(require 'emojify)
(add-hook 'after-init-hook #'global-emojify-mode)
(when (member "Apple Color Emoji" (font-family-list))
  (set-fontset-font
    t 'symbol (font-spec :family "Apple Color Emoji") nil 'prepend))
#+END_SRC

** Themes

I really like the doom-themes, so I'll get those. My favourite for everyday use is the =doom-nord= theme.

#+BEGIN_SRC emacs-lisp
(use-package doom-themes
  :ensure t
  :config
  (setq doom-themes-enable-bold t    ; if nil, bold is universally disabled
        doom-themes-enable-italic t) ; if nil, italics is universally disabled
  (load-theme 'doom-nord t))
#+END_SRC

This theme cycling function is borrowed from Lars' [[https://github.com/larstvei/dot-emacs#theme][configuration]]. I'll bind
this function to =C-c C-t= in the "Keybindings" section.

#+begin_src emacs-lisp
(defvar favourite-themes '(doom-nord doom-nord-light doom-flatwhite))

(defun cycle-themes ()
  "Returns a function that lets you cycle your themes."
  (let ((themes favourite-themes))
    (lambda ()
      (interactive)
      ;; Rotates the thme cycle and changes the current theme.
      (let ((rotated (nconc (cdr themes) (list (car themes)))))
        (load-theme (car (setq themes rotated)) t))
      (message (concat "Switched to " (symbol-name (car themes)))))))
#+end_src

When changing themes interactively, as with =M-x load-theme=, the current custom
theme is not disabled, causing weird issues such as lingering borders. I'll advice =load-theme= to always
disable the currently enabled themes when switching.

#+begin_src emacs-lisp
(defadvice load-theme
    (before disable-before-load (theme &optional no-confirm no-enable) activate)
  (mapc 'disable-theme custom-enabled-themes))
#+end_src

** Mode Line

I really like Nicolas Rougiers [[https://github.com/rougier/nano-modeline][Nano Modeline]]. It's minimal, pretty, and has some neat built-in features, like the option to put the modeline in the header bar instead of at the bottom of the screen.

#+begin_src emacs-lisp
(require 'nano-modeline)
(nano-modeline-mode 1)
(setq nano-modeline-space-top      +0.60    ;; Space above the text
      nano-modeline-space-bottom   -0.60    ;; Space below the text
      nano-modeline-prefix         'status  ;; I want icons, not RW/RO signifiers
      nano-modeline-prefix-padding t)       ;; Padding between prefix and text
#+end_src

** Terminal

I like [[https://github.com/akermu/emacs-libvterm][vterm]] and usually just use that. I don't want it to double check with me
before killing an instance of the terminal, so I'll set it to just kill it.

I also really Lars' [[https://github.com/larstvei/dot-emacs#vterm][vterm functins]], so I'll use those as well.
They're super handy!

#+begin_src emacs-lisp
(use-package vterm
  :ensure t
  :defer  t
  :preface
  (let ((last-vterm ""))
    (defun toggle-vterm ()
      (interactive)
      (cond ((string-match-p "^\\vterm<[1-9][0-9]*>$" (buffer-name))
             (goto-non-vterm-buffer))
            ((get-buffer last-vterm) (switch-to-buffer last-vterm))
            (t (vterm (setq last-vterm "vterm<1>")))))

    (defun goto-non-vterm-buffer ()
      (let* ((r "^\\vterm<[1-9][0-9]*>$")
             (vterm-buffer-p (lambda (b) (string-match-p r (buffer-name b))))
             (non-vterms (cl-remove-if vterm-buffer-p (buffer-list))))
        (when non-vterms
          (switch-to-buffer (car non-vterms)))))

	(defun switch-vterm (n)
      (let ((buffer-name (format "vterm<%d>" n)))
        (setq last-vterm buffer-name)
        (cond ((get-buffer buffer-name)
               (switch-to-buffer buffer-name))
              (t (vterm buffer-name)
                 (rename-buffer buffer-name))))))

  :bind (:map custom-bindings-map
              ("C-z" . toggle-vterm)
              ("M-1" . (lambda () (interactive) (switch-vterm 1)))
              ("M-2" . (lambda () (interactive) (switch-vterm 2)))
              ("M-3" . (lambda () (interactive) (switch-vterm 3)))
              ("M-4" . (lambda () (interactive) (switch-vterm 4)))
              ("M-5" . (lambda () (interactive) (switch-vterm 5)))
              ("M-6" . (lambda () (interactive) (switch-vterm 6)))
              ("M-7" . (lambda () (interactive) (switch-vterm 7)))
              ("M-8" . (lambda () (interactive) (switch-vterm 8)))
              ("M-9" . (lambda () (interactive) (switch-vterm 9))))

  :config
  ;; Don't query about killing vterm buffers, just kill it
  (defadvice vterm (after kill-with-no-query nil activate)
    (set-process-query-on-exit-flag (get-buffer-process ad-return-value) nil)))
#+end_src

** Dashboard

It's perfectly fine to just land in the scratch buffer. I think it's practical
and aesthetically unproblematic. But I don't really use the scratch buffer that
much on startup - usually I just =C-x b= my way to where I need to go.

The =dashboard= extension gives you a welcoming and pretty landing buffer. I
point it to my own image, but the ='logo= banner is also really nice.

#+BEGIN_SRC emacs-lisp
(require 'dashboard)
(setq dashboard-display-icons-p     t) ;; display icons on both GUI and terminal
(setq dashboard-icon-type 'nerd-icons) ;; use `nerd-icons' package
(dashboard-setup-startup-hook)
(setq dashboard-startup-banner         "~/.emacs.d/images/lambda.png"
      dashboard-image-banner-max-width 100
      dashboard-banner-logo-title      "Welcome back!"
      dashboard-center-content         t
      dashboard-set-footer             nil
      dashboard-page-separator         "\n\n\n"
      dashboard-items '((projects     . 5)
                        (recents      . 10)
                        (agenda       . 5)))
#+END_SRC

** Olivetti

=Olivetti= is a minor mode for centering text.
For convenience, I'll bind it to =C-c C-o= to activate it on the fly.

With the the font and font size I use, setting the =fill-column= variable to 14, means I can display /exactly/ 80 mono characters before the line is folded.

#+BEGIN_SRC emacs-lisp
(use-package olivetti
  :defer t
  :bind (:map custom-bindings-map ("C-c o" . olivetti-mode))
  :config
  (setq-default olivetti-body-width (+ fill-column 14)))
#+END_SRC

** PDF Tools

This displays PDFs in a much more beautiful way.

#+BEGIN_SRC emacs-lisp
(pdf-loader-install)
#+END_SRC

However, it takes a long time to load, so we'll wait to load it until we try to open a PDF. Then it'll take a long time to open the first PDF, but all the others will load quickly, and we don't need to spend any extra start-up time when we don't need to open any PDFs.

#+BEGIN_SRC emacs-lisp
(add-hook 'pdf-view-mode-hook
          (lambda () (setq header-line-format nil)))
#+END_SRC	  

** Completion

For completions, I use [[https://github.com/minad/vertico][Vertico]] and a suite of other extensions that play well together:

- [[https://github.com/tumashu/vertico-posframe][vertico-posframe]]
- [[https://github.com/minad/consult][Consult]]
- [[https://github.com/minad/marginalia][Marginalia]]
- [[https://github.com/minad/corfu][Corfu]]
- [[https://github.com/oantolin/orderless][Orderless]]

Let's start by configuring Vertico.

#+begin_src emacs-lisp
(vertico-mode 1)
(setq vertico-count 25                       ; Show more candidates
    ; Hide unavailable commands
    read-extended-command-predicate 'command-completion-default-include-p
    read-file-name-completion-ignore-case t  ; Ignore case of file names
    read-buffer-completion-ignore-case t     ; Ignore case in buffer completion
    completion-ignore-case t                 ; Ignore case in completion
)
#+end_src

Next, I want Vertico to appear in a small child frame, instead of as a
traditional minibuffer.

#+begin_src emacs-lisp
(use-package vertico-posframe
  :config
  (vertico-posframe-mode 1)
  (setq vertico-posframe-width 100
        vertico-posframe-height vertico-count))

#+end_src

Consult provides a /ton/ of search, navigation, and completion functionality. I
would definitely recommend looking at the documentation to learn more about all
that it can do.

#+begin_src emacs-lisp
(use-package consult
  :bind (:map custom-bindings-map
              ("C-x b"   . consult-buffer)
              ("C-s"     . consult-ripgrep)
			  ("C-c C-g" . consult-goto-line)))
#+end_src

Marginalia gives me annotations in the minibuffer.

#+begin_src emacs-lisp
(use-package marginalia
  :init 
  (marginalia-mode 1))
#+end_src

Corfu gives me text completion at point.

#+begin_src emacs-lisp
(use-package corfu
  :init
  (global-corfu-mode 1)
  (corfu-popupinfo-mode 1)
  :config
  (setq corfu-cycle t
        corfu-auto t
        corfu-auto-delay 0
        corfu-auto-prefix 2
        corfu-popupinfo-delay 0.5))
#+end_src

And [[https://github.com/oantolin/orderless][Orderless]] is a package for a completion /style/, that matches multiple regexes, in any
order. Let's use it together with Corfu.

#+begin_src emacs-lisp
(use-package orderless
  :ensure t
  :config
  (setq completion-styles '(orderless basic partial-completion)
        completion-category-overrides '((file (styles basic partial-completion)))
        orderless-component-separator "[ |]"))
#+end_src

** Helpful

Helpful is an improvement on Emacs' built-in *help* buffer. It's more user-friendly and easier to read.

Since I'm using Ivy and Counsel, I already have overwritten some standard Emacs keybindings. Therefore, I'll remap Counsel's functions for describing a function and a variable to the equivalent Helpful functions.

I'll also set some global keybindings that have not already been overwritten.

#+BEGIN_SRC emacs-lisp
(setq counsel-describe-function-function #'helpful-callable  ;; C-h f
      counsel-describe-variable-function #'helpful-variable) ;; C-h v
(global-set-key (kbd "C-h x")   #'helpful-command)           ;; C-h x
(global-set-key (kbd "C-h k")   #'helpful-key)               ;; C-h k
(global-set-key (kbd "C-c C-d") #'helpful-at-point)          ;; C-c C-d
(global-set-key (kbd "C-h F")   #'helpful-function)          ;; C-h F
#+END_SRC

** TODO Spelling

** Magit

Magit is a Git client specifically for Emacs, and it's super powerful.

#+begin_src emacs-lisp
(use-package magit
  :bind (:map custom-bindings-map ("C-c m" . magit-status)))
#+end_src

** Projectile

Projectile provides a convenient project interaction interface.

#+begin_src emacs-lisp
(use-package projectile
  :bind (:map custom-bindings-map ("C-c p" . projectile-command-map)))
#+end_src

** Treemacs

I like being able to view my project as a tree - even better if that tree is
interactive! I'll bind =C-c C-t= to =treemacs= in the "Keybindings" section.


* Org, Roam, & Obsidian

** Org

[[https://orgmode.org/][Org Mode]] is a smart text system that is used for organising notes, literate programming, time management, and a wide variety of other use cases. I've been interested in switching from my previous note-taking app, Obsidian, to using Org and Roam (described in the next section).

*Note* that I've set keybindings for Org and Roam in the "Keybindings" section.

Let's first make sure we're using Org.

#+BEGIN_SRC emacs-lisp
(require 'org)
#+END_SRC

*** Prettifying

Some prettification is in order.

#+begin_src emacs-lisp
(setq org-adapt-indentation t
      org-hide-leading-stars t
      org-hide-emphasis-markers t
      org-pretty-entities t
      org-src-fontify-natively t
      org-edit-src-content-indentation 0)
#+end_src

Log when TODOs are marked as done.

#+begin_src emacs-lisp
(setq org-log-done t)
#+end_src

Next, I always want to center the text and enable linebreaks in Org. In general, I want to activate it manually, so I'll make a hook specifically for Org mode.

#+begin_src emacs-lisp
;; Enable text centering and line breaks for Org Mode
(defun org-center-style ()
  (olivetti-mode 1))

(add-hook 'org-mode-hook 'org-center-style)
#+end_src

I'll use the =org-bullets= package to prettify the document headers and lists by
turning the normal header stars into Unicode bullets.

#+begin_src emacs-lisp
(use-package org-bullets
  :config
  (add-hook 'org-mode-hook (lambda () (org-bullets-mode 1))))
#+end_src

=org-superstar= is also a nice option.

#+begin_src emacs-lisp :tangle no
(use-package org-superstar
    :config
    (setq org-superstar-special-todo-items t)
    (add-hook 'org-mode-hook (lambda ()
                               (org-superstar-mode 1))))
#+end_src

Increase the size of LaTeX previews in Org.

#+begin_src emacs-lisp
(plist-put org-format-latex-options :scale 2)
#+end_src

=org-modern= is a package that prettifies a lot of Org elements, such as
headings, lists, tables, and source code blocks.

#+begin_src emacs-lisp
(setq
 ;; Edit settings
 org-auto-align-tags nil
 org-tags-column 0
 org-catch-invisible-edits 'show-and-error
 org-special-ctrl-a/e t
 org-insert-heading-respect-content t

 ;; Org styling, hide markup etc.
 org-hide-emphasis-markers t
 org-pretty-entities t
 org-ellipsis "…"

 ;; Agenda styling
 org-agenda-tags-column 0
 org-agenda-block-separator ?─
 org-agenda-time-grid
 '((daily today require-timed)
   (800 1000 1200 1400 1600 1800 2000)
   " ┄┄┄┄┄ " "┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄")
 org-agenda-current-time-string
 "⭠ now ─────────────────────────────────────────────────")

(global-org-modern-mode)
#+end_src

*** Org Faces

Set the sizes and fonts for the various headings.

#+begin_src emacs-lisp
;; Resize Org headings
(dolist (face '((org-level-1 . 1.4)
                (org-level-2 . 1.35)
                (org-level-3 . 1.3)
                (org-level-4 . 1.2)
                (org-level-5 . 1.2)
                (org-level-6 . 1.2)
                (org-level-7 . 1.2)
                (org-level-8 . 1.2)))
  (set-face-attribute (car face) nil :font "Source Sans Pro" :weight 'bold :height (cdr face)))

;; Make the document title a bit bigger
(set-face-attribute 'org-document-title nil :font "Source Sans Pro" :weight
'bold :height 1.8)
#+END_src

Configure =org-indent= to inherit from =fixed-pitch= to fix the vertical spacing in code blocks.

#+BEGIN_src emacs-lisp :tangle no
(org-indent ((t (:inherit (org-hide fixed-pitch)))))
#+end_src

Ensure some parts of the Org-document still uses =fixed-pitch= even when
=variable-pitch-mode= is on.

#+begin_src emacs-lisp
(set-face-attribute 'org-block nil :foreground nil :inherit 'fixed-pitch)
(set-face-attribute 'org-table nil :inherit 'fixed-pitch)
(set-face-attribute 'org-formula nil :inherit 'fixed-pitch)
(set-face-attribute 'org-code nil :inherit '(shadow fixed-pitch))
(set-face-attribute 'org-verbatim nil :inherit '(shadow fixed-pitch))
(set-face-attribute 'org-special-keyword nil :inherit '(font-lock-comment-face fixed-pitch))
(set-face-attribute 'org-meta-line nil :inherit '(font-lock-comment-face fixed-pitch))
(set-face-attribute 'org-checkbox nil :inherit 'fixed-pitch)
#+end_src

[[https://gitlab.com/jabranham/mixed-pitch][mixed-pitch]] is a package that infers when to use =fixed-pitch= and =variable-pitch=.

#+begin_src emacs-lisp
(use-package mixed-pitch
  :defer t
  :hook (text-mode . mixed-pitch-mode)
  :config
  ;;(setq mixed-pitch-set-heigth t)
  ;;(set-face-attribute 'variable-pitch nil :family "Source Sans Pro" :height 1.3)
)
#+end_src

Finally, for the source code blocks, display its contents using the major mode
of the relevant language and have TAB act as it normally would when coding in
that language.

#+begin_src emacs-lisp
(setq org-src-fontify-natively t)
(setq org-src-tab-acts-natively t)
#+end_src

*** Get Things Done

I'm trying out the Get Things Done method by David Allen, using Nicolas
Rougier's [[https://github.com/rougier/emacs-gtd][GTD configuration]] and Nicolas Petton's
[[https://emacs.cafe/emacs/orgmode/gtd/2017/06/30/orgmode-gtd.html][blog post]] on the subject.

The first step is to set the relevant directories.

#+BEGIN_SRC emacs-lisp
(setq org-directory "~/Dropbox/org/")
(setq org-agenda-files (list "inbox.org"))
#+END_SRC

Then to set up the relevant capture templates, with accompanying keybindings.

#+BEGIN_SRC emacs-lisp
(setq org-capture-templates
       `(("i" "Inbox" entry  (file "inbox.org")
        ,(concat "* TODO %?\n"
                 "/Entered on/ %U"))))
(defun org-capture-inbox ()
     (interactive)
     (call-interactively 'org-store-link)
     (org-capture nil "i"))
#+END_SRC

And then I have some keybindings for these functions.

For basic agenda and TODO-related keybindings, I'll use =C-c= followed by a
single, lower-case letter.

#+BEGIN_SRC emacs-lisp
(define-key custom-bindings-map (kbd "C-c l") 'org-store-link)
(define-key custom-bindings-map (kbd "C-c a") 'org-agenda)
(define-key custom-bindings-map (kbd "C-c c") 'org-capture)
(define-key custom-bindings-map (kbd "C-c t") 'org-todo)
#+END_SRC

I have some custom =.org=-files that I use to organise different parts of my
life (see "Org & Roam" section). I'll add keybindings to capture different
types of notes, each corresponding to a an =.org=-file type.

#+BEGIN_SRC emacs-lisp
(define-key custom-bindings-map (kbd "C-c i") 'org-capture-inbox)
#+END_SRC

*** Hugo

[[https://gohugo.io/][Hugo]] is a static site generator. By default, it uses a Markdown flavour called
Blackfriday. The package =ox-hugo= can export Org files to this format, and
also generate appropriate front-matter. I use it to write my blog in Org and
easily put it online.

#+BEGIN_SRC emacs-lisp
(with-eval-after-load 'ox
  (require 'ox-hugo))
#+END_SRC

** Roam

[[https://www.orgroam.com/][Roam]] is a smart note-taking system in the style of a personal knowledge
management system. It's all in plain-text and uses Org-mode.

I'm planning to transition some/all of my notetaking from Obsidian (see below)
to Roam, but have not done so yet. Details are described in the "Obsidian" section.

** Obsidian

[[https://obsidian.md/][Obsidian]] is a smart note-taking app with similar capabilities to those of Org
Roam. I've used Obsidian for a long time, but increasingly want to do my work
in Emacs. So why not just use Roam? Well, Obsidian has a lot of very nice
graphical features and a large, helpful community dedicated to personal
knowledge management. Therefore, I still prefer it over Roam, but I would like
to be able to access and edit my Obsidian notes via Emacs. Enter the
=obsidian.el= package.

#+begin_src emacs-lisp
(require 'obsidian)
(obsidian-specify-path "~/Dropbox/obsidian-personal")
;; If you want a different directory of `obsidian-capture':
(setq obsidian-inbox-directory "Inbox")

(add-hook
 'obsidian-mode-hook
 (lambda ()
   ;; Replace standard command with Obsidian.el's in obsidian vault:
   (local-set-key (kbd "C-c C-o") 'obsidian-follow-link-at-point)


   ;; Use either `obsidian-insert-wikilink' or `obsidian-insert-link':
   (local-set-key (kbd "C-c C-l") 'obsidian-insert-wikilink)

   ;; Following backlinks
   (local-set-key (kbd "C-c C-b") 'obsidian-backlink-jump)
   
   ;; Jump to another Obsidian note
   (local-set-key (kbd "C-c C-j") 'obsidian-jump)

   ;; Capture Obsidian note
   (local-set-key (kbd "C-c C-a") 'obsidian-capture)
))

(global-obsidian-mode t)
#+end_src


* Programming Modes

** Haskell

#+BEGIN_SRC emacs-lisp
(use-package haskell-mode
  :defer t
  :hook ((haskell-mode . interactive-haskell-mode)
         (haskell-mode . haskell-doc-mode)))
#+END_SRC


* Custom Keybindings

*** Extra Keybindings

#+begin_src emacs-lisp
(use-package emacs
  :config
  (define-key custom-bindings-map (kbd "C-c C-t") (cycle-themes)))
#+end_src

*** Activating the Keymap

Throughout the configuration, I've added bindings to my custom-bindings-map.
The last thing we need to to before we can call it a day, is to define a minor
mode for it and activate that mode. The below code does just that.

#+begin_src emacs-lisp
(define-minor-mode custom-bindings-mode
  "A mode that activates custom keybindings."
  :init-value t
  :keymap custom-bindings-map)
#+end_src




