#+TITLE: Sophie's Emacs Configuration
#+AUTHOR: Sophie Bosio
#+PROPERTY: header-args :tangle yes
#+STARTUP: overview

* About

This is my attempt at keeping my Emacs configuration organised and readable.

I've tried to follow the way [[https://github.com/larstvei/][Lars Tveito]] has organised [[https://github.com/larstvei/dot-emacs/blob/master/init.org][his Emacs configuration]], including using Org mode and =org-babel-tangle= to both document and structure the configuration file.

I'm at the very beginning of learning Emacs, so if you have any suggestions or improvements, I would be very happy to hear about them!


* Pre-Configuration

** Meta
As mentioned, I use =org-babel-tangle= and this document, written in Org mode.

The code below extracts the elisp configuration code and creates/overwrites the
=~/.emacs.d/init.el= configuration file when the =.org=-file is saved.
Therefore, changes are only done in the =.org=-file, where writing longer
comments about how things work and why things are added is easier, and then the resulting =init.el=-file remains clean and without excessive comments.

This is what the =init.el= file should look like, prompting it to tangle the =init.org= file and replace itself with that code.

#+BEGIN_SRC emacs-lisp :tangle no
;; We need org in order to make use of the tangling functionality
(require 'org)
;; Open the org-mode configuration
(find-file (concat user-emacs-directory "init.org"))
;; Tangle the file
(org-babel-tangle)
;; Load the tangled file
(load-file (concat user-emacs-directory "init.el"))
;; Byte-compile it
(byte-compile-file (concat user-emacs-directory "init.el"))
#+END_SRC

** Git Tracking & Practicalities

Now we also don't need to track the generated =init.el= file on Git, since it is directly derived from =init.org=.

This code makes Git ignore changes to =init.el=:

#+BEGIN_SRC sh :tangle no
git update-index --assume-unchanged init.el
#+END_SRC

If you do want to start tracking the file again, you can use:

#+BEGIN_SRC sh :tangle no
git update-index --no-assume-unchanged init.el
#+END_SRC

** Lexical Scoping

First, I want lexical scoping for the =init=-file, so I will add that to the top of the file.

#+BEGIN_SRC emacs-lisp
;;; -*- lexical-binding: t -*-
#+END_SRC

** Tangling

Now to tangling! The rest of the text and code in this section is lifted directly from Lars' configuration.

The =init.el= should (after the first run) mirror the source blocks in the =init.org=. We can use =C-c C-v t= to run =org-babel-tangle=, which extracts the code blocks from the current file into a source-specific file (in this case a =.el=-file).

To avoid doing this each time a change is made we can add a function to the =after-save-hook= ensuring to always tangle and byte-compile =.org=-document after changes.

#+BEGIN_SRC emacs-lisp
   (defun tangle-init ()
     "If the current buffer is init.org the code-blocks are
   tangled, and the tangled file is compiled."
     (when (equal (buffer-file-name)
                  (expand-file-name (concat user-emacs-directory "init.org")))
       ;; Avoid running hooks when tangling.
       (let ((prog-mode-hook nil))
         (org-babel-tangle)
         (byte-compile-file (concat user-emacs-directory "init.el")))))

   (add-hook 'after-save-hook 'tangle-init)
   #+END_SRC



* Interaction, Look & Feel

** Start-Up

I want to make some tweaks to improve startup performance. First, a common tweak is to disable the garbage collector during initialisation, and then resetting it afterwards. At startup, I also want to know how long Emacs took to boot and how many garbage collections were made.

#+BEGIN_SRC emacs-lisp
;; The default is 800 kilobytes.  Measured in bytes.
(setq gc-cons-threshold (* 50 1000 1000))

;; Profile Emacs startup
(let ((old-gc-treshold gc-cons-threshold))
  (setq gc-cons-threshold most-positive-fixnum)
  (add-hook 'after-init-hook
            (lambda () (setq gc-cons-threshold old-gc-treshold))))

(add-hook 'emacs-startup-hook
          (lambda ()
            (message "*** Emacs loaded in %s with %d garbage collections."
                     (format "%.2f seconds"
                             (float-time
                              (time-subtract after-init-time before-init-time)))
                     gcs-done)))
#+END_SRC

Set Emacs user directory explicitly:

#+BEGIN_SRC emacs-lisp
(setq user-emacs-directory "~/.emacs.d/")
(setq default-directory "~/")
#+END_SRC

Set UFT-8 as preferred coding system.

#+BEGIN_SRC emacs-lisp
(set-language-environment "UTF-8")
#+END_SRC

** Packages

To manage downloaded packages, Emacs comes with =package.el= installed. First, we'll need to initalise that, and then I'll set elpa, melpa, and melpa stable as package sources. These are very common and well-maintained mirrors.

#+BEGIN_SRC emacs-lisp
;; First, we need package!
(require 'package)

(setq package-archives
      '(("GNU ELPA"     . "https://elpa.gnu.org/packages/")
        ("MELPA"        . "https://melpa.org/packages/")
        ("ORG"          . "https://orgmode.org/elpa/")
        ("MELPA Stable" . "https://stable.melpa.org/packages/")
        ("nongnu"       . "https://elpa.nongnu.org/nongnu/"))
      package-archive-priorities
      '(("GNU ELPA"     . 20)
        ("MELPA"        . 15)
        ("ORG"          . 10)
        ("MELPA Stable" . 5)
        ("nongnu"       . 0)))

(package-initialize)
#+END_SRC

We also want to make sure packages are automatically installed and updated. The below code installs the listed packages if they are not already on the system.

#+BEGIN_SRC emacs-lisp
  (let* ((package--builtins nil)
     (packages
      '(all-the-icons        ; Icon pack for pretty displays
        async                ; Async library
        auctex               ; Integrated environment for *TeX*
        auto-compile         ; automatically compile Emacs Lisp libraries
        chatgpt-shell        ; Interaction mode for ChatGPT
        cider                ; Clojure Interactive Development Environment
        clj-refactor         ; Commands for refactoring Clojure code
        company              ; Modular text completion framework
        counsel              ; Various completion functions using Ivy
        counsel-projectile   ; Ivy integration for Projectile
        dashboard            ; A startup screen extracted from Spacemacs
        define-word          ; display the definition of word at point
        diff-hl              ; Highlight uncommitted changes using VC
        direnv               ; direnv integration
        doom-themes          ; An opinionated pack of modern color-themes
        doom-modeline        ; Mode line used in Doom Emacs
        editorconfig         ; EditorConfig Emacs Plugin
        evil-nerd-commenter  ; Language-specific commenting
        golden-ratio         ; Automatic resizing windows to golden ratio
        haskell-mode         ; A Haskell editing mode
        helpful              ; Easy-to-read docs that work with Counsel
        ivy                  ; Incremental Vertical completYon
        ivy-posframe         ; Using posframe to show Ivy
        ivy-fuz              ; Fuzzy searching with Ivy and fuz
        ivy-prescient        ; Sort and filter Ivy candidates
        ivy-rich             ; Friendly display transformer for Ivy
        jedi                 ; Python auto-completion for Emacs
        js2-mode             ; Improved JavaScript editing mode
        json                 ; JSON file format
        ligature             ; Font ligatures for Emacs
        lua-mode             ; Major-mode for editing Lua scripts
        magit                ; Control Git from Emacs
        markdown-mode        ; Emacs Major mode for Markdown-formatted files
        maude-mode           ; Emacs mode for the programming language Maude
        multiple-cursors     ; Multiple cursors for Emacs
        nano-modeline        ; N Λ N O modeline
        nano-theme           ; N Λ N O theme
        nerd-icons           ; Nerdy icons for every occasion
        ob-chatgpt-shell     ; Org babel functions for ChatGPT evaluation
        olivetti             ; Minor mode for a nice writing environment
        org                  ; Outline-based notes management and organizer
        org-bullets          ; Show bullets in org-mode as UTF-8 characters
        org-msg              ; Org mode to send and reply to email in HTML
        ox-gfm               ; Export Github Flavored Markdown from Org
        paredit              ; minor mode for editing parentheses
        pdf-tools            ; Emacs support library for PDF files
        projectile           ; Manage and navigate projects in Emacs easily
        proof-general        ; A generic Emacs interface for proof assistants
        racket-mode          ; Major mode for Racket language
        rainbow-delimiters   ; Coloured bracket pairs
        slime                ; Superior Lisp Interaction Mode for Emacs
        smex                 ; M-x interface with Ido-style fuzzy matching
        svg-tag-mode         ; Display beautified SVG tags
        treemacs             ; Interactive file tree
        try                  ; Try out Emacs packages
        visual-fill-column   ; Center text
        vterm                ; A terminal via libvterm
        which-key)))         ; Display available keybindings in popup
    (let ((packages (seq-remove 'package-installed-p packages)))
      (when packages
    ;; Install uninstalled packages
    (package-refresh-contents)
    (mapc 'package-install packages))))
#+END_SRC

I have a folder with extensions that have been downloaded manually. I'll add these to the =load-path= so Emacs knows where to look for them. My folder is called "local-extensions".

#+BEGIN_SRC emacs-lisp
(defvar local-extensions "~/.emacs.d/local-extensions/")
(add-to-list 'load-path  local-extensions)
(let ((default-directory local-extensions))
  (normal-top-level-add-subdirs-to-load-path))
#+END_SRC

And load custom settings from =custom.el= if it exists.

#+BEGIN_SRC emacs-lisp
(setq custom-file (concat user-emacs-directory "custom.el"))
(when (file-exists-p custom-file)
  (load custom-file))
#+END_SRC

** Sane Defaults

I have some defaults that I like to have in my config. Please note that this is
behaviour that /I/ consider sane, and want in my configuration. You should
definitely modify these to your tastes!

I want to reduce the number of UI elements that I don't use, so I'll remove those and inhibit some default behaviours. I'll also make the scrolling a little smoother.

#+BEGIN_SRC emacs-lisp
(setq inhibit-startup-message      t         ;; No startup message
      initial-scratch-message      nil       ;; Empty scratch buffer
      ring-bell-function          'ignore    ;; No bell
      display-time-24hr-format     t         ;; Use 24h clock
      display-time-default-load-average nil  ;; Don't show me load time
      default-directory            "~/"      ;; Set default directory
      scroll-margin                0         ;; Space between top/bottom
      use-dialog-box               nil       ;; Disable dialog
      auto-revert-interval         1         ;; Refresh buffers fast
      echo-keystrokes              0.1       ;; Show keystrokes fast
      frame-inhibit-implied-resize 1         ;; Don't resize frame implicitly
      sentence-end-double-space    nil       ;; No double spaces
      recentf-max-saved-items 1000           ;; Show more recent files
      save-interprogram-paste-before-kill t  ;; Save copies between programs
)

(set-fringe-mode 10)  ;; Fringe of 10
#+END_SRC

Some variables are buffer-local, so to change them globally, we need to use =setq-default= instead of the normal =setq=.

#+BEGIN_SRC emacs-lisp
(setq-default tab-width 4                       ;; Smaller tabs
              fill-column 79                    ;; Maximum line width
              indent-tabs-mode nil              ;; Use spaces instead of tabs
              split-width-threshold 160         ;; Split vertically by default
              split-height-threshold nil        ;; Split vertically by default
              frame-resize-pixelwise t          ;; Fine-grained frame resize
              auto-fill-function 'do-auto-fill  ;; Auto-fill-mode everywhere
)
#+END_SRC

I don't want to type out 'yes' or 'no' every time Emacs asks me something, so I'll set these to 'y' and 'n'.

#+BEGIN_SRC emacs-lisp
(fset 'yes-or-no-p 'y-or-n-p)
#+END_SRC

To avoid clutter, let's put all the auto-saved files into one and the same directory.

#+BEGIN_SRC emacs-lisp
(defvar emacs-autosave-directory
  (concat user-emacs-directory "autosaves/")
  "This variable dictates where to put auto saves. It is set to a
  directory called autosaves located wherever your .emacs.d/ is
  located.")

;; Sets all files to be backed up and auto saved in a single directory.
(setq backup-directory-alist
      `((".*" . ,emacs-autosave-directory))
      auto-save-file-name-transforms
      `((".*" ,emacs-autosave-directory t)))
#+END_SRC

And finally, I want scrolling to be a *lot* slower.

#+BEGIN_SRC emacs-lisp
;; Smoother scrolling
(setq mouse-wheel-scroll-amount '(1 ((shift) . 1))) ;; one line at a time
(setq mouse-wheel-progressive-speed            nil) ;; don't accelerate scrolling
(setq mouse-wheel-follow-mouse                  't) ;; scroll window under mouse
(setq scroll-step                                1) ;; keyboard scroll one line at a time
(setq use-dialog-box                           nil) ;; Disable dialog
#+END_SRC

** Personal Defaults

Some of these, I can't argue are "sane" in general - but they're what I want.

I want a small border around the whole frame, because I think it looks nicer.

#+BEGIN_SRC emacs-lisp
(add-to-list 'default-frame-alist '(internal-border-width . 22))
#+END_SRC

And when I open Emacs, I want it to open maximised and fullscreen by default.

#+BEGIN_SRC emacs-lisp
(set-frame-parameter (selected-frame) 'fullscreen 'maximized)
(add-to-list 'default-frame-alist     '(fullscreen . maximized))
(add-hook 'window-setup-hook          'toggle-frame-fullscreen t)  ;; F11
#+END_SRC

I prefer having my files save automatically. Any changes I don't want, I just don't commit to git. I use =auto-save-buffers-enhanced= to automatically save all buffers, not just the ones I have open.

#+BEGIN_SRC emacs-lisp
(require 'auto-save-buffers-enhanced)
(auto-save-buffers-enhanced t)
#+END_SRC

But since saving this file - the =init.org=-file - triggers recompilation of
=init.el=, it's really annoying if this file is autosaved when I write to it.
Therefore, I'll disable automatic saving for this file in particular.

#+BEGIN_SRC emacs-lisp
(setq auto-save-buffers-enhanced-exclude-regexps '("init.org"))
#+END_SRC

One of the things that drove me the most insane when I first downloaded Emacs, was the way it deals with indentation. Specifically, how electric indent would indent regions when I entered a newline, and how adding/deleting tabs worked unexpectedly.

#+BEGIN_SRC emacs-lisp
;; Create a variable for our preferred tab width
(setq custom-tab-width 2)

;; Two callable functions for enabling/disabling tabs in Emacs
(defun disable-tabs () (setq indent-tabs-mode nil))
(defun enable-tabs  ()
  (local-set-key (kbd "TAB") 'tab-to-tab-stop)
  (setq indent-tabs-mode t)
  (setq tab-width custom-tab-width))

;; Hooks to Enable Tabs
(add-hook 'prog-mode-hook 'enable-tabs)
;; Hooks to Disable Tabs
(add-hook 'lisp-mode-hook 'disable-tabs)
(add-hook 'emacs-lisp-mode-hook 'disable-tabs)

;; Language-Specific Tweaks
(setq-default python-indent-offset custom-tab-width) ;; Python
(setq-default js-indent-level custom-tab-width)      ;; Javascript

;; Making electric-indent behave sanely
;; (setq-default electric-indent-inhibit t)

;; Inhibit electric indent mode when changing to new major mode
(add-hook 'after-change-major-mode-hook (lambda() (electric-indent-mode -1)))

;; Make the backspace properly erase the tab instead of
;; removing 1 space at a time.
(setq backward-delete-char-untabify-method 'hungry)

;;Visualize tabs as a pipe character - "|"
;; This will also show trailing characters as they are useful to spot.
(setq whitespace-style '(face tabs tab-mark trailing))
(custom-set-faces
 '(whitespace-tab ((t (:foreground "#636363")))))
(setq whitespace-display-mappings
  '((tab-mark 9 [124 9] [92 9]))) ; 124 is the ascii ID for '\|'
(global-whitespace-mode) ; Enable whitespace mode everywhere
#+END_SRC

Another thing that bothered me, was how the =backward-kill-word= command (C-delete/backspace) would delete not only trailing backspaces, but everything behind it until it had deleted a word. Additionally, this was automatically added to the kill ring. With this code, it behaves more like normal Ctrl-Backspace.

#+BEGIN_SRC emacs-lisp
(defun custom/backward-kill-word ()
  "Remove all whitespace if the character behind the cursor is whitespace,
   otherwise remove a word."
  (interactive)
  (if (looking-back "[ \n]")
      ;; delete horizontal space behind us and then check to see if we
      ;; are looking at a newline
      (progn (delete-horizontal-space 't)
             (while (looking-back "[ \n]")
               (backward-delete-char 1)))
    ;; otherwise, just do the normal kill word.
    (custom/delete-dont-kill 1)))

;; Delete a word without adding it to the kill ring
(defun custom/delete-dont-kill (arg)
  "Delete characters backward until encountering the beginning of a word.
With argument ARG, do this that many times.
Don't kill, just delete."
  (interactive "p")
  (delete-region (point) (progn (backward-word arg) (point))))
(global-set-key [C-backspace] 'custom/backward-kill-word)
#+END_SRC

And finally, I want to use =ripgrep= as =grep=.

#+BEGIN_SRC emacs-lisp
(setq grep-command "rg -nS --no-heading "
      grep-use-null-device nil)
#+END_SRC

** Built-In Minor Modes

There are some default modes I want to disable.

#+BEGIN_SRC emacs-lisp
(dolist (mode
    '(tool-bar-mode        ;; Remove toolbar
      scroll-bar-mode      ;; Remove scollbars
      menu-bar-mode        ;; Remove menu bar
      blink-cursor-mode))  ;; Solid cursor, not blinking
    (funcall mode 0))
#+END_SRc

And then there are some modes that I do want to activate!

#+BEGIN_SRC emacs-lisp
(dolist (mode
    '(column-number-mode        ;; Show current column number in mode line
      delete-selection-mode     ;; Replace selected text when yanking
      dirtrack-mode             ;; Directory tracking in shell
      display-battery-mode      ;; Display battery percentage in mode line
      display-time-mode         ;; Display time in mode line
      editorconfig-mode         ;; Use the editorconfig plugin
      global-company-mode       ;; Auto-completion everywhere
      global-diff-hl-mode       ;; Highlight uncommitted changes
      global-so-long-mode       ;; Mitigate performance for long lines
      global-visual-line-mode   ;; Break lines instead of truncating them
      counsel-projectile-mode   ;; Manage and navigate projects
      recentf-mode              ;; Recently opened files
      show-paren-mode           ;; Highlight matching parentheses
      which-key-mode))          ;; Available key-bindings in popup
    (funcall mode 1))
(set-fringe-mode 10)            ;; Set fringe width to 10
#+END_SRC

And I do want line numbers, but only in programming modes.

#+BEGIN_SRC emacs-lisp
(add-hook
   'prog-mode-hook 'display-line-numbers-mode) ;; Only line numbers when coding
#+END_SRC

** Font

I want my font to look big enough on my laptop screen, and I also want font ligatures and prettified greek letters

#+BEGIN_SRC emacs-lisp
(defvar efs/default-font-size          102)   ;; Define default font size
(defvar efs/default-variable-font-size 102)   ;; Define default variable-pitch font size

;; Set font face
(set-face-attribute 'default nil :font "JetBrainsMono NFM" :height efs/default-font-size)
(set-face-attribute 'fixed-pitch nil :font "JetBrainsMono NFM" :height efs/default-font-size)
(set-face-attribute 'variable-pitch nil :font "Segoe UI" :height efs/default-variable-font-size)

;; Font ligatures
(defvar ligatures-JetBrainsMono
  '("--" "---" "==" "===" "!=" "!==" "=!=" "=:=" "=/=" "<=" ">=" "&&" "&&&" "&=" "++" "+++"
   "***" ";;" "!!" "??" "?:" "?." "?=" "<:" ":<" ":>" ">:" "<>" "<<<" ">>>" "<<" ">>" "||" "-|"
   "_|_" "|-" "||-" "|=" "||=" "##" "###" "####" "#{" "#[" "]#" "#(" "#?" "#_" "#_(" "#:"
   "#!" "#=" "^=" "<$>" "<$" "$>" "<+>" "<+ +>" "<*>" "<* *>" "</" "</>" "/>" "<!--"
   "<#--" "-->" "->" "->>" "<<-" "<-" "<=<" "=<<" "<<=" "<==" "<=>" "<==>" "==>" "=>"
   "=>>" ">=>" ">>=" ">>-" ">-" ">--" "-<" "-<<" ">->" "<-<" "<-|" "<=|" "|=>" "|->" "<-"
   "<~~" "<~" "<~>" "~~" "~~>" "~>" "~-" "-~" "~@" "[||]" "|]" "[|" "|}" "{|" "[<" ">]"
   "|>" "<|" "||>" "<||" "|||>" "|||>" "<|>" "..." ".." ".=" ".-" "..<" ".?" "::" ":::"
   ":=" "::=" ":?" ":?>" "//" "///" "/*" "*/" "/=" "//=" "/==" "@_" "__"))
(use-package ligature
  :load-path "~/.emacs.d/elpa/ligature-20220808.1225/ligature.el"
  :config
  (ligature-set-ligatures 'prog-mode ligatures-JetBrainsMono)
  (global-ligature-mode t))

;; Prettify greek letters
(setq-default prettify-symbols-alist '(("lambda" . ?λ)
                                       ("delta" . ?Δ)
                                       ("gamma" . ?Γ)
                                       ("phi" . ?φ)
                                       ("psi" . ?ψ)))
#+END_SRC

** Themes

I really like the doom-themes, so I'll get those. I also want to be able to cycle through themes easily, so I'll use =cycle-themes.el= to do that with their standard keybinding, =C-c C-t=

#+BEGIN_SRC emacs-lisp
;; Set theme
(load-theme 'doom-nord)

;; Cycle through themes
(setq cycle-themes-theme-list
      '(doom-nord doom-miramare doom-flatwhite doom-nord-light doom-nord-aurora doom-opera))

(require 'cycle-themes)
(cycle-themes-mode)

;; Change colour of fringes to match
(add-hook 'cycle-themes-after-cycle-hook
          #'(lambda ()
              (dolist (frame (frame-list))
                (set-face-attribute 'fringe frame 
                   :background (face-background 'default)))))
#+END_SRC

** Mode Line

I really like Nicolas Rougiers [[https://github.com/rougier/nano-modeline][Nano Modeline]]. It's minimal, pretty, and has some neat built-in features, like the option to put the modeline in the header bar instead of at the bottom of the screen.

For it to display properly, we also need the =nerd-icons= icon pack.

#+BEGIN_SRC emacs-lisp
(require 'nerd-icons)
(nano-modeline-mode 1)
(setq nano-modeline-space-top      +0.60  ;; Space above the text
      nano-modeline-space-bottom   -0.60  ;; Space below the text
      nano-modeline-prefix         'icon  ;; I want icons, not RW/RO signifiers
      nano-modeline-prefix-padding t)     ;; Padding between prefix and text
#+END_SRC

TODO Display time, battery percentage, and customise icons

** TODO Eat

=eat= (Emulate A Terminal) is a terminal emulator from the Non-GNU archive, so
make sure you have that in your package archives!

#+BEGIN_SRC emacs-lisp
;; For `eat-eshell-visual-command-mode'.
(add-hook 'eshell-load-hook #'eat-eshell-visual-command-mode)
#+END_SRC

** Dashboard

It's perfectly fine to just land in the scratch buffer. I think it's practical
and aesthetically unproblematic. But I don't really use the scratch buffer that
much on startup - usually I just =C-x b= my way to where I need to go.

The =dashboard= extension gives you a welcoming and pretty landing buffer.

#+BEGIN_SRC emacs-lisp
(require 'dashboard)
(setq dashboard-display-icons-p     t) ;; display icons on both GUI and terminal
(setq dashboard-icon-type 'nerd-icons) ;; use `nerd-icons' package
(dashboard-setup-startup-hook)
(setq dashboard-startup-banner    "~/.emacs.d/emacs.png"
      dashboard-center-content    t
      dashboard-set-footer        nil
      dashboard-page-separator    "\n\n\n"
      dashboard-items '((projects . 15)
                        (recents  . 15)
                        (bookmarks . 5)))
#+END_SRC

** Olivetti

=Olivetti= is a minor mode for centering text.
For convenience, I'll bind it to =C-c C-o= to activate it on the fly.

With the the font and font size I use, setting the =fill-column= variable to 14, means I can display /exactly/ 80 mono characters before the line is folded.

#+BEGIN_SRC emacs-lisp
(require 'olivetti)
(setq-default olivetti-body-width (+ fill-column 14))
#+END_SRC

** PDF Tools

This displays PDFs in a much more beautiful way.

#+BEGIN_SRC emacs-lisp
(pdf-loader-install)
#+END_SRC

However, it takes a long time to load, so we'll wait to load it until we try to open a PDF. Then it'll take a long time to open the first PDF, but all the others will load quickly, and we don't need to spend any extra start-up time when we don't need to open any PDFs.

#+BEGIN_SRC emacs-lisp
(add-hook 'pdf-view-mode-hook
          (lambda () (setq header-line-format nil)))
#+END_SRC	  

** Ivy

Ivy is a package for "Incremental Vertical completYon", giving you fuzzy completion suggestions in the minibuffer.

#+BEGIN_SRC emacs-lisp
(setq ivy-wrap t                         ;; Scrolling up brings me to last cand.
      ivy-height 25                      ;; Make Ivy taller
      ivy-use-virtual-buffers t          ;; C-x b displays recents and bookmarks
      ivy-on-del-error-function 'ignore  ;; Let me hold in backspace
      ivy-virtual-abbreviate 'abbreviate ;; Disambiguate same file diff dirs
)
(ivy-mode 1)
#+END_SRC

Since it's so widely used, Ivy also integrates nicely with a host of other packages and extensions. Two really nice ones are Counsel, which replaces Emacs commands with Ivy-specific ones, and Swiper, which uses Ivy to display search results.

#+BEGIN_SRC emacs-lisp
(require 'counsel)
(setq enable-recursive-minibuffers t
      search-default-mode #'char-fold-to-regexp)
(global-set-key (kbd "C-s") 'swiper)
(global-set-key (kbd "C-c C-r") 'ivy-resume)
(global-set-key (kbd "<f6>") 'ivy-resume)
(global-set-key (kbd "M-x") 'counsel-M-x)
(global-set-key (kbd "C-x C-f") 'counsel-find-file)
(global-set-key (kbd "<f1> f") 'counsel-describe-function)
(global-set-key (kbd "<f1> v") 'counsel-describe-variable)
(global-set-key (kbd "<f1> o") 'counsel-describe-symbol)
(global-set-key (kbd "<f1> l") 'counsel-find-library)
(global-set-key (kbd "<f2> i") 'counsel-info-lookup-symbol)
(global-set-key (kbd "<f2> u") 'counsel-unicode-char)
(global-set-key (kbd "C-c g") 'counsel-git)
(global-set-key (kbd "C-c j") 'counsel-git-grep)
(global-set-key (kbd "C-c k") 'counsel-ag)
(global-set-key (kbd "C-x l") 'counsel-locate)
(global-set-key (kbd "C-S-o") 'counsel-rhythmbox)
(define-key minibuffer-local-map (kbd "C-r") 'counsel-minibuffer-history)
#+END_SRc

I also want to display the minibuffer as a separate child frame with =ivy-posframe=, fuzzy search with =ivy-fuz=, sorting and filtering of candidates with =ivy-prescient=, and =ivy-rich= is a display transformer making Ivy easier on the eyes. I have commented out =ivy-rich=, because it interacts poorly with =ivy-posframe= at the size that I like to keep the minibuffer.

#+BEGIN_SRC emacs-lisp
;; Posframe, to display minibuffer as a child frame
(require 'ivy-posframe)
(setq ivy-posframe-display-functions-alist '(
        (t . ivy-posframe-display)                 ;; Display the posframe
        (t . ivy-posframe-display-at-frame-center) ;; Display at frame center
    )
    ivy-posframe-width 85                          ;; Narrow box
    ivy-posframe-border-width 0                    ;; No surrounding border
)
(ivy-posframe-mode 1)

;; Fuzzy search
(setq ivy-sort-matches-functions-alist '((t . ivy-fuz-sort-fn)))
(setq ivy-re-builders-alist '((t . ivy-fuz-regex-fuzzy)))
(with-eval-after-load 'ivy
  (require 'ivy-fuz)
  (add-to-list 'ivy-highlight-functions-alist '(ivy-fuz-regex-fuzzy . ivy-fuz-highlight-fn)))

;; Sorting and filtering candidates
(with-eval-after-load 'counsel
    (require' ivy-prescient)
    (setq ivy-prescient-enable-filtering nil)
    (ivy-prescient-mode 1))

;; Display transformer for Ivy
;;(with-eval-after-load 'ivy
;;    (ivy-rich-mode 1))
#+END_SRC

** Helpful

Helpful is an improvement on Emacs' built-in *help* buffer. It's more user-friendly and easier to read.

Since I'm using Ivy and Counsel, I already have overwritten some standard Emacs keybindings. Therefore, I'll remap Counsel's functions for describing a function and a variable to the equivalent Helpful functions.

I'll also set some global keybindings that have not already been overwritten.

#+BEGIN_SRC emacs-lisp
(setq counsel-describe-function-function #'helpful-callable  ;; C-h f
      counsel-describe-variable-function #'helpful-variable) ;; C-h v
(global-set-key (kbd "C-h x") #'helpful-command)             ;; C-h x
(global-set-key (kbd "C-h k") #'helpful-key)                 ;; C-h k
(global-set-key (kbd "C-c C-d") #'helpful-at-point)          ;; C-c C-d
(global-set-key (kbd "C-h F") #'helpful-function)            ;; C-h F
#+END_SRC

** Text Auto-Completion

=company-mode= is an auto-completion framework meant to "COMPlete ANYthing". I want pretty aggressive completion suggestions.

#+BEGIN_SRC emacs-lisp
(setq company-idle-delay 0
      company-echo-delay 0
      company-dabbrev-downcase nil
      company-minimum-prefix-length 2
      company-selection-wrap-around t
      company-transformers '(company-sort-by-occurrence
                             company-sort-by-backend-importance))
#+END_SRC

** TODO Spelling

** TODO Magit

** TODO Projectile

** Treemacs

I like being able to view my project as a tree - even better if that tree is
interactive! I'll bind =C-c C-t= to =treemacs= in the "Keybindings" section.


* Org & Roam

**  Org

[[https://orgmode.org/][Org Mode]] is a smart text system that is used for organising notes, literate programming, time management, and a wide variety of other use cases. I've been interested in switching from my previous note-taking app, Obsidian, to using Org and Roam (described in the next section).

I still have a lot to learn about these modes, but I've done my best to prettify the way =.org=-files are displayed in my config.

Next, I always want to center the text and enable linebreaks in Org. In general, I want to activate it manually, so I'll make a hook specifically for Org mode.

#+begin_src emacs-lisp
;; Enable text centering and line breaks for Org Mode
(defun my/org-mode-visual-style ()
  (olivetti-mode 1))

(add-hook 'org-mode-hook 'my/org-mode-visual-style)
#+end_src

And finally, I'll use the =org-bullets= package to prettify the document headers and lists by turning the normal header stars into Unicode bullets.

#+begin_src emacs-lisp
(require 'org-bullets)
(add-hook 'org-mode-hook (lambda () (org-bullets-mode 1)))
#+end_src

** TODO Roam

[[https://www.orgroam.com/][Roam]] is a smart note-taking system in the style of a personal knowledge
management system. It's all in plain-text and uses Org-mode.


* Programming Modes

** Haskell

#+BEGIN_SRC emacs-lisp
(add-hook 'haskell-mode-hook 'interactive-haskell-mode)
(add-hook 'haskell-mode-hook 'turn-on-haskell-doc-mode)
(add-hook 'haskell-mode-hook 'turn-on-haskell-indent)
#+END_SRC


* Keybindings

Since major modes can overwrite my custom keybindings, I have done as Lars in
his config and as suggested in this Stack Overflow post, and created a custom
keymap. Then I have a minor mode that just activates the keymap, and I activate
the minor mode on startup and mode change.

** Defining the Keymap

#+BEGIN_SRC emacs-lisp
(defvar custom-bindings-map (make-keymap)
  "A keymap for custom bindings.")
#+END_SRC

** Olivetti

#+BEGIN_SRC emacs-lisp
(define-key custom-bindings-map (kbd "C-c C-o") 'olivetti-mode)
#+END_SRC

** Treemacs

#+BEGIN_SRC emacs-lisp
(define-key custom-bindings-map (kbd "C-c C-t") 'treemacs)
#+END_SRC

** Creating & Activating Minor Mode

#+BEGIN_SRC emacs-lisp
(define-minor-mode custom-bindings-mode
  "A mode that activates custom-bindings."
  t nil custom-bindings-map)
#+END_SRC
